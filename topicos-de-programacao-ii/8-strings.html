<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Tópicos de Programação II (TEP II)</title><link media="(prefers-color-scheme: light)" href=/aulas-faesa/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/aulas-faesa/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/aulas-faesa/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Tópicos de Programação II (TEP II)</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#strings-manipulação-de-textos>8.1. Strings: Manipulação de Textos</a></li><li class="toc-item level-2"><a href=#definição-e-declaração-de-uma-string>8.2. Definição e declaração de uma string</a></li><li class="toc-item level-3"><a href=#declarando-uma-string>8.2.1. Declarando uma string</a></li><li class="toc-item level-4"><a href=#a-importância-do-terminador-nulo>8.2.1.1. A importância do terminador nulo</a></li><li class="toc-item level-3"><a href=#inicializando-uma-string>8.2.2. Inicializando uma string</a></li><li class="toc-item level-3"><a href=#acessando-um-elemento-da-string>8.2.3. Acessando um elemento da string</a></li><li class="toc-item level-3"><a href=#lendo-uma-string-do-teclado>8.2.4. Lendo uma string do teclado</a></li><li class="toc-item level-4"><a href=#usando-a-função-scanf>8.2.4.1. Usando a função scanf()</a></li><li class="toc-item level-4"><a href=#usando-a-função-gets>8.2.4.2. Usando a função gets()</a></li><li class="toc-item level-4"><a href=#usando-a-função-fgets>8.2.4.3. Usando a função fgets()</a></li><li class="toc-item level-4"><a href=#limpando-o-buffer-do-teclado>8.2.4.4. Limpando o buffer do teclado</a></li><li class="toc-item level-3"><a href=#escrevendo-uma-string-na-tela>8.2.5. Escrevendo uma string na tela</a></li><li class="toc-item level-4"><a href=#usando-a-função-printf>8.2.5.1. Usando a função printf()</a></li><li class="toc-item level-4"><a href=#usando-a-função-fputs>8.2.5.2. Usando a função fputs()</a></li><li class="toc-item level-2"><a href=#funções-para-manipulação-de-strings>8.3. Funções para manipulação de strings</a></li><li class="toc-item level-3"><a href=#tamanho-de-uma-string>8.3.1. Tamanho de uma string</a></li><li class="toc-item level-3"><a href=#copiando-uma-string>8.3.2. Copiando uma string</a></li><li class="toc-item level-3"><a href=#concatenando-strings>8.3.3. Concatenando strings</a></li><li class="toc-item level-3"><a href=#comparando-duas-strings>8.3.4. Comparando duas strings</a></li><li class="toc-item level-2"><a href=#questões>8.4. Questões</a></li><li class="toc-item level-2"><a href=#próximos-passos>8.5. Próximos passos</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=7-arrays.html><i class=nav-icon data-lucide=chevron-left></i> Arrays (Vetores e Matrizes)</a><a class="sidebar-nav-link next" href=9-functions.html>Funções <i class=nav-icon data-lucide=chevron-right></i></a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>8</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>Arrays de Caracteres (Strings)</span> <span class="title-ornament right">❧</span></h1><p class=article-date>10/02/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Tópicos de Programação II</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-II>II - Linguagem C</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>Arrays de Caracteres (Strings)</span></nav></header><div class=article-body><h2 id=strings-manipulação-de-textos><span class=heading-text>Strings: Manipulação de Textos</span><span class=heading-arabic>8.1</span></h2><p>Este capítulo tem como objetivo fundamental apresentar o conceito de <strong>string</strong> na linguagem <strong>C</strong>, explorando como essa estrutura é essencial para a manipulação de palavras e textos dentro de um programa. Ao final deste estudo, você será capaz de compreender a natureza técnica das strings, além de dominar as técnicas para sua criação, inicialização e acesso aos seus elementos individuais. Adicionalmente, você aprenderá a realizar operações de entrada e saída de textos via teclado e tela, bem como a utilizar as funções bibliotecárias básicas para o processamento de cadeias de caracteres.</p><div class="callout callout-info"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=10 /><path d="M12 16v-4"/><path d="M12 8h.01"/></svg></span><span class=callout-title-inner>Objetivos de Aprendizado</span></div><div class=callout-content><ul><li>Compreender a definição de <strong>string</strong> como um caso especial de array.</li><li>Aprender a declarar e estruturar cadeias de caracteres.</li><li>Dominar os diferentes métodos de <strong>inicialização</strong> de strings.</li><li>Conhecer as formas de acessar e modificar caracteres específicos em um texto.</li><li>Praticar a <strong>leitura</strong> e a <strong>escrita</strong> de strings utilizando funções de entrada e saída.</li><li>Utilizar funções fundamentais para manipulação e análise de textos.</li></ul></div></div><h2 id=definição-e-declaração-de-uma-string><span class=heading-text>Definição e declaração de uma string</span><span class=heading-arabic>8.2</span></h2><p>Uma <strong>string</strong> é o termo técnico utilizado para definir uma sequência de caracteres posicionados de forma adjacente na memória do computador. Na linguagem <strong>C</strong>, essa estrutura, que pode representar uma palavra ou uma frase completa, é implementada fisicamente através de um <strong>array do tipo char</strong>.</p><h3 id=declarando-uma-string><span class=heading-text>Declarando uma string</span><span class=heading-arabic>8.2.1</span></h3><p>Como a string é, essencialmente, um array de caracteres, sua declaração respeita as mesmas normas sintáticas de um array convencional:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>char str[6];
</code></pre><p>Esta instrução reserva um espaço na memória para uma string de nome <code>str</code> com capacidade para 6 elementos. No entanto, você deve ter atenção redobrada a uma característica vital: as strings utilizam obrigatoriamente o caractere <strong><code>\0</code></strong> (caractere nulo) logo após a última letra da palavra ou frase armazenada.</p><p>O caractere <strong><code>\0</code></strong> serve para indicar o <strong>fim da sequência de caracteres</strong>.</p><h4 id=a-importância-do-terminador-nulo><span class=heading-text>A importância do terminador nulo</span><span class=heading-arabic>8.2.1.1</span></h4><p>A necessidade do <code>\0</code> surge porque você pode declarar uma string com um tamanho significativamente maior do que o texto que ela efetivamente armazena. Imagine que você definiu uma string com 50 posições, mas a utilizou apenas para guardar a palavra "oi". As 48 posições restantes conterão "lixo de memória" (valores aleatórios residuais).</p><p>Para evitar que esse conteúdo irrelevante seja exibido na tela, o sistema utiliza o <code>\0</code> como uma marca de interrupção. Ele sinaliza que a sequência útil de texto terminou e que as posições seguintes devem ser ignoradas:</p><pre class="line-numbers language-text" data-lang=TEXT><code class=language-text>o | i | \0 | ? | ã | # | ...
</code></pre><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Cálculo do Tamanho</span></div><div class=callout-content><p>Ao definir o tamanho de uma string, você deve sempre contabilizar o espaço extra para o caractere <code>\0</code>. Isso significa que, em uma string declarada com tamanho 50, você terá apenas <strong>49 posições disponíveis</strong> para o texto propriamente dito, pois a última vaga deve ser reservada para o sinalizador de encerramento.</p></div></div><h3 id=inicializando-uma-string><span class=heading-text>Inicializando uma string</span><span class=heading-arabic>8.2.2</span></h3><p>Uma <strong>string</strong> pode ter seu conteúdo capturado via teclado ou ser definida com um valor inicial logo no momento de sua criação. Para a inicialização direta no código, você pode adotar o mesmo princípio utilizado para vetores e matrizes, atribuindo cada caractere individualmente:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>char str[10] = { 'J', 'o', 'a', 'o', '\0' };
</code></pre><p>Contudo, como você pode notar, essa abordagem manual não é prática para textos longos. Por esse motivo, a linguagem <strong>C</strong> oferece uma forma muito mais eficiente e legível de inicialização utilizando <strong>aspas duplas</strong>:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>char str[10] = "Joao";
</code></pre><p>Além de facilitar a escrita, essa forma de inicialização possui a vantagem técnica de inserir automaticamente o caractere terminador <strong><code>\0</code></strong> ao final da sequência de caracteres, garantindo a integridade da estrutura do texto na memória.</p><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Praticidade das Aspas</span></div><div class=callout-content><p>Sempre que você souber o valor inicial de um texto, prefira o uso das aspas duplas. Elas tornam o seu código mais limpo e evitam que você esqueça de incluir manualmente o caractere de fechamento <code>\0</code>.</p></div></div><h3 id=acessando-um-elemento-da-string><span class=heading-text>Acessando um elemento da string</span><span class=heading-arabic>8.2.3</span></h3><p>Um aspecto fundamental na manipulação de <strong>strings</strong> é que, devido à sua natureza de <strong>array</strong>, cada caractere individual pode ser acessado de forma independente por meio de <strong>indexação</strong>, exatamente como você faria com qualquer outro vetor ou matriz.</p><p>Considere o exemplo abaixo, onde uma string é inicialmente definida e, posteriormente, tem seu primeiro caractere alterado:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>char str[6] = "Teste"; 
// Memória inicial: T | e | s | t | e | \0

str[0] = 'L';
// Memória após alteração: L | e | s | t | e | \0
</code></pre><p>Ao realizar essas operações, você deve estar atento à diferenciação sintática exigida pela linguagem <strong>C</strong>:</p><ul><li><strong>Aspas duplas (" ")</strong>: São utilizadas exclusivamente para a atribuição de <strong>strings</strong> completas (cadeias de caracteres).</li><li><strong>Aspas simples (' ')</strong>: São utilizadas obrigatoriamente para a atribuição de um <strong>único caractere</strong> em uma posição específica do array.</li></ul><div class="callout callout-important"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Lógica de Indexação</span></div><div class=callout-content><p>Lembre-se de que o primeiro caractere de uma string está sempre no índice <strong>0</strong>. Modificar um caractere individualmente não altera a posição do terminador nulo <code>\0</code>, a menos que você sobrescreva manualmente o próprio terminador.</p></div></div><h3 id=lendo-uma-string-do-teclado><span class=heading-text>Lendo uma string do teclado</span><span class=heading-arabic>8.2.4</span></h3><p>A leitura de cadeias de caracteres em <strong>C</strong> pode ser realizada de diversas maneiras, cada uma com comportamentos específicos em relação a espaços e limites de memória.</p><h4 id=usando-a-função-scanf><span class=heading-text>Usando a função scanf()</span><span class=heading-arabic>8.2.4.1</span></h4><p>Você pode utilizar a função <code>scanf()</code> com o formatador <code>%s</code> para capturar uma string. É importante notar que, ao ler strings com esta função, você não deve utilizar o símbolo <code>&</code> antes do nome da variável, nem os colchetes, pois o objetivo é capturar a sequência inteira e não apenas um caractere.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>char str[20];
scanf("%s", str); // Lê uma string até o primeiro espaço
</code></pre><p>No entanto, a função <code>scanf()</code> possui uma limitação crítica: ela interrompe a leitura ao encontrar o primeiro caractere de espaço. Isso a torna inadequada para ler frases, capturando apenas palavras isoladas.</p><h4 id=usando-a-função-gets><span class=heading-text>Usando a função gets()</span><span class=heading-arabic>8.2.4.2</span></h4><p>Uma alternativa para capturar frases completas é a função <code>gets()</code>. Ela lê todos os caracteres digitados, incluindo espaços, até que a tecla <em>Enter</em> seja pressionada.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>char str[20];
gets(str); // Lê a frase completa incluindo espaços
</code></pre><h4 id=usando-a-função-fgets><span class=heading-text>Usando a função fgets()</span><span class=heading-arabic>8.2.4.3</span></h4><p>A função <code>fgets()</code> é considerada uma opção mais robusta e segura para a leitura de textos. Ela exige três parâmetros: a string de destino, o tamanho máximo de caracteres e a origem da leitura (ponteiro para arquivo).</p><p>Para ler dados do teclado, você deve substituir o ponteiro de arquivo pela constante <code>stdin</code>, que representa a entrada padrão.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
   char nome[30];
   printf("Digite um nome: ");
   fgets(nome, 30, stdin); // Lê do teclado com limite de 30 caracteres
   printf("O nome digitado foi: %s", nome);
   system("pause");
   return 0;
}
</code></pre><p>A função <code>fgets()</code> apresenta vantagens importantes sobre a <code>gets()</code>:</p><ul><li><strong>Segurança</strong>: Ela limita a leitura ao tamanho especificado (ou "tamanho-1"), evitando o estouro de <em>buffer</em> caso você digite um texto maior do que o espaço reservado.</li><li><strong>Preservação do Enter</strong>: Diferente da <code>gets()</code>, o caractere de nova linha (<code>\n</code>) gerado pelo <em>Enter</em> é armazenado dentro da string final.</li></ul><h4 id=limpando-o-buffer-do-teclado><span class=heading-text>Limpando o buffer do teclado</span><span class=heading-arabic>8.2.4.4</span></h4><p>Em certas situações, resíduos de leituras anteriores no teclado podem causar falhas na captura de novas strings ou caracteres. Para evitar esses erros, você pode "limpar" a entrada padrão utilizando a função <code>setbuf(stdin, NULL)</code> antes de realizar a leitura.</p><p>Na linguagem <strong>C</strong>, a constante <code>NULL</code> representa um valor nulo. Ao associá-la ao dispositivo <code>stdin</code>, você garante que o <em>buffer</em> de entrada esteja vazio para a próxima operação.</p><div style=gap:2%;display:flex><div style=width:49%><pre class="line-numbers language-c" data-lang=C><code class=language-c>
// Limpando para caracteres
char ch;
setbuf(stdin, NULL);
scanf("%c", &ch);
</code></pre></div><div style=width:49%><pre class="line-numbers language-c" data-lang=C><code class=language-c>
// Limpando para strings
char str[10];
setbuf(stdin, NULL);
gets(str);
</code></pre></div></div><h3 id=escrevendo-uma-string-na-tela><span class=heading-text>Escrevendo uma string na tela</span><span class=heading-arabic>8.2.5</span></h3><p>A exibição de cadeias de caracteres para o usuário pode ser realizada de forma simples através de funções de saída formatada ou funções específicas de escrita de strings.</p><h4 id=usando-a-função-printf><span class=heading-text>Usando a função printf()</span><span class=heading-arabic>8.2.5.1</span></h4><p>A maneira mais comum de exibir uma string é utilizando a função <code>printf()</code> com o especificador de formato <code>%s</code>. Ao contrário da exibição de caracteres individuais, você deve referenciar apenas o nome do array, sem o uso de colchetes ou índices, para que o sistema processe a sequência completa até encontrar o terminador nulo.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>char str[20] = "Hello World";
printf("%s", str); // Exibe a string completa na tela
</code></pre><h4 id=usando-a-função-fputs><span class=heading-text>Usando a função fputs()</span><span class=heading-arabic>8.2.5.2</span></h4><p>A função <code>fputs()</code> é uma alternativa eficiente para a escrita de textos. Ela foi projetada para enviar uma string para um fluxo de saída específico, recebendo dois parâmetros: a string de origem e um ponteiro para o destino (arquivo ou dispositivo).</p><p>Para direcionar o texto diretamente para o monitor, você deve utilizar a constante <code>stdout</code>, que representa a saída padrão do sistema.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
   char texto[30] = "Hello World\n";
   
   // Escreve a string no dispositivo de saída padrão (tela)
   fputs(texto, stdout); 

   system("pause");
   return 0;
}
</code></pre><p>A função <code>fputs()</code> retorna um valor diferente de zero caso a escrita seja bem-sucedida ou a constante <code>EOF</code> (geralmente $-1$) em caso de erro. Uma característica importante a ser lembrada é que, ao contrário de outras funções de saída de strings como a <code>puts()</code>, a <code>fputs()</code> não adiciona automaticamente uma quebra de linha ao final do texto; se você precisar saltar uma linha, deverá incluir o caractere <code>\n</code> dentro da própria string.</p><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Escolha da Função</span></div><div class=callout-content><p>Enquanto o <code>printf()</code> oferece maior flexibilidade para formatar textos junto com outras variáveis, o <code>fputs()</code> é mais direto e performático para exibir mensagens de texto puras que já estão armazenadas em memória.</p></div></div><h2 id=funções-para-manipulação-de-strings><span class=heading-text>Funções para manipulação de strings</span><span class=heading-arabic>8.3</span></h2><p>A linguagem <strong>C</strong> disponibiliza na biblioteca padrão <code>&lt;string.h></code> uma série de funções desenvolvidas especificamente para facilitar o processamento e a manipulação de cadeias de caracteres. Abaixo, você conhecerá as ferramentas mais fundamentais para gerenciar textos em seus programas.</p><h3 id=tamanho-de-uma-string><span class=heading-text>Tamanho de uma string</span><span class=heading-arabic>8.3.1</span></h3><p>Para descobrir o comprimento real de um texto, você deve utilizar a função <code>strlen()</code>. É vital não confundir o tamanho total do array com a quantidade de caracteres que ele armazena no momento.</p><ul><li><strong>Funcionamento</strong>: A função <code>strlen()</code> conta e retorna apenas o número de caracteres existentes <strong>antes</strong> do caractere terminador <code>\0</code>.</li><li><strong>Exemplo</strong>: Se você declarar <code>char str[15] = "teste";</code>, a função retornará <strong>5</strong> (as letras da palavra "teste") e não <strong>15</strong> (o tamanho reservado na memória).</li></ul><h3 id=copiando-uma-string><span class=heading-text>Copiando uma string</span><span class=heading-arabic>8.3.2</span></h3><p>Como você já aprendeu, a linguagem <strong>C</strong> não permite a atribuição direta entre arrays utilizando o operador <code>=</code>. Para transferir o conteúdo de um texto para outro, é necessário realizar uma cópia elemento por elemento, tarefa que a função <code>strcpy()</code> executa automaticamente.</p><p>A sintaxe da função segue este padrão:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>strcpy(char *destino, char *origem);
</code></pre><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h> // Necessário para usar strcpy()

int main(){
   char str1[100], str2[100];
   printf("Entre com uma string: ");
   gets(str1);

   // Copia o conteúdo de str1 para str2
   strcpy(str2, str1); 

   printf("String 1: %s\n", str1);
   printf("String 2: %s\n", str2);
   system("pause");
   return 0;
}
</code></pre><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Segurança de Memória</span></div><div class=callout-content><p>Ao utilizar o <code>strcpy()</code>, você deve garantir que o array de <strong>destino</strong> seja grande o suficiente para suportar todos os caracteres da <strong>origem</strong>, incluindo o terminador nulo, para evitar o estouro de <em>buffer</em>.</p></div></div><h3 id=concatenando-strings><span class=heading-text>Concatenando strings</span><span class=heading-arabic>8.3.3</span></h3><p>A operação de concatenação consiste em anexar o conteúdo de uma string ao final de outra já existente. Para isso, utiliza-se a função <code>strcat()</code>.</p><p>O funcionamento técnico é preciso: a função <code>strcat()</code> localiza o caractere <code>\0</code> da string de destino e começa a gravar a string de origem exatamente a partir daquela posição.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>

int main(){
   char str1[15] = "bom ";
   char str2[15] = "dia";

   // Resultará em "bom dia" dentro de str1
   strcat(str1, str2); 

   printf("%s", str1);
   system("pause");
   return 0;
}
</code></pre><p>Assim como na cópia, você deve certificar-se de que o array de destino tenha espaço livre suficiente para comportar a soma das duas cadeias de caracteres.</p><h3 id=comparando-duas-strings><span class=heading-text>Comparando duas strings</span><span class=heading-arabic>8.3.4</span></h3><p>Para verificar a igualdade entre textos, você não deve usar operadores relacionais como <code>==</code>. A ferramenta correta é a função <code>strcmp()</code>.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>int strcmp(char *str1, char *str2);
</code></pre><p>A função analisa as duas strings posição por posição e retorna um valor inteiro:</p><ul><li><strong>Valor ZERO (0)</strong>: Significa que as strings são rigorosamente <strong>iguais</strong>.</li><li><strong>Valor diferente de ZERO</strong>: Significa que as strings são <strong>diferentes</strong>.</li></ul><div class="callout callout-important"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Sensibilidade a Maiúsculas</span></div><div class=callout-content><p>A função <code>strcmp()</code> é <em><strong>case-sensitive</strong></em>. Isso significa que letras maiúsculas e minúsculas são tratadas como caracteres distintos, fazendo com que "Teste" e "teste" sejam consideradas diferentes pelo programa.</p></div></div><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>

int main(){
   char str1[100], str2[100];
   printf("Entre com uma string: ");
   gets(str1);
   printf("Entre com outra string: ");
   gets(str2);

   if(strcmp(str1, str2) == 0)
       printf("Strings iguais\n");
   else
       printf("Strings diferentes\n");

   system("pause");
   return 0;
}
</code></pre><h2 id=questões><span class=heading-text>Questões</span><span class=heading-arabic>8.4</span></h2><p><strong>1.</strong> Escreva um programa em C que declare uma string com capacidade para 20 caracteres. Inicialize-a com a palavra "Teste" diretamente no código e, em seguida, imprima a string na tela.</p><ul><li><strong>Entrada:</strong> Nenhuma.</li><li><strong>Saída Esperada:</strong> Teste.</li></ul><p><strong>2.</strong> Crie um programa que leia o primeiro nome do usuário (sem espaços) utilizando a função <code>scanf</code> e, em seguida, cumprimente-o imprimindo "Ola, [Nome]!".</p><ul><li><strong>Entrada:</strong> Maria.</li><li><strong>Saída Esperada:</strong> Ola, Maria!.</li></ul><p><strong>3.</strong> Desenvolva um programa que leia uma frase completa (que pode conter espaços) digitada pelo usuário, utilizando a função <code>fgets</code>. Imprima a frase lida na tela.</p><ul><li><strong>Entrada:</strong> Aprendendo a programar em C.</li><li><strong>Saída Esperada:</strong> Aprendendo a programar em C.</li></ul><p><strong>4.</strong> Escreva um programa que leia uma palavra do usuário e imprima o <strong>tamanho</strong> dessa palavra (número de caracteres), utilizando a função <code>strlen</code>.</p><ul><li><strong>Entrada:</strong> Computador.</li><li><strong>Saída Esperada:</strong> Tamanho: 10.</li></ul><p><strong>5.</strong> Crie um programa que leia duas palavras separadamente e utilize a função <code>strcat</code> para concatená-las em uma única string, separadas por um espaço (você pode precisar adicionar o espaço manualmente ou concatenar " " entre elas). Imprima o resultado final.</p><ul><li><strong>Entrada:</strong> Bom, Dia.</li><li><strong>Saída Esperada:</strong> Bom Dia.</li></ul><p><strong>6.</strong> Escreva um programa que leia uma palavra e a armazene na variável <code>str1</code>. Utilize a função <code>strcpy</code> para copiar o conteúdo de <code>str1</code> para uma segunda variável <code>str2</code>. Imprima ambas as strings para confirmar a cópia.</p><ul><li><strong>Entrada:</strong> Copia.</li><li><strong>Saída Esperada:</strong> String 1: Copia, String 2: Copia.</li></ul><p><strong>7.</strong> Desenvolva um programa que leia duas strings e verifique se elas são iguais ou diferentes utilizando a função <code>strcmp</code>. O programa deve imprimir "Iguais" ou "Diferentes".</p><ul><li><strong>Entrada:</strong> Casa, casa.</li><li><strong>Saída Esperada:</strong> Diferentes.</li></ul><p><strong>8.</strong> (Sem usar strlen) Crie um programa que leia uma string do usuário e conte manualmente quantos caracteres ela possui (percorrendo o array até encontrar o terminador <code>\0</code>). Imprima a contagem.</p><ul><li><strong>Entrada:</strong> Teste.</li><li><strong>Saída Esperada:</strong> 5.</li></ul><p><strong>9.</strong> Escreva um programa que leia uma string e imprima as 4 primeiras letras dessa string.</p><ul><li><strong>Entrada:</strong> Paralelepipedo.</li><li><strong>Saída Esperada:</strong> Para.</li></ul><p><strong>10.</strong> Crie um programa que leia uma string e substitua todas as vogais 'a' pelo caractere '*'. Imprima a string modificada.</p><ul><li><strong>Entrada:</strong> Arara.</li><li><strong>Saída Esperada:</strong> Ar*r*. (Note que a maiúscula 'A' não deve ser alterada).</li></ul><p><strong>11.</strong> Escreva um programa que leia uma palavra e verifique se ela é um <strong>palíndromo</strong> (se pode ser lida da mesma forma de trás para frente, como "ANA" ou "RADAR"). O programa deve imprimir "Eh palindromo" ou "Nao eh palindromo".</p><ul><li><strong>Entrada:</strong> RADAR.</li><li><strong>Saída Esperada:</strong> Eh palindromo.</li></ul><p><strong>12.</strong> Crie um programa que leia uma string e a imprima de trás para frente (invertida), sem utilizar funções prontas de inversão.</p><ul><li><strong>Entrada:</strong> ABC.</li><li><strong>Saída Esperada:</strong> CBA.</li></ul><h2 id=próximos-passos><span class=heading-text>Próximos passos</span><span class=heading-arabic>8.5</span></h2><p>No próximo capítulo, <a href=9-functions.html>Funções</a>, estudaremos como criar e utilizar funções em C para organizar melhor o código, torná-lo mais modular e reutilizável, além de compreender a passagem de parâmetros, o uso de ponteiros e o acesso à memória, fundamentos essenciais para programas mais eficientes e bem estruturados.</p></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/aulas-faesa/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Tópicos de Programação II (TEP II)`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>