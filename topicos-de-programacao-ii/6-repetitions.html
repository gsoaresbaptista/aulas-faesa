<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Tópicos de Programação II (TEP II)</title><link media="(prefers-color-scheme: light)" href=/aulas-faesa/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/aulas-faesa/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/aulas-faesa/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Tópicos de Programação II (TEP II)</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#repetições>6.1. Repetições</a></li><li class="toc-item level-2"><a href=#repetição-por-condição>6.2. Repetição por Condição</a></li><li class="toc-item level-2"><a href=#laço-infinito>6.3. Laço infinito</a></li><li class="toc-item level-3"><a href=#exemplo-condição-errônea>6.3.1. Exemplo: Condição Errônea</a></li><li class="toc-item level-3"><a href=#exemplo-ausência-de-modificação-de-valor>6.3.2. Exemplo: Ausência de Modificação de Valor</a></li><li class="toc-item level-2"><a href=#comando-while>6.4. Comando while</a></li><li class="toc-item level-3"><a href=#regras-de-sintaxe-e-boas-práticas>6.4.1. Regras de Sintaxe e Boas Práticas</a></li><li class="toc-item level-2"><a href=#comando-for>6.5. Comando for</a></li><li class="toc-item level-3"><a href=#flexibilidade-e-comparação-com-o-while>6.5.1. Flexibilidade e Comparação com o while</a></li><li class="toc-item level-3"><a href=#omitindo-cláusulas-no-for>6.5.2. Omitindo Cláusulas no for</a></li><li class="toc-item level-3"><a href=#operador-de-vírgula-e-tipos-de-dados>6.5.3. Operador de Vírgula e Tipos de Dados</a></li><li class="toc-item level-2"><a href=#comando-do-while>6.6. Comando do-while</a></li><li class="toc-item level-3"><a href=#diferença-prática-entre-while-e-do-while>6.6.1. Diferença Prática entre while e do-while</a></li><li class="toc-item level-3"><a href=#regras-de-sintaxe-importantes>6.6.2. Regras de Sintaxe Importantes</a></li><li class="toc-item level-2"><a href=#aninhamento-de-repetições>6.7. Aninhamento de Repetições</a></li><li class="toc-item level-3"><a href=#aplicação-prática>6.7.1. Aplicação Prática</a></li><li class="toc-item level-2"><a href=#comando-continue>6.8. Comando continue</a></li><li class="toc-item level-2"><a href=#comando-continue>6.9. Comando continue</a></li><li class="toc-item level-3"><a href=#regras-de-uso-e-riscos-de-lógica>6.9.1. Regras de Uso e Riscos de Lógica</a></li><li class="toc-item level-2"><a href=#questões>6.10. Questões</a></li><li class="toc-item level-2"><a href=#próximos-passos>6.11. Próximos passos</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=5-conditionals.html><i class=nav-icon data-lucide=chevron-left></i> Condicionais</a><a class="sidebar-nav-link next" href=7-arrays.html>Arrays (Vetores e Matrizes) <i class=nav-icon data-lucide=chevron-right></i></a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>6</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>Repetições</span> <span class="title-ornament right">❧</span></h1><p class=article-date>10/02/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Tópicos de Programação II</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-II>II - Linguagem C</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>Repetições</span></nav></header><div class=article-body><h2 id=repetições><span class=heading-text>Repetições</span><span class=heading-arabic>6.1</span></h2><p>Este capítulo tem como objetivo fundamental apresentar o funcionamento de cada uma das estruturas de repetição disponíveis na linguagem <strong>C</strong>. Ao longo deste estudo, você desenvolverá as competências necessárias para manipular o fluxo de execução de seus programas de forma eficiente. Ao final da leitura, você será capaz de compreender e definir o conceito de um <strong>laço</strong> (<em>loop</em>), identificar e prevenir a ocorrência de um <strong>laço infinito</strong>, além de dominar a utilização prática dos comandos <strong>while</strong>, <strong>for</strong> (incluindo a técnica de omissão de cláusulas) e <strong>do-while</strong>. Adicionalmente, você aprenderá a estruturar o <strong>aninhamento de repetições</strong> e a controlar o fluxo interno desses ciclos utilizando os comandos de interrupção e salto <strong>break</strong> e <strong>continue</strong>.</p><div class="callout callout-info"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=10 /><path d="M12 16v-4"/><path d="M12 8h.01"/></svg></span><span class=callout-title-inner>Objetivos de Aprendizado</span></div><div class=callout-content><ul><li>Compreender a definição e a aplicação de um <strong>laço</strong> de repetição.</li><li>Identificar as causas e os riscos de um <strong>laço infinito</strong>.</li><li>Dominar a sintaxe e a lógica dos comandos <strong>while</strong>, <strong>for</strong> e <strong>do-while</strong>.</li><li>Aprender a flexibilizar o comando <strong>for</strong> através da omissão de cláusulas.</li><li>Desenvolver habilidades para criar <strong>repetições aninhadas</strong>.</li><li>Utilizar os comandos <strong>break</strong> e <strong>continue</strong> para o controle refinado do fluxo.</li></ul></div></div><h2 id=repetição-por-condição><span class=heading-text>Repetição por Condição</span><span class=heading-arabic>6.2</span></h2><p>Nas etapas anteriores, você aprendeu a utilizar os desvios condicionais para garantir que um bloco de comandos fosse executado apenas quando uma condição específica fosse atendida. Contudo, em diversas situações de programação, surge a necessidade de que um bloco de instruções não seja executado apenas uma única vez, mas sim repetidamente, enquanto uma determinada condição permanecer verdadeira.</p><p>A lógica fundamental dessa estrutura pode ser resumida pelo conceito: "<strong>enquanto</strong> uma condição for válida, <strong>faça</strong> a sequência de comandos". Esse processo cria um ciclo que se encerra somente quando a condição avaliada se torna falsa.</p><p>Essa dinâmica é muito semelhante ao funcionamento de um fluxograma. Neles, utilizamos o símbolo do losango para decidir entre diferentes caminhos baseados em uma resposta do tipo verdadeiro ou falso. A diferença fundamental na estrutura de repetição é que, ao atingir o final da sequência de comandos, o fluxo do programa não segue adiante, mas é desviado novamente para o ponto de avaliação da condição, reiniciando o processo.</p><div style=justify-content:center;display:flex><div style="border:1px dashed #333;border-radius:8px 0 0 8px;flex-direction:column;justify-content:center;width:225px;padding:30px;font-weight:bolder;display:flex"><p style=margin:0>Leia A e B;</p><p style=margin:0>Enquanto A &lt; B</p><p style=margin:0>     A recebe A + 1;</p><p style=margin:0>     Imprima A;</p><p style=margin:0>Fim Enquanto</p></div><div style="border:1px dashed #333;border-left:none;border-radius:0 8px 8px 0;width:300px;padding:30px"><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 235.75 322.00" data-sketch=true xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 318)" class=graph id=graph0><title>Flowchart</title><polygon points="-4,4 -4,-318 231.75,-318 231.75,4 -4,4" fill=white stroke=transparent /><g class=node id=node1><title>Inicio</title><ellipse cx=89.75 cy=-296 fill=#e1f5fe rx=27.9 ry=18 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=89.75 y=-292.9>Início</text></g><g class=node id=node3><title>ReadAB</title><path d="M113.25,-247C113.25,-247 66.25,-247 66.25,-247 60.25,-247 54.25,-241 54.25,-235 54.25,-235 54.25,-223 54.25,-223 54.25,-217 60.25,-211 66.25,-211 66.25,-211 113.25,-211 113.25,-211 119.25,-211 125.25,-217 125.25,-223 125.25,-223 125.25,-235 125.25,-235 125.25,-241 119.25,-247 113.25,-247" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=89.75 y=-225.9>Leia A e B</text></g><g class=edge id=edge1><title>Inicio->ReadAB</title><path d="M89.75,-277.92C89.75,-271.7 89.75,-264.5 89.75,-257.6" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="93.25,-257.19 89.75,-247.19 86.25,-257.19 93.25,-257.19" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node2><title>Fim</title><ellipse cx=200.75 cy=-85 fill=#e1f5fe rx=27 ry=18 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=200.75 y=-81.9>Fim</text></g><g class=node id=node4><title>Condicao</title><polygon points="89.75,-180 44.71,-162 89.75,-144 134.79,-162 89.75,-180" fill=#fff9c4 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=89.75 y=-158.9>A &lt; B?</text></g><g class=edge id=edge2><title>ReadAB->Condicao</title><path d="M89.75,-210.92C89.75,-204.7 89.75,-197.5 89.75,-190.6" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="93.25,-190.19 89.75,-180.19 86.25,-190.19 93.25,-190.19" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=edge id=edge6><title>Condicao->Fim</title><path d="M105.65,-150.25C123.46,-138.22 152.62,-118.52 173.96,-104.1" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="175.96,-106.97 182.28,-98.48 172.04,-101.17 175.96,-106.97" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=161.25 y=-121>Não</text></g><g class=node id=node5><title>SomaA</title><path d="M125.25,-103C125.25,-103 54.25,-103 54.25,-103 48.25,-103 42.25,-97 42.25,-91 42.25,-91 42.25,-79 42.25,-79 42.25,-73 48.25,-67 54.25,-67 54.25,-67 125.25,-67 125.25,-67 131.25,-67 137.25,-73 137.25,-79 137.25,-79 137.25,-91 137.25,-91 137.25,-97 131.25,-103 125.25,-103" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=89.75 y=-81.9>Some +1 em A</text></g><g class=edge id=edge3><title>Condicao->SomaA</title><path d="M89.75,-143.98C89.75,-134.94 89.75,-123.6 89.75,-113.35" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="93.25,-113.21 89.75,-103.21 86.25,-113.21 93.25,-113.21" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=98.75 y=-121>Sim</text></g><g class=node id=node6><title>PrintA</title><path d="M64.25,-36C64.25,-36 17.25,-36 17.25,-36 11.25,-36 5.25,-30 5.25,-24 5.25,-24 5.25,-12 5.25,-12 5.25,-6 11.25,0 17.25,0 17.25,0 64.25,0 64.25,0 70.25,0 76.25,-6 76.25,-12 76.25,-12 76.25,-24 76.25,-24 76.25,-30 70.25,-36 64.25,-36" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=40.75 y=-14.9>Imprima A</text></g><g class=edge id=edge4><title>SomaA->PrintA</title><path d="M76.87,-66.92C71.74,-60.11 65.71,-52.12 60.07,-44.64" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="62.52,-42.07 53.7,-36.19 56.93,-46.28 62.52,-42.07" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=edge id=edge5><title>PrintA:w->Condicao:w</title><path d="M3.75,-18C-4.27,-18 3.65,-28.06 4.75,-36 12.3,-90.44 -11.55,-153.55 33.74,-161.22" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="33.51,-164.72 43.75,-162 34.05,-157.74 33.51,-164.72" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=8.75 y=-82.5></text></g></g></svg></div></div></div></div><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Entendendo o Ciclo</span></div><div class=callout-content><p>A repetição por condição permite que você execute um conjunto de instruções quantas vezes forem necessárias, sem que precise escrever o mesmo código repetidamente. É o computador quem decide o momento de parar, baseando-se no teste lógico que você definiu.</p></div></div><h2 id=laço-infinito><span class=heading-text>Laço infinito</span><span class=heading-arabic>6.3</span></h2><p>Um <strong>laço infinito</strong> (<em>infinite loop</em>) caracteriza-se por uma sequência de comandos que se repete indefinidamente durante a execução de um programa. Essa situação é, na maioria das vezes, fruto de um erro de lógica ou de programação e ocorre principalmente por dois motivos fundamentais:</p><ul><li><strong>Ausência de uma condição de parada</strong>: Você não define um critério que interrompa o ciclo de repetição.</li><li><strong>Condição de parada inalcançável</strong>: Existe um critério de interrupção, mas, devido à lógica do código, ele nunca é satisfeito.</li></ul><p>Essencialmente, o laço infinito surge de falhas ao especificar a expressão condicional que controla a estrutura de repetição.</p><h3 id=exemplo-condição-errônea><span class=heading-text>Exemplo: Condição Errônea</span><span class=heading-arabic>6.3.1</span></h3><p>No cenário ilustrado abaixo, você pode observar um erro na lógica de atualização da variável de controle:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>X recebe 4;
enquanto (X &lt; 5) faca
    X recebe X – 1;
    Imprima X;
fim enquanto
</code></pre><p>Neste código, a variável $X$ inicia com o valor 4 e a repetição continua enquanto $X &lt; 5$. No entanto, a instrução interna subtrai uma unidade de $X$ a cada iteração ($X = X - 1$). Como o valor de $X$ torna-se cada vez menor e mais negativo, a condição $X &lt; 5$ será permanentemente verdadeira, impedindo que você saia do laço.</p><h3 id=exemplo-ausência-de-modificação-de-valor><span class=heading-text>Exemplo: Ausência de Modificação de Valor</span><span class=heading-arabic>6.3.2</span></h3><p>Outro erro frequente que produz um laço infinito é a omissão de comandos que alterem o estado das variáveis de controle dentro do bloco de repetição:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>X recebe 4;
enquanto (X &lt; 5) faca
    Imprima X;
fim enquanto
</code></pre><p>Como demonstrado acima, você define o valor de $X$ como 4 e a condição de entrada como $X &lt; 5$. Contudo, não existe nenhuma instrução dentro do laço que modifique o conteúdo de $X$. Dessa forma, a condição permanece eternamente verdadeira, fazendo com que o programa imprima o valor de $X$ sem nunca encerrar a execução.</p><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Atenção ao Desenvolver</span></div><div class=callout-content><p>Ao criar estruturas de repetição, você deve garantir que o bloco de comandos contenha uma instrução que aproxime o sistema da condição de parada. Sem essa evolução, o seu programa ficará travado em um ciclo eterno, consumindo processamento sem concluir a tarefa pretendida.</p></div></div><h2 id=comando-while><span class=heading-text>Comando while</span><span class=heading-arabic>6.4</span></h2><p>O comando <strong>while</strong> é a implementação direta na linguagem <strong>C</strong> da estrutura de repetição por condição "enquanto". Ele permite que um bloco de código seja executado repetidamente enquanto uma expressão lógica for considerada válida.</p><p>A forma geral do comando é:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>while (condição) {
    sequência de comandos;
}
</code></pre><p>Durante a execução, o funcionamento do <strong>while</strong> segue este fluxo lógico:</p><ul><li><strong>Avaliação da Condição</strong>: O programa testa a expressão entre parênteses.</li><li><strong>Condição Verdadeira</strong>: Se o resultado for diferente de zero, a sequência de comandos interna é processada. Após a execução da última instrução do bloco, o fluxo retorna automaticamente ao teste da condição para uma nova validação.</li><li><strong>Condição Falsa</strong>: Se o resultado for igual a zero, o bloco de comandos é ignorado e o programa segue para a instrução imediatamente após o fechamento das chaves.</li></ul><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 335.74 322.00" data-sketch=true width=350 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 318)" class=graph id=graph0><title>Flowchart</title><polygon points="-4,4 -4,-318 331.74,-318 331.74,4 -4,4" fill=white stroke=transparent /><g class=node id=node1><title>ScanA</title><path d="M231.74,-314C231.74,-314 149.74,-314 149.74,-314 143.74,-314 137.74,-308 137.74,-302 137.74,-302 137.74,-290 137.74,-290 137.74,-284 143.74,-278 149.74,-278 149.74,-278 231.74,-278 231.74,-278 237.74,-278 243.74,-284 243.74,-290 243.74,-290 243.74,-302 243.74,-302 243.74,-308 237.74,-314 231.74,-314" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=190.74 y=-292.9>scanf ("%d", &a);</text></g><g class=node id=node2><title>ScanB</title><path d="M231.74,-247C231.74,-247 149.74,-247 149.74,-247 143.74,-247 137.74,-241 137.74,-235 137.74,-235 137.74,-223 137.74,-223 137.74,-217 143.74,-211 149.74,-211 149.74,-211 231.74,-211 231.74,-211 237.74,-211 243.74,-217 243.74,-223 243.74,-223 243.74,-235 243.74,-235 243.74,-241 237.74,-247 231.74,-247" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=190.74 y=-225.9>scanf ("%d", &b);</text></g><g class=edge id=edge1><title>ScanA->ScanB</title><path d="M190.74,-277.92C190.74,-271.7 190.74,-264.5 190.74,-257.6" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="194.24,-257.19 190.74,-247.19 187.24,-257.19 194.24,-257.19" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node3><title>While</title><polygon points="190.74,-180 116,-162 190.74,-144 265.47,-162 190.74,-180" fill=#fff9c4 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=190.74 y=-158.9>while (a &lt; b){</text></g><g class=edge id=edge2><title>ScanB->While</title><path d="M190.74,-210.92C190.74,-204.7 190.74,-197.5 190.74,-190.6" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="194.24,-190.19 190.74,-180.19 187.24,-190.19 194.24,-190.19" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node4><title>Incremento</title><path d="M211.24,-103C211.24,-103 170.24,-103 170.24,-103 164.24,-103 158.24,-97 158.24,-91 158.24,-91 158.24,-79 158.24,-79 158.24,-73 164.24,-67 170.24,-67 170.24,-67 211.24,-67 211.24,-67 217.24,-67 223.24,-73 223.24,-79 223.24,-79 223.24,-91 223.24,-91 223.24,-97 217.24,-103 211.24,-103" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=190.74 y=-81.9>a = a + 1;</text></g><g class=edge id=edge3><title>While->Incremento:n</title><path d="M190.74,-144C190.74,-135.24 190.74,-124.13 190.74,-113.26" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="194.24,-113 190.74,-103 187.24,-113 194.24,-113" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=200.24 y=-121>SIM</text></g><g class=node id=node6><title>Continua</title><path d="M109.74,-103C109.74,-103 29.74,-103 29.74,-103 23.74,-103 17.74,-97 17.74,-91 17.74,-91 17.74,-79 17.74,-79 17.74,-73 23.74,-67 29.74,-67 29.74,-67 109.74,-67 109.74,-67 115.74,-67 121.74,-73 121.74,-79 121.74,-79 121.74,-91 121.74,-91 121.74,-97 115.74,-103 109.74,-103" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=69.74 y=-88.4>Continuação do</text><text font-family=Arial font-size=12.00 text-anchor=middle x=69.74 y=-75.4>programa</text></g><g class=edge id=edge6><title>While:w->Continua:w</title><path d="M114.74,-162C63.67,-162 -23.6,-96.56 6.47,-86.34" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="7.27,-89.76 16.74,-85 6.37,-82.82 7.27,-89.76" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=41.74 y=-121>NÃO</text></g><g class=node id=node5><title>Print</title><path d="M270.74,-36C270.74,-36 186.74,-36 186.74,-36 180.74,-36 174.74,-30 174.74,-24 174.74,-24 174.74,-12 174.74,-12 174.74,-6 180.74,0 186.74,0 186.74,0 270.74,0 270.74,0 276.74,0 282.74,-6 282.74,-12 282.74,-12 282.74,-24 282.74,-24 282.74,-30 276.74,-36 270.74,-36" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=228.74 y=-14.9>printf ("%d \n", a);</text></g><g class=edge id=edge4><title>Incremento->Print</title><path d="M200.72,-66.92C204.62,-60.26 209.17,-52.47 213.46,-45.13" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="216.66,-46.59 218.69,-36.19 210.62,-43.06 216.66,-46.59" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=edge id=edge5><title>Print:e->While:e</title><path d="M283.74,-18C344.66,-18 332.8,-146.68 276.88,-160.76" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="276.23,-157.31 266.74,-162 277.09,-164.26 276.23,-157.31" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=325.74 y=-82.5></text></g></g></svg></div></div><p>O exemplo abaixo demonstra um programa que solicita dois números inteiros ao usuário e imprime todos os valores existentes entre eles:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int a, b;
    printf("Digite o valor de a: ");
    scanf("%d", &a);
    printf("Digite o valor de b: ");
    scanf("%d", &b);

    while (a &lt; b){
        a = a + 1;
        printf("%d \n", a);
    }

    system("pause");
    return 0;
}
</code></pre><h3 id=regras-de-sintaxe-e-boas-práticas><span class=heading-text>Regras de Sintaxe e Boas Práticas</span><span class=heading-arabic>6.4.1</span></h3><p>Assim como você aprendeu no estudo do comando <strong>if</strong>, o <strong>while</strong> compartilha diversas regras estruturais essenciais:</p><ul><li><strong>Expressões Lógicas</strong>: A condição pode ser qualquer expressão que utilize operadores matemáticos, relacionais ou lógicos, desde que resulte em um valor falso (zero) ou verdadeiro (diferente de zero).</li><li><strong>Uso de Chaves</strong>: O comando atua apenas sobre a instrução imediatamente seguinte. Para executar um conjunto de comandos, você deve obrigatoriamente delimitá-los entre chaves <code>{ }</code>.</li><li><strong>Ponto e Vírgula</strong>: Nunca utilize o ponto e vírgula (<code>;</code>) logo após a condição.</li></ul><div class="callout callout-danger"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1=12 x2=12 y1=9 y2=13 /><line x1=12 x2=12 y1=17 y2=17.01 /></svg></span><span class=callout-title-inner>Erro Comum: Ponto e Vírgula após a Condição</span></div><div class=callout-content><p>Inserir um <code>;</code> após o parêntese do <strong>while</strong> faz com que o compilador interprete que o laço terminou ali mesmo, possuindo um corpo vazio. Veja o exemplo do impacto negativo desta prática:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>while (a &lt; b); { // ERRADO! O ponto e vírgula interrompe o laço.
    a = a + 1;   // Este comando agora está FORA do while.
    printf("%d \n", a);
}
</code></pre><p>No código acima, se a condição inicial for verdadeira, você criará um <strong>laço infinito</strong>, pois as variáveis de controle nunca serão alteradas dentro do laço vazio.</p></div></div><p><strong>Lembre-se:</strong> é sua total responsabilidade como programador garantir que o valor de algum elemento da condição seja modificado dentro do bloco de comandos, assegurando que o programa eventualmente atinja a condição de parada.</p><h2 id=comando-for><span class=heading-text>Comando for</span><span class=heading-arabic>6.5</span></h2><p>O comando <strong>for</strong> possui uma funcionalidade muito similar ao <strong>while</strong>, sendo projetado para repetir um comando ou um bloco de instruções diversas vezes. Sua principal característica é a capacidade de condensar a inicialização, a condição de parada e a atualização das variáveis em uma única linha.</p><p>A forma geral do comando é:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>for (inicialização; condição; incremento) {
    sequência de comandos;
}
</code></pre><p>Durante a execução deste laço, você deve observar a seguinte sequência de passos:</p><ul><li><strong>Inicialização</strong>: Esta cláusula é executada apenas uma vez, no início do processo. Nela, você atribui valores iniciais às variáveis que controlam o laço.</li><li><strong>Teste de Condição</strong>: Antes de cada repetição, a expressão lógica é avaliada.<ul><li>Se for <strong>verdadeira</strong> (valor diferente de zero), o bloco de comandos interno é executado.</li><li>Se for <strong>falsa</strong> (zero), o laço é encerrado imediatamente.</li></ul></li><li><strong>Incremento</strong>: Após a execução dos comandos internos, o programa executa a etapa de incremento ou atualização das variáveis. Finalizada esta etapa, o fluxo retorna ao teste de condição.</li></ul><p>O código abaixo exemplifica o uso do <strong>for</strong> para imprimir todos os números inteiros entre dois valores, <strong>a</strong> e <strong>b</strong>, fornecidos por você:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int a, b, c;
    printf("Digite o valor de a: ");
    scanf("%d", &a);
    printf("Digite o valor de b: ");
    scanf("%d", &b);

    for (c = a; c &lt;= b; c++){
        printf("%d \n", c);
    }

    system("pause");
    return 0;
}
</code></pre><p>Podemos ter uma visão diferente, talvez mais intuitiva para você, através do seguinte diagrama de blocos:</p><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 246.50 389.00" data-sketch=true width=300 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 385)" class=graph id=graph0><title>Flowchart</title><polygon points="-4,4 -4,-385 242.5,-385 242.5,4 -4,4" fill=white stroke=transparent /><g class=node id=node1><title>Decl</title><path d="M204,-381C204,-381 161,-381 161,-381 155,-381 149,-375 149,-369 149,-369 149,-357 149,-357 149,-351 155,-345 161,-345 161,-345 204,-345 204,-345 210,-345 216,-351 216,-357 216,-357 216,-369 216,-369 216,-375 210,-381 204,-381" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=182.5 y=-359.9>int a, b, c;</text></g><g class=node id=node2><title>ScanA</title><path d="M222,-314C222,-314 143,-314 143,-314 137,-314 131,-308 131,-302 131,-302 131,-290 131,-290 131,-284 137,-278 143,-278 143,-278 222,-278 222,-278 228,-278 234,-284 234,-290 234,-290 234,-302 234,-302 234,-308 228,-314 222,-314" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=182.5 y=-292.9>scanf ("%d",&a);</text></g><g class=edge id=edge1><title>Decl->ScanA</title><path d="M182.5,-344.92C182.5,-338.7 182.5,-331.5 182.5,-324.6" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="186,-324.19 182.5,-314.19 179,-324.19 186,-324.19" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node3><title>ScanB</title><path d="M222,-247C222,-247 143,-247 143,-247 137,-247 131,-241 131,-235 131,-235 131,-223 131,-223 131,-217 137,-211 143,-211 143,-211 222,-211 222,-211 228,-211 234,-217 234,-223 234,-223 234,-235 234,-235 234,-241 228,-247 222,-247" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=182.5 y=-225.9>scanf ("%d",&b);</text></g><g class=edge id=edge2><title>ScanA->ScanB</title><path d="M182.5,-277.92C182.5,-271.7 182.5,-264.5 182.5,-257.6" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="186,-257.19 182.5,-247.19 179,-257.19 186,-257.19" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node4><title>ForInit</title><path d="M205,-180C205,-180 160,-180 160,-180 154,-180 148,-174 148,-168 148,-168 148,-156 148,-156 148,-150 154,-144 160,-144 160,-144 205,-144 205,-144 211,-144 217,-150 217,-156 217,-156 217,-168 217,-168 217,-174 211,-180 205,-180" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=182.5 y=-158.9>for (c = a);</text></g><g class=edge id=edge3><title>ScanB->ForInit</title><path d="M182.5,-210.92C182.5,-204.7 182.5,-197.5 182.5,-190.6" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="186,-190.19 182.5,-180.19 179,-190.19 186,-190.19" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node5><title>ForCond</title><polygon points="182.5,-113 137.46,-95 182.5,-77 227.54,-95 182.5,-113" fill=#fff9c4 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=182.5 y=-91.9>c &lt;= b;</text></g><g class=edge id=edge4><title>ForInit->ForCond</title><path d="M182.5,-143.92C182.5,-137.7 182.5,-130.5 182.5,-123.6" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="186,-123.19 182.5,-113.19 179,-123.19 186,-123.19" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node7><title>Print</title><path d="M93,-36C93,-36 12,-36 12,-36 6,-36 0,-30 0,-24 0,-24 0,-12 0,-12 0,-6 6,0 12,0 12,0 93,0 93,0 99,0 105,-6 105,-12 105,-12 105,-24 105,-24 105,-30 99,-36 93,-36" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=52.5 y=-14.9>printf("%d \n",c);}</text></g><g class=edge id=edge5><title>ForCond->Print</title><path d="M164.97,-83.89C146.08,-72.99 115.43,-55.31 90.9,-41.15" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="92.58,-38.08 82.17,-36.12 89.08,-44.15 92.58,-38.08" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=134 y=-54>SIM</text></g><g class=node id=node8><title>Continua</title><path d="M226.5,-36C226.5,-36 146.5,-36 146.5,-36 140.5,-36 134.5,-30 134.5,-24 134.5,-24 134.5,-12 134.5,-12 134.5,-6 140.5,0 146.5,0 146.5,0 226.5,0 226.5,0 232.5,0 238.5,-6 238.5,-12 238.5,-12 238.5,-24 238.5,-24 238.5,-30 232.5,-36 226.5,-36" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=186.5 y=-21.4>Continuação do</text><text font-family=Arial font-size=12.00 text-anchor=middle x=186.5 y=-8.4>programa</text></g><g class=edge id=edge8><title>ForCond->Continua</title><path d="M183.41,-76.98C183.89,-67.94 184.49,-56.6 185.04,-46.35" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="188.54,-46.38 185.58,-36.21 181.55,-46.01 188.54,-46.38" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=195.5 y=-54>NÃO</text></g><g class=node id=node6><title>ForInc</title><path d="M67.5,-113C67.5,-113 37.5,-113 37.5,-113 31.5,-113 25.5,-107 25.5,-101 25.5,-101 25.5,-89 25.5,-89 25.5,-83 31.5,-77 37.5,-77 37.5,-77 67.5,-77 67.5,-77 73.5,-77 79.5,-83 79.5,-89 79.5,-89 79.5,-101 79.5,-101 79.5,-107 73.5,-113 67.5,-113" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=52.5 y=-91.9>c++){</text></g><g class=edge id=edge7><title>ForInc->ForCond</title><path d="M79.67,-95C95.37,-95 111.08,-95 126.79,-95" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="127.11,-98.5 137.11,-95 127.11,-91.5 127.11,-98.5" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=edge id=edge6><title>Print->ForInc</title><path d="M52.5,-36.21C52.5,-45.29 52.5,-56.64 52.5,-66.87" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="49,-66.98 52.5,-76.98 56,-66.98 49,-66.98" fill=#333333 stroke=#333333 stroke-width=1.2 /></g></g></svg></div></div><h3 id=flexibilidade-e-comparação-com-o-while><span class=heading-text>Flexibilidade e Comparação com o while</span><span class=heading-arabic>6.5.1</span></h3><p>O comando <strong>for</strong> respeita as mesmas normas de sintaxe que o <strong>if</strong> e o <strong>while</strong>: a condição pode envolver qualquer expressão lógica ou matemática, e o uso de chaves <code>{ }</code> é indispensável para agrupar múltiplos comandos. Para facilitar a compreensão, veja como uma mesma tarefa (somar números de 1 a 10) pode ser escrita em ambas as estruturas:</p><div style=gap:2%;display:flex><div style=width:49%><pre class="line-numbers language-c" data-lang=C><code class=language-c>
// Versão com FOR
for(i = 1; i &lt;= 10; i++){
    s = s + i;
}
</code></pre></div><div style=width:49%><pre class="line-numbers language-c" data-lang=C><code class=language-c>
// Versão com WHILE
i = 1;
while (i &lt;= 10){
    s = s + i;
    i++;
}
</code></pre></div></div><h3 id=omitindo-cláusulas-no-for><span class=heading-text>Omitindo Cláusulas no for</span><span class=heading-arabic>6.5.2</span></h3><p>Você pode omitir qualquer uma das três cláusulas do <strong>for</strong> (inicialização, condição ou incremento), dependendo da lógica do seu programa. Entretanto, é obrigatório manter os dois operadores de ponto e vírgula (<code>;</code>), que servem como delimitadores para o compilador.</p><ul><li><strong>Sem Inicialização</strong>: Útil quando a variável de controle já foi definida anteriormente no código.<pre class="line-numbers language-c" data-lang=C><code class=language-c>for (; a &lt;= b; a++) { ... }
</code></pre></li><li><strong>Sem Condição</strong>: Cria um <strong>laço infinito</strong>, pois a ausência de teste é interpretada como uma condição sempre verdadeira.<pre class="line-numbers language-c" data-lang=C><code class=language-c>for (c = a; ; c++) { ... }
</code></pre></li><li><strong>Sem Incremento</strong>: Frequentemente utilizado quando a atualização da variável ocorre de forma personalizada dentro do bloco de comandos.<pre class="line-numbers language-c" data-lang=C><code class=language-c>for (c = a; c &lt;= b; ) {
    printf("%d \n", c);
    c++; // Incremento manual
}
</code></pre></li></ul><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Além do Simples Incremento</span></div><div class=callout-content><p>A cláusula de incremento não se limita ao operador <code>++</code>. Você pode utilizar qualquer instrução que altere o valor da variável, como <code>c = c + 2</code> ou até mesmo um comando <code>scanf()</code>.</p></div></div><h3 id=operador-de-vírgula-e-tipos-de-dados><span class=heading-text>Operador de Vírgula e Tipos de Dados</span><span class=heading-arabic>6.5.3</span></h3><p>O operador vírgula (<code>,</code>) funciona como um separador, permitindo que você execute múltiplas instruções sequencialmente dentro das cláusulas do <strong>for</strong>. Isso possibilita, por exemplo, controlar duas variáveis simultaneamente no mesmo laço:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>for (i = 0, j = 100; i &lt; j; i++, j--) {
    printf("i = %d e j = %d \n", i, j);
}
</code></pre><p>Além disso, a variável de controle não precisa ser apenas do tipo <code>int</code>. Você pode utilizar uma variável do tipo <code>char</code> para percorrer, por exemplo, o alfabeto de 'A' até 'Z'.</p><h2 id=comando-do-while><span class=heading-text>Comando do-while</span><span class=heading-arabic>6.6</span></h2><p>O comando <strong>do-while</strong> é uma estrutura de repetição bastante similar ao <strong>while</strong>, porém com uma diferença fundamental na ordem de processamento: enquanto o <strong>while</strong> avalia a condição antes de executar os comandos, o <strong>do-while</strong> executa o bloco de instruções primeiro para somente depois testar a condição.</p><p>A forma geral do comando é:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>do {
    sequência de comandos;
} while (condição);
</code></pre><p>Ao utilizar o <strong>do-while</strong>, você garante que o programa siga esta ordem de execução:</p><ul><li><strong>Execução Inicial</strong>: A sequência de comandos dentro das chaves é processada imediatamente.</li><li><strong>Avaliação da Condição</strong>: Após a execução do bloco, o programa testa a expressão lógica.<ul><li>Se for <strong>verdadeira</strong> (valor diferente de zero), o fluxo retorna ao comando <code>do</code>, repetindo o bloco.</li><li>Se for <strong>falsa</strong> (zero), o laço é encerrado.</li></ul></li></ul><h3 id=diferença-prática-entre-while-e-do-while><span class=heading-text>Diferença Prática entre while e do-while</span><span class=heading-arabic>6.6.1</span></h3><p>A escolha entre essas duas estruturas depende de quantas vezes você precisa que o código seja executado no mínimo:</p><ul><li><strong>while</strong>: Como a condição é testada no início, se ela for falsa logo de cara, o bloco de comandos <strong>nunca</strong> será executado (zero ou mais repetições).</li><li><strong>do-while</strong>: Como a execução ocorre antes do teste, o bloco de comandos será processado <strong>pelo menos uma vez</strong>, independentemente da condição (uma ou mais repetições).</li></ul><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 265.69 533.00" data-sketch=true width=300 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 529)" class=graph id=graph0><title>Flowchart</title><polygon points="-4,4 -4,-529 261.69,-529 261.69,4 -4,4" fill=white stroke=transparent /><g class=node id=node1><title>Do</title><path d="M123.19,-525C123.19,-525 93.19,-525 93.19,-525 87.19,-525 81.19,-519 81.19,-513 81.19,-513 81.19,-501 81.19,-501 81.19,-495 87.19,-489 93.19,-489 93.19,-489 123.19,-489 123.19,-489 129.19,-489 135.19,-495 135.19,-501 135.19,-501 135.19,-513 135.19,-513 135.19,-519 129.19,-525 123.19,-525" fill=transparent stroke=transparent /><text font-family=Arial font-size=12.00 text-anchor=middle x=108.19 y=-503.9>do {</text></g><g class=node id=node2><title>Menu</title><path d="M188.19,-458C188.19,-458 28.19,-458 28.19,-458 22.19,-458 16.19,-452 16.19,-446 16.19,-446 16.19,-434 16.19,-434 16.19,-428 22.19,-422 28.19,-422 28.19,-422 188.19,-422 188.19,-422 194.19,-422 200.19,-428 200.19,-434 200.19,-434 200.19,-446 200.19,-446 200.19,-452 194.19,-458 188.19,-458" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=108.19 y=-436.9>printf ("Escolha uma opção:\n");</text></g><g class=node id=node3><title>Op1</title><path d="M140.69,-391C140.69,-391 27.69,-391 27.69,-391 21.69,-391 15.69,-385 15.69,-379 15.69,-379 15.69,-367 15.69,-367 15.69,-361 21.69,-355 27.69,-355 27.69,-355 140.69,-355 140.69,-355 146.69,-355 152.69,-361 152.69,-367 152.69,-367 152.69,-379 152.69,-379 152.69,-385 146.69,-391 140.69,-391" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=84.19 y=-369.9>printf ("(1) Opção 1\n");</text></g><g class=edge id=edge2><title>Menu->Op1</title><path d="M101.89,-421.92C99.48,-415.41 96.68,-407.81 94.02,-400.62" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="97.29,-399.36 90.54,-391.19 90.72,-401.78 97.29,-399.36" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node4><title>Op2</title><path d="M140.69,-324C140.69,-324 27.69,-324 27.69,-324 21.69,-324 15.69,-318 15.69,-312 15.69,-312 15.69,-300 15.69,-300 15.69,-294 21.69,-288 27.69,-288 27.69,-288 140.69,-288 140.69,-288 146.69,-288 152.69,-294 152.69,-300 152.69,-300 152.69,-312 152.69,-312 152.69,-318 146.69,-324 140.69,-324" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=84.19 y=-302.9>printf ("(2) Opção 2\n");</text></g><g class=edge id=edge3><title>Op1->Op2</title><path d="M84.19,-354.92C84.19,-348.7 84.19,-341.5 84.19,-334.6" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="87.69,-334.19 84.19,-324.19 80.69,-334.19 87.69,-334.19" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node5><title>Op3</title><path d="M140.69,-247C140.69,-247 27.69,-247 27.69,-247 21.69,-247 15.69,-241 15.69,-235 15.69,-235 15.69,-223 15.69,-223 15.69,-217 21.69,-211 27.69,-211 27.69,-211 140.69,-211 140.69,-211 146.69,-211 152.69,-217 152.69,-223 152.69,-223 152.69,-235 152.69,-235 152.69,-241 146.69,-247 140.69,-247" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=84.19 y=-225.9>printf ("(3) Opção 3\n");</text></g><g class=edge id=edge4><title>Op2->Op3</title><path d="M84.19,-287.98C84.19,-278.94 84.19,-267.6 84.19,-257.35" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="87.69,-257.21 84.19,-247.21 80.69,-257.21 87.69,-257.21" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node6><title>Scan</title><path d="M136.19,-180C136.19,-180 64.19,-180 64.19,-180 58.19,-180 52.19,-174 52.19,-168 52.19,-168 52.19,-156 52.19,-156 52.19,-150 58.19,-144 64.19,-144 64.19,-144 136.19,-144 136.19,-144 142.19,-144 148.19,-150 148.19,-156 148.19,-156 148.19,-168 148.19,-168 148.19,-174 142.19,-180 136.19,-180" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=100.19 y=-158.9>scanf("%d",&i);</text></g><g class=edge id=edge5><title>Op3->Scan</title><path d="M88.4,-210.92C89.96,-204.55 91.79,-197.16 93.52,-190.11" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="96.97,-190.74 95.96,-180.19 90.17,-189.06 96.97,-190.74" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node7><title>While</title><polygon points="114.19,-113 27.82,-95 114.19,-77 200.57,-95 114.19,-113" fill=#fff9c4 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=114.19 y=-91.9>((i &lt; 1) || (i > 3));</text></g><g class=edge id=edge6><title>Scan->While</title><path d="M103.87,-143.92C105.3,-137.27 106.98,-129.51 108.55,-122.18" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="112,-122.8 110.68,-112.29 105.16,-121.33 112,-122.8" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=edge id=edge7><title>While:e->Menu:e</title><path d="M202.19,-95C231.65,-95 208.19,-131.55 208.19,-161 208.19,-374 208.19,-374 208.19,-374 208.19,-399.12 224.51,-429.32 211.14,-437.73" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="210.16,-434.36 201.19,-440 211.72,-441.19 210.16,-434.36" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=217.69 y=-265>SIM</text></g><g class=node id=node8><title>Result</title><path d="M245.69,-36C245.69,-36 38.69,-36 38.69,-36 32.69,-36 26.69,-30 26.69,-24 26.69,-24 26.69,-12 26.69,-12 26.69,-6 32.69,0 38.69,0 38.69,0 245.69,0 245.69,0 251.69,0 257.69,-6 257.69,-12 257.69,-12 257.69,-24 257.69,-24 257.69,-30 251.69,-36 245.69,-36" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=142.19 y=-14.9>printf ("Você escolheu a Opção %d.\n",i);</text></g><g class=edge id=edge8><title>While:w->Result:w</title><path d="M26.19,-95C-4.29,-95 -7.62,-33.92 16.19,-20.56" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="17.37,-23.87 26.19,-18 15.64,-17.09 17.37,-23.87" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=28.19 y=-54>NÃO } while</text></g></g></svg></div></div><p>O exemplo abaixo ilustra o uso do <strong>do-while</strong> para criar um menu de opções. O programa exibe as alternativas e captura a sua entrada, repetindo o processo enquanto você digitar um valor inválido:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int i;
    do {
        printf ("Escolha uma opcao:\n");
        printf ("(1) Opção 1\n");
        printf ("(2) Opção 2\n");
        printf ("(3) Opção 3\n");
        scanf("%d", &i);
    } while ((i &lt; 1) || (i > 3));

    printf ("Voce escolheu a Opcao %d.\n", i);
    system("pause");
    return 0;
}
</code></pre><h3 id=regras-de-sintaxe-importantes><span class=heading-text>Regras de Sintaxe Importantes</span><span class=heading-arabic>6.6.2</span></h3><p>O comando <strong>do-while</strong> segue as mesmas recomendações de uso de chaves e definições lógicas dos comandos anteriores. No entanto, ele possui uma particularidade sintática exclusiva:</p><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Uso Obrigatório do Ponto e Vírgula</span></div><div class=callout-content><p>Diferente do <code>if</code>, <code>while</code> ou <code>for</code>, você <strong>deve</strong> colocar um ponto e vírgula (<code>;</code>) logo após o fechamento do parêntese da condição do <strong>do-while</strong>.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>do {
    printf("Valor %d\n", i);
    i++;
} while(i &lt; 10); // Este ponto e vírgula é obrigatório!
</code></pre></div></div><p>Essa exigência ocorre porque a condição é o último elemento da estrutura. O ponto e vírgula sinaliza ao compilador que a definição daquele laço específico foi finalizada. Assim como nas outras estruturas de repetição, lembre-se que é sua responsabilidade garantir que a variável de controle seja alterada dentro do bloco para evitar um <strong>laço infinito</strong>.</p><h2 id=aninhamento-de-repetições><span class=heading-text>Aninhamento de Repetições</span><span class=heading-arabic>6.7</span></h2><p>Uma <strong>repetição aninhada</strong> ocorre quando você utiliza um comando de repetição dentro do bloco de comandos de outro comando de repetição. Essa estrutura é conceitualmente idêntica ao aninhamento que você já praticou com o comando <strong>if</strong>, permitindo criar ciclos de execução dentro de outros ciclos.</p><p>A forma geral de uma repetição aninhada é:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>repetição (condição 1) {
    sequência de comandos;
    repetição (condição 2) {
        sequência de comandos;
        repetição...
    }
}
</code></pre><p>Neste contexto, o termo "repetição" pode representar qualquer um dos três comandos da linguagem <strong>C</strong>: <strong>while</strong>, <strong>for</strong> ou <strong>do-while</strong>.</p><p>Durante a execução, o programa avalia primeiramente a <strong>condição 1</strong>. Se o resultado for verdadeiro (diferente de zero), ele inicia o processamento do seu bloco interno, o que inclui a avaliação da <strong>condição 2</strong>. É fundamental notar que os comandos da segunda repetição só serão processados se a condição da primeira for satisfeita. Esse comportamento se replica em cascata para cada novo nível de aninhamento que você encontrar.</p><h3 id=aplicação-prática><span class=heading-text>Aplicação Prática</span><span class=heading-arabic>6.7.1</span></h3><p>O aninhamento de repetições é extremamente útil quando você precisa percorrer dois ou mais conjuntos de valores relacionados. Um exemplo clássico é a impressão de uma <strong>matriz identidade</strong> de tamanho $4 \times 4$. Para realizar essa tarefa, você precisa percorrer as quatro linhas da matriz e, para cada uma dessas linhas, percorrer as suas quatro colunas correspondentes. Um único comando de repetição não seria suficiente para gerenciar essas duas dimensões simultaneamente.</p><p>Abaixo, você pode comparar como essa lógica é implementada utilizando diferentes estruturas:</p><div style=gap:2%;display:flex><div style=width:49%><pre class="line-numbers language-c" data-lang=C><code class=language-c>// Versão com FOR
#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int i, j;
    for (i = 1; i &lt; 5; i++){
        for (j = 1; j &lt; 5; j++){
            if(i == j)
                printf("1 ");
            else
                printf("0 ");
        }
        printf("\n");
    }
    system("pause");
    return 0;
}
</code></pre></div><div style=width:49%><pre class="line-numbers language-c" data-lang=C><code class=language-c>// Versão com WHILE
#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int i = 1, j;
    while(i &lt; 5){
        j = 1;
        while(j &lt; 5){
            if(i == j)
                printf("1 ");
            else
                printf("0 ");
            j++;
        }
        printf("\n");
        i++;
    }
    system("pause");
    return 0;
}
</code></pre></div></div><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Flexibilidade no Aninhamento</span></div><div class=callout-content><p>A linguagem <strong>C</strong> permite que você misture tipos diferentes de comandos de repetição em um aninhamento. Você pode, por exemplo, utilizar um <strong>for</strong> como laço externo e um <strong>while</strong> como laço interno, ou qualquer outra combinação que melhor atenda à lógica do seu programa.</p></div></div><h2 id=comando-continue><span class=heading-text>Comando continue</span><span class=heading-arabic>6.8</span></h2><p>O comando <strong>continue</strong> é outro recurso de controle de fluxo utilizado exclusivamente dentro de estruturas de repetição como <strong>for</strong>, <strong>while</strong> e <strong>do-while</strong>. Enquanto o comando <code>break</code> interrompe e encerra o laço definitivamente, o <strong>continue</strong> interrompe apenas a iteração atual, saltando imediatamente para o próximo ciclo de execução da repetição.</p><p>Quando o programa encontra um <strong>continue</strong>, todos os comandos que estiverem abaixo dele, dentro do corpo do laço, são ignorados naquela volta específica. Em um laço <strong>for</strong>, o fluxo salta para a etapa de incremento; em laços <strong>while</strong> ou <strong>do-while</strong>, o programa retorna direto para o teste da condição.</p><p>O exemplo a seguir demonstra o uso do <strong>continue</strong> para imprimir apenas números ímpares entre <strong>a</strong> e <strong>b</strong>:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int a, b;
    printf("Digite o valor de a: ");
    scanf("%d", &a);
    printf("Digite o valor de b: ");
    scanf("%d", &b);

    while (a &lt;= b){
        a = a + 1;
        if(a % 2 == 0)
            continue; // Pula a impressão se o número for par
        printf("%d \n", a);
    }

    system("pause");
    return 0;
}
</code></pre><p>Abaixo, você pode visualizar a lógica de execução deste comando através do fluxograma:</p><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 350.97 275.00" data-sketch=true width=350 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 271)" class=graph id=graph0><title>Flowchart</title><polygon points="-4,4 -4,-271 346.97,-271 346.97,4 -4,4" fill=white stroke=transparent /><g class=node id=node1><title>WhileCond</title><polygon points="123.98,-267 41.07,-249 123.98,-231 206.88,-249 123.98,-267" fill=#fff9c4 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=123.98 y=-245.9>while (a &lt;= b) {</text></g><g class=node id=node2><title>Soma</title><path d="M144.48,-190C144.48,-190 103.48,-190 103.48,-190 97.48,-190 91.48,-184 91.48,-178 91.48,-178 91.48,-166 91.48,-166 91.48,-160 97.48,-154 103.48,-154 103.48,-154 144.48,-154 144.48,-154 150.48,-154 156.48,-160 156.48,-166 156.48,-166 156.48,-178 156.48,-178 156.48,-184 150.48,-190 144.48,-190" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=123.98 y=-168.9>a = a + 1;</text></g><g class=edge id=edge1><title>WhileCond->Soma</title><path d="M123.98,-230.98C123.98,-221.94 123.98,-210.6 123.98,-200.35" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="127.48,-200.21 123.98,-190.21 120.48,-200.21 127.48,-200.21" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=133.48 y=-208>SIM</text></g><g class=node id=node6><title>Continua</title><path d="M126.98,-36C126.98,-36 46.98,-36 46.98,-36 40.98,-36 34.98,-30 34.98,-24 34.98,-24 34.98,-12 34.98,-12 34.98,-6 40.98,0 46.98,0 46.98,0 126.98,0 126.98,0 132.98,0 138.98,-6 138.98,-12 138.98,-12 138.98,-24 138.98,-24 138.98,-30 132.98,-36 126.98,-36" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=86.98 y=-21.4>Continuação do</text><text font-family=Arial font-size=12.00 text-anchor=middle x=86.98 y=-8.4>programa</text></g><g class=edge id=edge2><title>WhileCond->Continua:w</title><path d="M109.25,-233.86C98.35,-222.76 83.75,-206.46 73.98,-190 35.78,-125.68 -37.24,-27.72 23.95,-18.67" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="24.23,-22.16 33.98,-18 23.76,-15.18 24.23,-22.16" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=65.98 y=-131>NÃO while</text></g><g class=node id=node3><title>IfBreak</title><polygon points="123.98,-113 63.1,-95 123.98,-77 184.86,-95 123.98,-113" fill=#fff9c4 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=123.98 y=-91.9>if (a == 5){</text></g><g class=edge id=edge3><title>Soma->IfBreak</title><path d="M123.98,-153.98C123.98,-144.94 123.98,-133.6 123.98,-123.35" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="127.48,-123.21 123.98,-113.21 120.48,-123.21 127.48,-123.21" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node4><title>BreakNode</title><path d="M297.98,-113C297.98,-113 267.98,-113 267.98,-113 261.98,-113 255.98,-107 255.98,-101 255.98,-101 255.98,-89 255.98,-89 255.98,-83 261.98,-77 267.98,-77 267.98,-77 297.98,-77 297.98,-77 303.98,-77 309.98,-83 309.98,-89 309.98,-89 309.98,-101 309.98,-101 309.98,-107 303.98,-113 297.98,-113" fill=#ffebee stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=282.98 y=-91.9>break;</text></g><g class=edge id=edge4><title>IfBreak->BreakNode</title><path d="M184.99,-95C205.49,-95 227.73,-95 245.82,-95" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="245.96,-98.5 255.96,-95 245.96,-91.5 245.96,-98.5" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=220.45 y=-101>SIM</text></g><g class=node id=node5><title>Print</title><path d="M326.48,-36C326.48,-36 241.48,-36 241.48,-36 235.48,-36 229.48,-30 229.48,-24 229.48,-24 229.48,-12 229.48,-12 229.48,-6 235.48,0 241.48,0 241.48,0 326.48,0 326.48,0 332.48,0 338.48,-6 338.48,-12 338.48,-12 338.48,-24 338.48,-24 338.48,-30 332.48,-36 326.48,-36" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=283.98 y=-14.9>printf("%d \n",a); }</text></g><g class=edge id=edge5><title>IfBreak->Print</title><path d="M146.22,-83.57C169.96,-72.45 208.21,-54.51 238.39,-40.37" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="239.91,-43.52 247.47,-36.11 236.93,-37.18 239.91,-43.52" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=228.48 y=-54>NÃO if</text></g><g class=edge id=edge6><title>BreakNode:s->Continua</title><path d="M282.98,-77C282.98,-54.97 206.13,-68.15 184.98,-62 166.16,-56.53 146.21,-48.27 129.26,-40.45" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="130.71,-37.27 120.18,-36.17 127.73,-43.6 130.71,-37.27" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=edge id=edge7><title>Print:e->WhileCond:e</title><path d="M339.98,-18C345.54,-18 356.97,-238.3 218.23,-248.63" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="217.84,-245.14 207.98,-249 218.1,-252.13 217.84,-245.14" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=334.98 y=-131></text></g></g></svg></div></div><div class="callout callout-important"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Estratégia de Uso</span></div><div class=callout-content><p>Assim como ocorre com o <code>break</code>, o comando <strong>continue</strong> deve ser utilizado dentro de uma estrutura condicional (<code>if</code> ou <code>else</code>). Caso contrário, o programa saltaria todas as instruções abaixo dele em todas as iterações, impedindo a execução lógica do corpo do laço. No caso de laços <strong>while</strong>, você deve ter cuidado redobrado: se o incremento da variável de controle estiver posicionado após o <strong>continue</strong>, você criará acidentalmente um <strong>laço infinito</strong>, pois a variável nunca será atualizada.</p></div></div><h2 id=comando-continue><span class=heading-text>Comando continue</span><span class=heading-arabic>6.9</span></h2><p>O comando <strong>continue</strong> guarda semelhanças com o comando <code>break</code>, pois ambos ignoram o restante das instruções dentro de um laço. Entretanto, a diferença funcional é determinante: enquanto o <code>break</code> encerra o comando de repetição definitivamente, o <strong>continue</strong> interrompe apenas a iteração atual e salta para a próxima repetição do laço, caso ela exista.</p><p>Devido a essa característica, o <strong>continue</strong> é de uso exclusivo dentro de laços de repetição, ao contrário do <code>break</code>, que também pode ser aplicado no comando <code>switch</code>. Quando executado, o programa ignora os comandos restantes daquela volta específica e retorna imediatamente para testar a condição do laço (no caso do <code>while</code> e <code>do-while</code>) ou para a cláusula de incremento (no caso do <code>for</code>).</p><p>O exemplo abaixo ilustra um programa que imprime valores entre <strong>a</strong> e <strong>b</strong>, mas pula especificamente a impressão do número 5:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int a, b;
    printf("Digite o valor de a: ");
    scanf("%d", &a);
    printf("Digite o valor de b: ");
    scanf("%d", &b);

    while (a &lt;= b){
        a = a + 1;
        if(a == 5)
            continue; // Interrompe a iteração atual e volta ao teste do while
        printf("%d \n", a);
    }

    system("pause");
    return 0;
}
</code></pre><h3 id=regras-de-uso-e-riscos-de-lógica><span class=heading-text>Regras de Uso e Riscos de Lógica</span><span class=heading-arabic>6.9.1</span></h3><p>Para utilizar o <strong>continue</strong> de forma didática e segura, você deve seguir estas orientações:</p><ul><li><strong>Uso com Condicionais</strong>: O comando deve estar sempre abrigado por um <code>if</code> ou <code>else</code> dentro da repetição. Isso garante que apenas iterações específicas, que atingirem um determinado resultado, sejam ignoradas.</li><li><strong>Risco de Laço Infinito</strong>: Se você posicionar o <strong>continue</strong> fora de uma estrutura condicional, o programa ignorará sistematicamente todas as execuções do laço. Além disso, em estruturas como o <code>while</code>, se o incremento da variável de controle estiver posicionado após o <strong>continue</strong>, você criará um <strong>laço infinito</strong>, pois o programa nunca chegará à linha que atualiza o valor da condição de parada.</li></ul><p>Abaixo, veja a representação visual do fluxo de execução do comando:</p><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 320.62 297.00" data-sketch=true width=350 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 293)" class=graph id=graph0><title>Flowchart</title><polygon points="-4,4 -4,-293 316.62,-293 316.62,4 -4,4" fill=white stroke=transparent /><g class=node id=node1><title>WhileCond</title><polygon points="101.5,-289 18.59,-271 101.5,-253 184.41,-271 101.5,-289" fill=#fff9c4 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=101.5 y=-267.9>while (a &lt;= b) {</text></g><g class=node id=node2><title>Soma</title><path d="M53,-201C53,-201 12,-201 12,-201 6,-201 0,-195 0,-189 0,-189 0,-177 0,-177 0,-171 6,-165 12,-165 12,-165 53,-165 53,-165 59,-165 65,-171 65,-177 65,-177 65,-189 65,-189 65,-195 59,-201 53,-201" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=32.5 y=-179.9>a = a + 1;</text></g><g class=edge id=edge1><title>WhileCond->Soma</title><path d="M79.42,-257.72C71.42,-252.45 62.81,-245.72 56.5,-238 50.01,-230.07 44.94,-220.11 41.15,-210.91" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="44.36,-209.48 37.55,-201.35 37.81,-211.94 44.36,-209.48" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=66 y=-224.5>SIM</text></g><g class=node id=node6><title>Continua</title><path d="M193.5,-201C193.5,-201 113.5,-201 113.5,-201 107.5,-201 101.5,-195 101.5,-189 101.5,-189 101.5,-177 101.5,-177 101.5,-171 107.5,-165 113.5,-165 113.5,-165 193.5,-165 193.5,-165 199.5,-165 205.5,-171 205.5,-177 205.5,-177 205.5,-189 205.5,-189 205.5,-195 199.5,-201 193.5,-201" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=153.5 y=-186.4>Continuação do</text><text font-family=Arial font-size=12.00 text-anchor=middle x=153.5 y=-173.4>programa</text></g><g class=edge id=edge2><title>WhileCond->Continua:w</title><path d="M95.01,-254.04C87.05,-232.65 76.25,-196.18 90.57,-185.82" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="91.84,-189.1 100.5,-183 89.92,-182.36 91.84,-189.1" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=101 y=-230>NÃO</text><text font-family=Arial font-size=10.00 text-anchor=middle x=101 y=-219>while</text></g><g class=node id=node3><title>IfCont</title><polygon points="71.5,-124 11.36,-106 71.5,-88 131.64,-106 71.5,-124" fill=#fff9c4 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=71.5 y=-102.9>if (a == 5):</text></g><g class=edge id=edge3><title>Soma->IfCont</title><path d="M41.35,-164.98C46.56,-154.95 53.24,-142.11 58.99,-131.05" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="62.23,-132.41 63.74,-121.92 56.02,-129.18 62.23,-132.41" fill=#333333 stroke=#333333 stroke-width=1.2 /></g><g class=node id=node4><title>ContNode</title><path d="M256,-124C256,-124 215,-124 215,-124 209,-124 203,-118 203,-112 203,-112 203,-100 203,-100 203,-94 209,-88 215,-88 215,-88 256,-88 256,-88 262,-88 268,-94 268,-100 268,-100 268,-112 268,-112 268,-118 262,-124 256,-124" fill=#e8f5e9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=235.5 y=-102.9>continue;</text></g><g class=edge id=edge4><title>IfCont->ContNode</title><path d="M131.64,-106C151.91,-106 174.1,-106 192.74,-106" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="192.99,-109.5 202.99,-106 192.99,-102.5 192.99,-109.5" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=167.28 y=-112>SIM</text></g><g class=node id=node5><title>Print</title><path d="M261,-36C261,-36 176,-36 176,-36 170,-36 164,-30 164,-24 164,-24 164,-12 164,-12 164,-6 170,0 176,0 176,0 261,0 261,0 267,0 273,-6 273,-12 273,-12 273,-24 273,-24 273,-30 267,-36 261,-36" fill=#f9f9f9 stroke=#333333 /><text font-family=Arial font-size=12.00 text-anchor=middle x=218.5 y=-14.9>printf("%d \n",a); }</text></g><g class=edge id=edge5><title>IfCont->Print</title><path d="M91.02,-93.58C113.71,-80.3 151.7,-58.08 180.32,-41.34" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="182.39,-44.18 189.25,-36.11 178.85,-38.14 182.39,-44.18" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=172.5 y=-65>NÃO</text><text font-family=Arial font-size=10.00 text-anchor=middle x=172.5 y=-54>if</text></g><g class=edge id=edge6><title>ContNode:e->WhileCond:e</title><path d="M269.5,-106C307.59,-106 238.42,-247.42 195.3,-268.41" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="194.27,-265.06 185.5,-271 196.06,-271.83 194.27,-265.06" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=269.5 y=-180.5></text></g><g class=edge id=edge7><title>Print:e->WhileCond:e</title><path d="M274.5,-18C337.57,-18 304.84,-95.53 296.5,-150 285.99,-218.61 261.07,-266.17 195.86,-270.65" fill=none stroke=#333333 stroke-width=1.2 /><polygon points="195.38,-267.17 185.5,-271 195.61,-274.16 195.38,-267.17" fill=#333333 stroke=#333333 stroke-width=1.2 /><text font-family=Arial font-size=10.00 text-anchor=middle x=299.5 y=-142></text></g></g></svg></div></div><h2 id=questões><span class=heading-text>Questões</span><span class=heading-arabic>6.10</span></h2><p><strong>1.</strong> Escreva um programa em C que utilize um laço <code>for</code> para imprimir todos os números inteiros de 1 a 20 na tela.</p><ul><li><strong>Entrada:</strong> Nenhuma.</li><li><strong>Saída Esperada:</strong> 1 2 3 ... 20 (um por linha ou separados por espaço).</li></ul><p><strong>2.</strong> Crie um programa que utilize o laço <code>while</code> para exibir uma contagem regressiva de 10 até 0. Ao final, imprima a mensagem "FIM!".</p><ul><li><strong>Entrada:</strong> Nenhuma.</li><li><strong>Saída Esperada:</strong> 10, 9, 8, ... 0, FIM!</li></ul><p><strong>3.</strong> Peça ao usuário para digitar um número inteiro. Utilize um laço (pode ser <code>for</code> ou <code>while</code>) para imprimir a tabuada desse número de 1 a 10.</p><ul><li><strong>Entrada:</strong> Um número (ex: 5).</li><li><strong>Saída Esperada:</strong><ul><li>5 x 1 = 5</li><li>5 x 2 = 10</li><li>...</li><li>5 x 10 = 50</li></ul></li></ul><p><strong>4.</strong> Escreva um programa que leia 5 números inteiros fornecidos pelo usuário. Utilize um laço para ler esses números e, a cada leitura, some-o a uma variável acumuladora. Ao final, imprima a soma total e a média dos valores.</p><ul><li><strong>Entrada:</strong> 5 números inteiros (ex: 10, 20, 10, 20, 40).</li><li><strong>Saída Esperada:</strong> Soma: 100, Média: 20.0.</li></ul><p><strong>5.</strong> Utilize a estrutura <code>do-while</code> para criar um programa que peça ao usuário para digitar uma nota entre 0.0 e 10.0. Se o usuário digitar um valor inválido (fora desse intervalo), o programa deve exibir "Nota inválida" e pedir o valor novamente. O programa só deve parar quando uma nota válida for inserida.</p><ul><li><strong>Entrada:</strong> Repetidas tentativas de números (ex: -1, 15, 7).</li><li><strong>Saída:</strong> Apenas quando digitar 7: "Nota valida: 7.0".</li></ul><p><strong>6.</strong> Crie um programa que receba dois números inteiros, <code>A</code> e <code>B</code> (considere que A &lt; B). Utilize um laço <code>for</code> para percorrer o intervalo de A até B e imprimir apenas os números pares.</p><ul><li><strong>Dica:</strong> Use o operador <code>%</code> (resto) para verificar se é par.</li><li><strong>Entrada:</strong> Dois inteiros (ex: 2 e 10).</li><li><strong>Saída Esperada:</strong> 2 4 6 8 10.</li></ul><p><strong>7.</strong> Escreva um programa que calcule o fatorial de um número inteiro não negativo fornecido pelo usuário. Lembre-se que o fatorial de N ($N!$) é a multiplicação:</p><p>$$N \times (N-1) \times (N-2) \times ... \times 1$$</p><p>Exemplo: $5! = 5 \times 4 \times 3 \times 2 \times 1 = 120$).</p><ul><li><strong>Entrada:</strong> Um número inteiro positivo (ex: 5).</li><li><strong>Saída Esperada:</strong> Fatorial: 120.</li></ul><p><strong>8.</strong> Utilize <strong>laços aninhados</strong> (um laço dentro de outro) para desenhar um quadrado de asteriscos na tela. O usuário deve informar o tamanho do lado do quadrado.</p><ul><li><strong>Entrada:</strong> Um inteiro <code>N</code> (ex: 4).</li><li><strong>Saída Esperada:</strong></li></ul><pre class="line-numbers language-txt" data-lang=TXT><code class=language-txt>****
****
****
****
</code></pre><p><strong>9.</strong> Escreva um programa que leia um número inteiro <code>N</code> e imprima as <code>N</code> primeiras linhas do Triângulo de Floyd. O triângulo é formado por números sequenciais dispostos em linhas crescentes.</p><ul><li><strong>Entrada:</strong> Um inteiro (ex: 4).</li><li><strong>Saída Esperada:</strong></li></ul><pre class="line-numbers language-txt" data-lang=TXT><code class=language-txt>1
2 3
4 5 6
7 8 9 10
</code></pre><p><strong>10.</strong> Crie um programa que peça um número inteiro positivo maior que 1 ao usuário e determine se ele é um número <strong>PRIMO</strong> (divisível apenas por 1 e por ele mesmo). Para isso, você precisará usar um laço para testar a divisibilidade do número por todos os antecessores até chegar na metade do valor dele.</p><ul><li><strong>Entrada:</strong> Um número inteiro (ex: 7).</li><li><strong>Saída Esperada:</strong> "Eh primo".</li><li><strong>Entrada Alternativa:</strong> 9.</li><li><strong>Saída Esperada:</strong> "Nao eh primo".</li></ul><p><strong>11.</strong> A sequência de Fibonacci começa com 0 e 1, e os próximos números são sempre a soma dos dois anteriores (0, 1, 1, 2, 3, 5, 8, 13...). Escreva um programa que leia um inteiro <code>N</code> e imprima os <code>N</code> primeiros termos dessa sequência.</p><ul><li><strong>Entrada:</strong> Um inteiro N (ex: 6).</li><li><strong>Saída Esperada:</strong> 0 1 1 2 3 5.</li></ul><h2 id=próximos-passos><span class=heading-text>Próximos passos</span><span class=heading-arabic>6.11</span></h2><p>No próximo capítulo, <a href=7-arrays.html>Arrays (Vetores e Matrizes)</a>, aprenderemos a armazenar múltiplos valores de um mesmo tipo em uma única variável composta. Veremos como declarar vetores (<em>arrays</em>) além de como acessar seus elementos através de índices.</p></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/aulas-faesa/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Tópicos de Programação II (TEP II)`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>