<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Tópicos de Programação II (TEP II)</title><link media="(prefers-color-scheme: light)" href=/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Tópicos de Programação II (TEP II)</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#vetores-e-matrizes---arrays>7.1. Vetores e Matrizes - Arrays</a></li><li class="toc-item level-2"><a href=#por-que-utilizar-arrays>7.2. Por que utilizar arrays?</a></li><li class="toc-item level-3"><a href=#o-problema-da-escalabilidade>7.2.1. O problema da escalabilidade</a></li><li class="toc-item level-3"><a href=#a-solução-o-array>7.2.2. A solução: O Array</a></li><li class="toc-item level-2"><a href=#array-com-uma-dimensão---vetor>7.3. Array com uma dimensão - Vetor</a></li><li class="toc-item level-3"><a href=#declarando-um-vetor>7.3.1. Declarando um vetor</a></li><li class="toc-item level-3"><a href=#acessando-um-elemento-do-vetor>7.3.2. Acessando um elemento do vetor</a></li><li class="toc-item level-4"><a href=#utilizando-laços-de-repetição-com-arrays>7.3.2.1. Utilizando laços de repetição com arrays</a></li><li class="toc-item level-4"><a href=#características-das-posições-do-array>7.3.2.2. Características das posições do array</a></li><li class="toc-item level-3"><a href=#cuidados-com-a-atribuição-de-arrays>7.3.3. Cuidados com a atribuição de arrays</a></li><li class="toc-item level-2"><a href=#array-com-duas-dimensões---matriz>7.4. Array com duas dimensões - Matriz</a></li><li class="toc-item level-3"><a href=#declarando-uma-matriz>7.4.1. Declarando uma matriz</a></li><li class="toc-item level-3"><a href=#acessando-um-elemento-da-matriz>7.4.2. Acessando um elemento da matriz</a></li><li class="toc-item level-4"><a href=#percorrendo-os-elementos-de-uma-matriz>7.4.2.1. Percorrendo os elementos de uma matriz</a></li><li class="toc-item level-4"><a href=#propriedades-das-posições-da-matriz>7.4.2.2. Propriedades das posições da matriz</a></li><li class="toc-item level-2"><a href=#array-com-mais-de-duas-dimensões>7.5. Array com mais de duas dimensões</a></li><li class="toc-item level-3"><a href=#acesso-e-manipulação>7.5.1. Acesso e Manipulação</a></li><li class="toc-item level-3"><a href=#organização-na-memória>7.5.2. Organização na Memória</a></li><li class="toc-item level-2"><a href=#inicialização-de-arrays>7.6. Inicialização de arrays</a></li><li class="toc-item level-3"><a href=#utilizando-o-operador-de-chaves>7.6.1. Utilizando o operador de chaves</a></li><li class="toc-item level-3"><a href=#inicializando-matrizes>7.6.2. Inicializando Matrizes</a></li><li class="toc-item level-3"><a href=#inicialização-de-caracteres-strings>7.6.3. Inicialização de caracteres (Strings)</a></li><li class="toc-item level-3"><a href=#inicialização-sem-tamanho>7.6.4. Inicialização sem tamanho</a></li><li class="toc-item level-2"><a href=#exemplos-de-uso-de-arrays>7.7. Exemplos de uso de arrays</a></li><li class="toc-item level-3"><a href=#somando-os-elementos-de-um-vetor>7.7.1. Somando os elementos de um vetor</a></li><li class="toc-item level-3"><a href=#encontrando-o-maior-valor-de-um-vetor>7.7.2. Encontrando o maior valor de um vetor</a></li><li class="toc-item level-3"><a href=#calculando-a-média-dos-elementos-de-um-vetor>7.7.3. Calculando a média dos elementos de um vetor</a></li><li class="toc-item level-3"><a href=#somando-os-elementos-de-uma-matriz>7.7.4. Somando os elementos de uma matriz</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=6-repetitions.html><i class=nav-icon data-lucide=chevron-left></i> Repetições</a><a class="sidebar-nav-link next" href=8-strings.html>Arrays de Caracteres (Strings) <i class=nav-icon data-lucide=chevron-right></i></a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>7</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>Arrays (Vetores e Matrizes)</span> <span class="title-ornament right">❧</span></h1><p class=article-date>10/02/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Tópicos de Programação II</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-II>II - Linguagem C</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>Arrays (Vetores e Matrizes)</span></nav></header><div class=article-body><h2 id=vetores-e-matrizes---arrays><span class=heading-text>Vetores e Matrizes - Arrays</span><span class=heading-arabic>7.1</span></h2><p>Este capítulo tem como objetivo fundamental apresentar o conceito de <strong>array</strong> na linguagem <strong>C</strong>, explorando sua aplicação prática na declaração de vetores e matrizes. Ao final deste estudo, você será capaz de compreender a necessidade técnica de utilizar coleções de dados, dominar a criação e o acesso a elementos tanto em <strong>vetores</strong> (unidimensionais) quanto em <strong>matrizes</strong> (bidimensionais), além de explorar a estruturação de arrays com múltiplas dimensões e as técnicas para a inicialização correta dessas estruturas.</p><div class="callout callout-info"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=10 /><path d="M12 16v-4"/><path d="M12 8h.01"/></svg></span><span class=callout-title-inner>Objetivos de Aprendizado</span></div><div class=callout-content><ul><li>Compreender a motivação para o uso de <strong>arrays</strong> no desenvolvimento de software.</li><li>Aprender a declarar e estruturar um <strong>vetor</strong>.</li><li>Dominar as técnicas de acesso e manipulação dos elementos de um vetor.</li><li>Desenvolver habilidades para criar e organizar <strong>matrizes</strong>.</li><li>Compreender como acessar e modificar dados em posições específicas de uma matriz.</li><li>Explorar a criação de arrays que possuam mais de duas dimensões.</li><li>Conhecer os métodos para <strong>inicializar</strong> arrays no momento da declaração.</li></ul></div></div><h2 id=por-que-utilizar-arrays><span class=heading-text>Por que utilizar arrays?</span><span class=heading-arabic>7.2</span></h2><p>As variáveis que você utilizou até este momento possuem uma limitação fundamental: são capazes de armazenar apenas um único valor por vez. Sempre que você atribui um novo dado a uma variável, o conteúdo anterior é permanentemente substituído e perdido pelo sistema.</p><p>Observe esse comportamento no código a seguir:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    float x = 10;
    printf("x = %f\n", x);

    x = 20; // O valor 10 é descartado e substituído por 20
    printf("x = %f\n", x);

    system("pause");
    return 0;
}
</code></pre><p>Essa dinâmica ocorre porque cada variável está vinculada a uma posição exclusiva na memória, comportando apenas um dado do tipo especificado. Consequentemente, para processar diversos valores de forma simultânea, você seria obrigado a declarar múltiplas variáveis manuais.</p><h3 id=o-problema-da-escalabilidade><span class=heading-text>O problema da escalabilidade</span><span class=heading-arabic>7.2.1</span></h3><p>Imagine que você precise desenvolver um programa para ler as notas de cinco estudantes, calcular a média e, em seguida, imprimir apenas as notas que ficaram acima dessa média calculada. Uma solução utilizando variáveis simples seria estruturada da seguinte forma:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    float n1, n2, n3, n4, n5;
    printf("Digite a nota de 5 estudantes: ");
    
    // Leitura individual para cada uma das 5 variáveis
    scanf("%f", &n1); 
    scanf("%f", &n2); 
    scanf("%f", &n3); 
    scanf("%f", &n4); 
    scanf("%f", &n5);

    float media = (n1 + n2 + n3 + n4 + n5) / 5.0;

    // Testes individuais exaustivos e repetitivos
    if(n1 > media) printf("nota: %f\n", n1);
    if(n2 > media) printf("nota: %f\n", n2);
    if(n3 > media) printf("nota: %f\n", n3);
    if(n4 > media) printf("nota: %f\n", n4);
    if(n5 > media) printf("nota: %f\n", n5);

    system("pause");
    return 0;
}
</code></pre><p>Embora essa abordagem funcione para um grupo pequeno, ela se torna tecnicamente inviável se a turma possuir 100 estudantes. Expandir esse programa exigiria de você:</p><ul><li>A criação de <strong>100 nomes de variáveis</strong> diferentes para gerenciar.</li><li>A escrita de <strong>100 comandos <code>scanf()</code></strong> para realizar a leitura.</li><li>Uma expressão de soma contendo <strong>100 termos</strong> individuais.</li><li>A repetição de <strong>100 comandos <code>if</code></strong> e <strong>100 comandos <code>printf()</code></strong> para a verificação final.</li></ul><p>Essa solução é extremamente rígida e propensa a falhas. Qualquer alteração no número de alunos exigiria que você reescrevesse quase a totalidade do código.</p><h3 id=a-solução-o-array><span class=heading-text>A solução: O Array</span><span class=heading-arabic>7.2.2</span></h3><p>Como as notas dos alunos guardam uma relação lógica entre si, você pode declará-las utilizando um <strong>único nome</strong> para representar todo o conjunto de dados. Um <strong>array</strong> (também conhecido como "vetor") é a forma mais elementar de dados estruturados na linguagem <strong>C</strong>.</p><p>Trata-se de um conjunto de variáveis de um <strong>mesmo tipo</strong> que compartilham o mesmo identificador e estão organizadas de forma contígua na memória. A grande vantagem pedagógica e técnica é que cada valor individual dentro desse conjunto pode ser acessado através de um <strong>índice</strong> numérico.</p><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Vantagem do Array</span></div><div class=callout-content><p>Ao utilizar arrays, você substitui a gestão manual de dezenas de variáveis por uma estrutura única, permitindo o uso de laços de repetição para processar todos os dados de maneira automática, fluida e eficiente.</p></div></div><h2 id=array-com-uma-dimensão---vetor><span class=heading-text>Array com uma dimensão - Vetor</span><span class=heading-arabic>7.3</span></h2><p>A ideia de um <strong>array</strong> ou <strong>vetor</strong> é bastante simples: criar um conjunto de variáveis do mesmo tipo utilizando apenas um nome. Relembrando o exemplo anterior, em que as variáveis que guardam as notas dos 100 alunos são todas do mesmo tipo, essa solução permitiria usar apenas um nome (como <code>notas</code>) para representar todos os estudantes, em vez de criar um nome individual para cada variável.</p><h3 id=declarando-um-vetor><span class=heading-text>Declarando um vetor</span><span class=heading-arabic>7.3.1</span></h3><p>Em linguagem <strong>C</strong>, a declaração de um array segue esta forma geral:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>tipo_dado nome_array[tamanho];
</code></pre><p>Esse comando define um array de nome <code>nome_array</code> contendo <code>tamanho</code> elementos adjacentes na memória. Cada elemento do array é do tipo <code>tipo_dado</code>. No caso das notas dos 100 alunos, declararíamos um array de ponto flutuante da seguinte forma:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>float notas[100];
</code></pre><p>É fundamental que o <strong>tamanho</strong> de um array seja sempre um valor ou uma expressão inteira e constante. Veja os exemplos abaixo:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>
#define N 100

int main(){
    int n = 5;
    float F[N+1];    // Correto: expressão inteira e constante
    char texto[30];  // Correto: valor inteiro
    
    // int Vetor[n]; // Errado: n é uma variável
    // int V[4.5];   // Errado: 4.5 não é um valor inteiro

    system("pause");
    return 0;
}
</code></pre><h3 id=acessando-um-elemento-do-vetor><span class=heading-text>Acessando um elemento do vetor</span><span class=heading-arabic>7.3.2</span></h3><p>Como a variável que armazena a nota de um aluno compartilha o mesmo nome com as demais, o acesso ao valor individual é realizado por meio de um <strong>índice</strong>. Para indicar qual posição do array você deseja acessar, utiliza-se o operador de colchetes <code>[]</code>: <code>notas[indice]</code>.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>float notas[100];
notas[0] = 81; // Primeira posição
notas[1] = 55; // Segunda posição
// ...
notas[99] = 72; // Centésima posição
</code></pre><p>A imagem abaixo ilustra como esses dados são organizados:</p><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 243.00 112.00" data-sketch=true width=350 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 108)" class=graph id=graph0><title>G</title><polygon points="-4,4 -4,-108 239,-108 239,4 -4,4" fill=white stroke=transparent /><g class=node id=node1><title>array</title><text font-family=Times,serif font-size=14.00 text-anchor=start x=22.5 y=-80.8>0</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=60.5 y=-80.8>1</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=95 y=-80.8>...</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=199 y=-80.8>99</text><polygon points="8.5,-34 8.5,-69 46.5,-69 46.5,-34 8.5,-34" fill=#9fc5e8 stroke=transparent /><polygon points="8.5,-34 8.5,-69 46.5,-69 46.5,-34 8.5,-34" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 font-weight=bold text-anchor=start x=17.5 y=-48.8>81</text><polygon points="46.5,-34 46.5,-69 84.5,-69 84.5,-34 46.5,-34" fill=#9fc5e8 stroke=transparent /><polygon points="46.5,-34 46.5,-69 84.5,-69 84.5,-34 46.5,-34" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 font-weight=bold text-anchor=start x=55.5 y=-48.8>55</text><polygon points="84.5,-34 84.5,-69 119.5,-69 119.5,-34 84.5,-34" fill=#9fc5e8 stroke=transparent /><polygon points="84.5,-34 84.5,-69 119.5,-69 119.5,-34 84.5,-34" fill=none stroke=black /><polygon points="119.5,-34 119.5,-69 154.5,-69 154.5,-34 119.5,-34" fill=#9fc5e8 stroke=transparent /><polygon points="119.5,-34 119.5,-69 154.5,-69 154.5,-34 119.5,-34" fill=none stroke=black /><polygon points="154.5,-34 154.5,-69 189.5,-69 189.5,-34 154.5,-34" fill=#9fc5e8 stroke=transparent /><polygon points="154.5,-34 154.5,-69 189.5,-69 189.5,-34 154.5,-34" fill=none stroke=black /><polygon points="189.5,-34 189.5,-69 227.5,-69 227.5,-34 189.5,-34" fill=#9fc5e8 stroke=transparent /><polygon points="189.5,-34 189.5,-69 227.5,-69 227.5,-34 189.5,-34" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 font-weight=bold text-anchor=start x=198.5 y=-48.8>72</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=115.5 y=-22.8> </text><text font-family=Times,serif font-size=14.00 text-anchor=start x=14 y=-8.8>                   </text><text font-family=Times,serif font-size=14.00 font-weight=bold text-anchor=start x=105 y=-8.8>notas</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=149 y=-8.8>               </text></g></g></svg></div></div><p>Na linguagem <strong>C</strong>, a numeração do índice começa sempre do <strong>ZERO</strong> e termina em <strong>N-1</strong>, onde <strong>N</strong> é o tamanho definido na declaração. Isso ocorre porque o nome do array aponta para o início do bloco na memória, e o índice indica quantas posições se deve "pular" para alcançar o dado desejado.</p><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 323.00 337.00" data-sketch=true width=350 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 333)" class=graph id=graph0><title>G</title><polygon points="-4,4 -4,-333 319,-333 319,4 -4,4" fill=white stroke=transparent /><g class=node id=node1><title>memoria</title><polygon points="8.5,-295.5 8.5,-324.5 217.5,-324.5 217.5,-295.5 8.5,-295.5" fill=#cccccc stroke=transparent /><polygon points="8.5,-295.5 8.5,-324.5 217.5,-324.5 217.5,-295.5 8.5,-295.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 font-weight=bold text-anchor=start x=77.5 y=-307.3>Memória</text><polygon points="8.5,-266.5 8.5,-295.5 50.5,-295.5 50.5,-266.5 8.5,-266.5" fill=#eeeeee stroke=transparent /><polygon points="8.5,-266.5 8.5,-295.5 50.5,-295.5 50.5,-266.5 8.5,-266.5" fill=none stroke=black /><text fill=red font-family=Times,serif font-size=14.00 font-weight=bold text-anchor=start x=23 y=-278.3>#</text><polygon points="50.5,-266.5 50.5,-295.5 130.5,-295.5 130.5,-266.5 50.5,-266.5" fill=#eeeeee stroke=transparent /><polygon points="50.5,-266.5 50.5,-295.5 130.5,-295.5 130.5,-266.5 50.5,-266.5" fill=none stroke=black /><text fill=red font-family=Times,serif font-size=14.00 font-weight=bold text-anchor=start x=78 y=-278.3>var</text><polygon points="130.5,-266.5 130.5,-295.5 217.5,-295.5 217.5,-266.5 130.5,-266.5" fill=#eeeeee stroke=transparent /><polygon points="130.5,-266.5 130.5,-295.5 217.5,-295.5 217.5,-266.5 130.5,-266.5" fill=none stroke=black /><text fill=red font-family=Times,serif font-size=14.00 font-weight=bold text-anchor=start x=137.5 y=-278.3>conteúdo</text><polygon points="8.5,-237.5 8.5,-266.5 50.5,-266.5 50.5,-237.5 8.5,-237.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=15.5 y=-248.3>123</text><polygon points="50.5,-237.5 50.5,-266.5 130.5,-266.5 130.5,-237.5 50.5,-237.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 font-weight=bold text-anchor=start x=68.5 y=-249.3>notas</text><polygon points="130.5,-237.5 130.5,-266.5 217.5,-266.5 217.5,-237.5 130.5,-237.5" fill=#eeeeee stroke=transparent /><polygon points="130.5,-237.5 130.5,-266.5 217.5,-266.5 217.5,-237.5 130.5,-237.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=164.5 y=-248.3>81</text><polygon points="8.5,-208.5 8.5,-237.5 50.5,-237.5 50.5,-208.5 8.5,-208.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=15.5 y=-219.3>124</text><polygon points="50.5,-208.5 50.5,-237.5 130.5,-237.5 130.5,-208.5 50.5,-208.5" fill=none stroke=black /><polygon points="130.5,-208.5 130.5,-237.5 217.5,-237.5 217.5,-208.5 130.5,-208.5" fill=#eeeeee stroke=transparent /><polygon points="130.5,-208.5 130.5,-237.5 217.5,-237.5 217.5,-208.5 130.5,-208.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=164.5 y=-219.3>55</text><polygon points="8.5,-179.5 8.5,-208.5 50.5,-208.5 50.5,-179.5 8.5,-179.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=15.5 y=-190.3>125</text><polygon points="50.5,-179.5 50.5,-208.5 130.5,-208.5 130.5,-179.5 50.5,-179.5" fill=none stroke=black /><polygon points="130.5,-179.5 130.5,-208.5 217.5,-208.5 217.5,-179.5 130.5,-179.5" fill=#eeeeee stroke=transparent /><polygon points="130.5,-179.5 130.5,-208.5 217.5,-208.5 217.5,-179.5 130.5,-179.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=164.5 y=-190.3>63</text><polygon points="8.5,-150.5 8.5,-179.5 50.5,-179.5 50.5,-150.5 8.5,-150.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=15.5 y=-161.3>126</text><polygon points="50.5,-150.5 50.5,-179.5 130.5,-179.5 130.5,-150.5 50.5,-150.5" fill=none stroke=black /><polygon points="130.5,-150.5 130.5,-179.5 217.5,-179.5 217.5,-150.5 130.5,-150.5" fill=#eeeeee stroke=transparent /><polygon points="130.5,-150.5 130.5,-179.5 217.5,-179.5 217.5,-150.5 130.5,-150.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=164.5 y=-161.3>67</text><polygon points="8.5,-121.5 8.5,-150.5 50.5,-150.5 50.5,-121.5 8.5,-121.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=15.5 y=-132.3>127</text><polygon points="50.5,-121.5 50.5,-150.5 130.5,-150.5 130.5,-121.5 50.5,-121.5" fill=none stroke=black /><polygon points="130.5,-121.5 130.5,-150.5 217.5,-150.5 217.5,-121.5 130.5,-121.5" fill=#eeeeee stroke=transparent /><polygon points="130.5,-121.5 130.5,-150.5 217.5,-150.5 217.5,-121.5 130.5,-121.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=164.5 y=-132.3>90</text><polygon points="8.5,-92.5 8.5,-121.5 50.5,-121.5 50.5,-92.5 8.5,-92.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=15.5 y=-103.3>128</text><polygon points="50.5,-92.5 50.5,-121.5 130.5,-121.5 130.5,-92.5 50.5,-92.5" fill=none stroke=black /><polygon points="130.5,-92.5 130.5,-121.5 217.5,-121.5 217.5,-92.5 130.5,-92.5" fill=#eeeeee stroke=transparent /><polygon points="130.5,-92.5 130.5,-121.5 217.5,-121.5 217.5,-92.5 130.5,-92.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=167 y=-103.3>...</text><polygon points="8.5,-63.5 8.5,-92.5 50.5,-92.5 50.5,-63.5 8.5,-63.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=15.5 y=-74.3>129</text><polygon points="50.5,-63.5 50.5,-92.5 130.5,-92.5 130.5,-63.5 50.5,-63.5" fill=none stroke=black /><polygon points="130.5,-63.5 130.5,-92.5 217.5,-92.5 217.5,-63.5 130.5,-63.5" fill=#eeeeee stroke=transparent /><polygon points="130.5,-63.5 130.5,-92.5 217.5,-92.5 217.5,-63.5 130.5,-63.5" fill=none stroke=black /><polygon points="8.5,-3.5 8.5,-63.5 217.5,-63.5 217.5,-3.5 8.5,-3.5" fill=#cccccc stroke=transparent /><polygon points="8.5,-3.5 8.5,-63.5 217.5,-63.5 217.5,-3.5 8.5,-3.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=28.5 y=-30.1>                   </text><text font-family=Times,serif font-size=18.00 text-anchor=start x=119.5 y=-30.1>⋮</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=124.5 y=-30.1>               </text></g><g class=node id=node2><title>rotulos</title><text font-family=Times,serif font-size=14.00 text-anchor=start x=241.5 y=-247.3>notas[0]</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=241.5 y=-218.3>notas[1]</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=241.5 y=-189.3>notas[2]</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=241.5 y=-160.3>notas[3]</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=241.5 y=-131.3>notas[4]</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=241.5 y=-102.3> </text><text font-family=Times,serif font-size=14.00 text-anchor=start x=241.5 y=-73.3> </text></g></g></svg></div></div><h4 id=utilizando-laços-de-repetição-com-arrays><span class=heading-text>Utilizando laços de repetição com arrays</span><span class=heading-arabic>7.3.2.1</span></h4><p>A grande vantagem pedagógica e técnica do uso de índices é a possibilidade de utilizar comandos de repetição, como o laço <strong>for</strong>, para manipular o array inteiro de forma automática.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int notas[100];
    int i;
    for (i = 0; i &lt; 100; i++){
        printf("Digite a nota do aluno %d: ", i);
        scanf("%d", &amp;notas[i]);
    }
    system("pause");
    return 0;
}
</code></pre><p>Nesse exemplo, o laço <strong>for</strong> executa o comando <code>scanf()</code> para cada uma das 100 posições. Isso torna o código muito mais enxuto, facilita a manutenção e minimiza erros, pois você não precisa reescrever o mesmo comando 100 vezes.</p><h4 id=características-das-posições-do-array><span class=heading-text>Características das posições do array</span><span class=heading-arabic>7.3.2.2</span></h4><p>Cada posição do array funciona exatamente como uma variável individual. Isso significa que ela pode ser usada em:</p><ul><li><strong>Leitura de dados</strong>: <code>scanf("%d", &amp;notas[5]);</code></li><li><strong>Atribuição</strong>: <code>notas[0] = 10;</code></li><li><strong>Expressões</strong>: <code>notas[1] = notas[5] + notas[0];</code></li></ul><p>Além disso, o tempo necessário para acessar qualquer posição do array é exatamente o mesmo, independentemente de ser o primeiro ou o último elemento.</p><div class="callout callout-danger"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1=12 x2=12 y1=9 y2=13 /><line x1=12 x2=12 y1=17 y2=17.01 /></svg></span><span class=callout-title-inner>Atenção aos limites do Array</span></div><div class=callout-content><p>É sua responsabilidade como programador garantir que os limites do array (de 0 a N-1) sejam respeitados. Tentar acessar índices como -1 ou 100 pode resultar em erros graves, pois o programa tentará acessar espaços de memória que podem pertencer a outras variáveis.</p></div></div><h3 id=cuidados-com-a-atribuição-de-arrays><span class=heading-text>Cuidados com a atribuição de arrays</span><span class=heading-arabic>7.3.3</span></h3><p>Uma restrição importante da linguagem <strong>C</strong> é que <strong>não se pode atribuir um array inteiro a outro</strong> diretamente utilizando o operador <code>=</code>. Para copiar os dados, você deve realizar a atribuição elemento por elemento.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int v[5] = {1, 2, 3, 4, 5};
    int v1[5];
    
    // v1 = v; // ERRADO! O compilador não aceita essa operação
    
    int i;
    for(i = 0; i &lt; 5; i++)
        v1[i] = v[i]; // CORRETO: cópia individual

    system("pause");
    return 0;
}
</code></pre><h2 id=array-com-duas-dimensões---matriz><span class=heading-text>Array com duas dimensões - Matriz</span><span class=heading-arabic>7.4</span></h2><p>Os arrays explorados anteriormente possuíam apenas uma dimensão e eram tratados como listas lineares de variáveis. No entanto, existem situações em que a organização dos dados exige uma estrutura mais robusta, como no caso de tabelas compostas por linhas e colunas. Para atender a essa necessidade, utilizamos arrays com duas dimensões, conhecidos tecnicamente como <strong>matrizes</strong>.</p><h3 id=declarando-uma-matriz><span class=heading-text>Declarando uma matriz</span><span class=heading-arabic>7.4.1</span></h3><p>Na linguagem <strong>C</strong>, a declaração de uma matriz segue uma sintaxe que expande o conceito do vetor, adicionando um segundo par de colchetes para representar a nova dimensão:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>tipo_dado nome_array[nro_linhas][nro_colunas];
</code></pre><p>Esse comando reserva um espaço na memória para um conjunto de elementos adjacentes do mesmo tipo. O total de elementos criados é o resultado da multiplicação entre o número de linhas e o número de colunas. Por exemplo, para criar uma matriz de inteiros com 100 linhas e 50 colunas, utiliza-se a seguinte instrução:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>int mat[100][50];
</code></pre><h3 id=acessando-um-elemento-da-matriz><span class=heading-text>Acessando um elemento da matriz</span><span class=heading-arabic>7.4.2</span></h3><p>Diferente do vetor, onde bastava um único índice, o acesso a uma posição específica na matriz exige que você informe as coordenadas de <strong>linha</strong> e <strong>coluna</strong>. Cada índice deve ser colocado em seu próprio par de colchetes:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>int mat[100][50];
mat[0][1] = 99; // Acessa a primeira linha (0) e a segunda coluna (1)
</code></pre><p>A imagem abaixo ilustra a localização desse valor na estrutura de dados:</p><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 349.00 193.00" data-sketch=true width=350 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 189)" class=graph id=graph0><title>G</title><polygon points="-4,4 -4,-189 345,-189 345,4 -4,4" fill=white stroke=transparent /><g class=node id=node1><title>matriz</title><text font-family=Times,serif font-size=14.00 text-anchor=start x=139.5 y=-159.3>0</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=175 y=-159.3>1</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=210.5 y=-159.3>...</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=304.5 y=-159.3>49</text><text font-family=Times,serif font-size=14.00 text-anchor=start x=105 y=-123.3>0</text><polygon points="129.5,-108.5 129.5,-145.5 159.5,-145.5 159.5,-108.5 129.5,-108.5" fill=#9fc5e8 stroke=transparent /><polygon points="129.5,-108.5 129.5,-145.5 159.5,-145.5 159.5,-108.5 129.5,-108.5" fill=none stroke=black /><polygon points="159.5,-108.5 159.5,-145.5 200.5,-145.5 200.5,-108.5 159.5,-108.5" fill=#9fc5e8 stroke=transparent /><polygon points="159.5,-108.5 159.5,-145.5 200.5,-145.5 200.5,-108.5 159.5,-108.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=170.5 y=-123.3>99</text><polygon points="200.5,-108.5 200.5,-145.5 234.5,-145.5 234.5,-108.5 200.5,-108.5" fill=#9fc5e8 stroke=transparent /><polygon points="200.5,-108.5 200.5,-145.5 234.5,-145.5 234.5,-108.5 200.5,-108.5" fill=none stroke=black /><polygon points="234.5,-108.5 234.5,-145.5 264.5,-145.5 264.5,-108.5 234.5,-108.5" fill=#9fc5e8 stroke=transparent /><polygon points="234.5,-108.5 234.5,-145.5 264.5,-145.5 264.5,-108.5 234.5,-108.5" fill=none stroke=black /><polygon points="264.5,-108.5 264.5,-145.5 294.5,-145.5 294.5,-108.5 264.5,-108.5" fill=#9fc5e8 stroke=transparent /><polygon points="264.5,-108.5 264.5,-145.5 294.5,-145.5 294.5,-108.5 264.5,-108.5" fill=none stroke=black /><polygon points="294.5,-108.5 294.5,-145.5 333.5,-145.5 333.5,-108.5 294.5,-108.5" fill=#9fc5e8 stroke=transparent /><polygon points="294.5,-108.5 294.5,-145.5 333.5,-145.5 333.5,-108.5 294.5,-108.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=105 y=-87.3>1</text><polygon points="129.5,-73.5 129.5,-108.5 159.5,-108.5 159.5,-73.5 129.5,-73.5" fill=#9fc5e8 stroke=transparent /><polygon points="129.5,-73.5 129.5,-108.5 159.5,-108.5 159.5,-73.5 129.5,-73.5" fill=none stroke=black /><polygon points="159.5,-73.5 159.5,-108.5 200.5,-108.5 200.5,-73.5 159.5,-73.5" fill=#9fc5e8 stroke=transparent /><polygon points="159.5,-73.5 159.5,-108.5 200.5,-108.5 200.5,-73.5 159.5,-73.5" fill=none stroke=black /><polygon points="200.5,-73.5 200.5,-108.5 234.5,-108.5 234.5,-73.5 200.5,-73.5" fill=#9fc5e8 stroke=transparent /><polygon points="200.5,-73.5 200.5,-108.5 234.5,-108.5 234.5,-73.5 200.5,-73.5" fill=none stroke=black /><polygon points="234.5,-73.5 234.5,-108.5 264.5,-108.5 264.5,-73.5 234.5,-73.5" fill=#9fc5e8 stroke=transparent /><polygon points="234.5,-73.5 234.5,-108.5 264.5,-108.5 264.5,-73.5 234.5,-73.5" fill=none stroke=black /><polygon points="264.5,-73.5 264.5,-108.5 294.5,-108.5 294.5,-73.5 264.5,-73.5" fill=#9fc5e8 stroke=transparent /><polygon points="264.5,-73.5 264.5,-108.5 294.5,-108.5 294.5,-73.5 264.5,-73.5" fill=none stroke=black /><polygon points="294.5,-73.5 294.5,-108.5 333.5,-108.5 333.5,-73.5 294.5,-73.5" fill=#9fc5e8 stroke=transparent /><polygon points="294.5,-73.5 294.5,-108.5 333.5,-108.5 333.5,-73.5 294.5,-73.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=103 y=-52.3>...</text><polygon points="129.5,-38.5 129.5,-73.5 159.5,-73.5 159.5,-38.5 129.5,-38.5" fill=#9fc5e8 stroke=transparent /><polygon points="129.5,-38.5 129.5,-73.5 159.5,-73.5 159.5,-38.5 129.5,-38.5" fill=none stroke=black /><polygon points="159.5,-38.5 159.5,-73.5 200.5,-73.5 200.5,-38.5 159.5,-38.5" fill=#9fc5e8 stroke=transparent /><polygon points="159.5,-38.5 159.5,-73.5 200.5,-73.5 200.5,-38.5 159.5,-38.5" fill=none stroke=black /><polygon points="200.5,-38.5 200.5,-73.5 234.5,-73.5 234.5,-38.5 200.5,-38.5" fill=#9fc5e8 stroke=transparent /><polygon points="200.5,-38.5 200.5,-73.5 234.5,-73.5 234.5,-38.5 200.5,-38.5" fill=none stroke=black /><polygon points="234.5,-38.5 234.5,-73.5 264.5,-73.5 264.5,-38.5 234.5,-38.5" fill=#9fc5e8 stroke=transparent /><polygon points="234.5,-38.5 234.5,-73.5 264.5,-73.5 264.5,-38.5 234.5,-38.5" fill=none stroke=black /><polygon points="264.5,-38.5 264.5,-73.5 294.5,-73.5 294.5,-38.5 264.5,-38.5" fill=#9fc5e8 stroke=transparent /><polygon points="264.5,-38.5 264.5,-73.5 294.5,-73.5 294.5,-38.5 264.5,-38.5" fill=none stroke=black /><polygon points="294.5,-38.5 294.5,-73.5 333.5,-73.5 333.5,-38.5 294.5,-38.5" fill=#9fc5e8 stroke=transparent /><polygon points="294.5,-38.5 294.5,-73.5 333.5,-73.5 333.5,-38.5 294.5,-38.5" fill=none stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=start x=100.5 y=-17.3>99</text><polygon points="129.5,-3.5 129.5,-38.5 159.5,-38.5 159.5,-3.5 129.5,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="129.5,-3.5 129.5,-38.5 159.5,-38.5 159.5,-3.5 129.5,-3.5" fill=none stroke=black /><polygon points="159.5,-3.5 159.5,-38.5 200.5,-38.5 200.5,-3.5 159.5,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="159.5,-3.5 159.5,-38.5 200.5,-38.5 200.5,-3.5 159.5,-3.5" fill=none stroke=black /><polygon points="200.5,-3.5 200.5,-38.5 234.5,-38.5 234.5,-3.5 200.5,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="200.5,-3.5 200.5,-38.5 234.5,-38.5 234.5,-3.5 200.5,-3.5" fill=none stroke=black /><polygon points="234.5,-3.5 234.5,-38.5 264.5,-38.5 264.5,-3.5 234.5,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="234.5,-3.5 234.5,-38.5 264.5,-38.5 264.5,-3.5 234.5,-3.5" fill=none stroke=black /><polygon points="264.5,-3.5 264.5,-38.5 294.5,-38.5 294.5,-3.5 264.5,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="264.5,-3.5 264.5,-38.5 294.5,-38.5 294.5,-3.5 264.5,-3.5" fill=none stroke=black /><polygon points="294.5,-3.5 294.5,-38.5 333.5,-38.5 333.5,-3.5 294.5,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="294.5,-3.5 294.5,-38.5 333.5,-38.5 333.5,-3.5 294.5,-3.5" fill=none stroke=black /></g><g class=node id=node2><title>label_mat</title><text font-family="Arial Bold" font-size=14.00 text-anchor=middle x=37 y=-123.8>mat[0][1]</text></g><g class=edge id=edge1><title>label_mat->matriz:celula99</title><path d="M74.18,-127.5C97.41,-127.5 127.2,-127.5 149,-127.5" fill=none stroke=#333333 stroke-width=1.5 /><polygon points="149.29,-131 159.29,-127.5 149.29,-124 149.29,-131" fill=#333333 stroke=#333333 stroke-width=1.5 /></g></g></svg></div></div><p>Lembre-se que, assim como nos vetores, a contagem de cada dimensão começa obrigatoriamente no <strong>ZERO</strong> e termina em <strong>N-1</strong>. Portanto, em uma matriz de 100x50, as linhas variam de 0 a 99, enquanto as colunas variam de 0 a 49.</p><h4 id=percorrendo-os-elementos-de-uma-matriz><span class=heading-text>Percorrendo os elementos de uma matriz</span><span class=heading-arabic>7.4.2.1</span></h4><p>Para manipular todos os elementos de uma matriz de forma eficiente, é necessário utilizar o conceito de <strong>aninhamento de repetições</strong>. Como existem dois índices, você precisará de dois laços para percorrer a estrutura completa.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int mat[100][50];
    int i, j;
    
    // O laço externo percorre as linhas
    for (i = 0; i &lt; 100; i++){
        // O laço interno percorre as colunas de cada linha
        for (j = 0; j &lt; 50; j++){
            printf("Digite o valor de mat[%d][%d]: ", i, j);
            scanf("%d", &mat[i][j]);
        }
    }
    
    system("pause");
    return 0;
}
</code></pre><p>Nesse exemplo, utilizamos as variáveis <code>i</code> (para as linhas) e <code>j</code> (para as colunas). O laço interno deve completar todo o seu ciclo (variando de 0 a 49) para cada incremento do laço externo, garantindo que todas as células da tabela sejam processadas.</p><h4 id=propriedades-das-posições-da-matriz><span class=heading-text>Propriedades das posições da matriz</span><span class=heading-arabic>7.4.2.2</span></h4><p>Cada célula individual da matriz comporta-se exatamente como uma variável comum do tipo declarado. Elas podem ser utilizadas em qualquer operação suportada pela linguagem:</p><ul><li><strong>Entrada de dados</strong>: <code>scanf("%d", &mat[5][0]);</code></li><li><strong>Atribuição direta</strong>: <code>mat[0][0] = 10;</code></li><li><strong>Expressões matemáticas</strong>: <code>mat[1][2] = mat[5][0] + mat[0][0];</code></li></ul><div class="callout callout-info"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=10 /><path d="M12 16v-4"/><path d="M12 8h.01"/></svg></span><span class=callout-title-inner>Desempenho de Acesso</span></div><div class=callout-content><p>Todas as posições de uma matriz são igualmente acessíveis pelo sistema. Isso significa que o tempo necessário para o computador ler ou escrever na posição <code>mat[0][0]</code> é idêntico ao tempo gasto para a posição <code>mat[99][49]</code>.</p></div></div><h2 id=array-com-mais-de-duas-dimensões><span class=heading-text>Array com mais de duas dimensões</span><span class=heading-arabic>7.5</span></h2><p>Nas seções anteriores, você aprendeu a estruturar dados em uma única dimensão (vetores) ou em duas dimensões (matrizes). A linguagem <strong>C</strong>, contudo, permite que você expanda essa lógica para criar arrays com múltiplas dimensões de maneira bastante intuitiva.</p><p>A regra fundamental é que cada dimensão do array é definida por um par de colchetes <code>[]</code> em sua declaração.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    // Declara array de int com 1 dimensão
    int vet[5];
    
    // Declara array de float com 2 dimensões
    float mat[5][5];
    
    // Declara array de double com 3 dimensões (cubo)
    double cub[5][5][5];
    
    // Declara array de int com 4 dimensões
    int X[5][5][5][5];

    system("pause");
    return 0;
}
</code></pre><p>Como demonstrado acima, cada par de colchetes adicionado ao nome do array durante a declaração insere uma nova dimensão à estrutura, independentemente do tipo de dado utilizado.</p><h3 id=acesso-e-manipulação><span class=heading-text>Acesso e Manipulação</span><span class=heading-arabic>7.5.1</span></h3><p>Para acessar o valor de uma posição específica, você deve fornecer um índice para cada dimensão existente no array. Consequentemente, para percorrer todos os elementos de uma estrutura multidimensional, você precisará aninhar tantos laços de repetição quantas forem as dimensões do array.</p><p>Veja o exemplo de como preencher um cubo (3 dimensões) com zeros:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int cub[5][5][5];
    int i, j, k;

    // São necessários três laços para percorrer as três dimensões
    for (i = 0; i &lt; 5; i++){
        for (j = 0; j &lt; 5; j++){
            for (k = 0; k &lt; 5; k++){
                cub[i][j][k] = 0; // Atribuição de valor
            }
        }
    }

    system("pause");
    return 0;
}
</code></pre><p>Neste código, as variáveis <code>i</code>, <code>j</code> e <code>k</code> indexam cada uma das dimensões. O aninhamento é necessário porque a primeira dimensão comporta um array de duas dimensões, que por sua vez contém arrays unidimensionais.</p><h3 id=organização-na-memória><span class=heading-text>Organização na Memória</span><span class=heading-arabic>7.5.2</span></h3><p>Embora os colchetes criem a percepção visual de que estamos trabalhando com cubos ou estruturas complexas, é vital que você compreenda que o computador armazena todos os arrays de forma <strong>linear</strong> na memória.</p><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 774.00 242.00" data-sketch=true width=700 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 238)" class=graph id=graph0><title>G</title><polygon points="-4,4 -4,-238 770,-238 770,4 -4,4" fill=white stroke=transparent /><g class=node id=node1><title>matriz</title><text font-family=Arial font-size=14.00 text-anchor=start x=319 y=-218.8>0,0</text><polygon points="338,-193 338,-215 360,-215 360,-193 338,-193" fill=#9fc5e8 stroke=transparent /><polygon points="338,-193 338,-215 360,-215 360,-193 338,-193" fill=none stroke=black /><polygon points="360,-193 360,-215 382,-215 382,-193 360,-193" fill=#9fc5e8 stroke=transparent /><polygon points="360,-193 360,-215 382,-215 382,-193 360,-193" fill=none stroke=black /><polygon points="382,-193 382,-215 404,-215 404,-193 382,-193" fill=#9fc5e8 stroke=transparent /><polygon points="382,-193 382,-215 404,-215 404,-193 382,-193" fill=none stroke=black /><polygon points="404,-193 404,-215 426,-215 426,-193 404,-193" fill=#9fc5e8 stroke=transparent /><polygon points="404,-193 404,-215 426,-215 426,-193 404,-193" fill=none stroke=black /><polygon points="426,-193 426,-215 448,-215 448,-193 426,-193" fill=#9fc5e8 stroke=transparent /><polygon points="426,-193 426,-215 448,-215 448,-193 426,-193" fill=none stroke=black /><polygon points="338,-171 338,-193 360,-193 360,-171 338,-171" fill=#9fc5e8 stroke=transparent /><polygon points="338,-171 338,-193 360,-193 360,-171 338,-171" fill=none stroke=black /><polygon points="360,-171 360,-193 382,-193 382,-171 360,-171" fill=#9fc5e8 stroke=transparent /><polygon points="360,-171 360,-193 382,-193 382,-171 360,-171" fill=none stroke=black /><polygon points="382,-171 382,-193 404,-193 404,-171 382,-171" fill=#9fc5e8 stroke=transparent /><polygon points="382,-171 382,-193 404,-193 404,-171 382,-171" fill=none stroke=black /><polygon points="404,-171 404,-193 426,-193 426,-171 404,-171" fill=#9fc5e8 stroke=transparent /><polygon points="404,-171 404,-193 426,-193 426,-171 404,-171" fill=none stroke=black /><polygon points="426,-171 426,-193 448,-193 448,-171 426,-171" fill=#9fc5e8 stroke=transparent /><polygon points="426,-171 426,-193 448,-193 448,-171 426,-171" fill=none stroke=black /><polygon points="338,-149 338,-171 360,-171 360,-149 338,-149" fill=#9fc5e8 stroke=transparent /><polygon points="338,-149 338,-171 360,-171 360,-149 338,-149" fill=none stroke=black /><polygon points="360,-149 360,-171 382,-171 382,-149 360,-149" fill=#9fc5e8 stroke=transparent /><polygon points="360,-149 360,-171 382,-171 382,-149 360,-149" fill=none stroke=black /><polygon points="382,-149 382,-171 404,-171 404,-149 382,-149" fill=#9fc5e8 stroke=transparent /><polygon points="382,-149 382,-171 404,-171 404,-149 382,-149" fill=none stroke=black /><polygon points="404,-149 404,-171 426,-171 426,-149 404,-149" fill=#9fc5e8 stroke=transparent /><polygon points="404,-149 404,-171 426,-171 426,-149 404,-149" fill=none stroke=black /><polygon points="426,-149 426,-171 448,-171 448,-149 426,-149" fill=#9fc5e8 stroke=transparent /><polygon points="426,-149 426,-171 448,-171 448,-149 426,-149" fill=none stroke=black /><polygon points="338,-127 338,-149 360,-149 360,-127 338,-127" fill=#9fc5e8 stroke=transparent /><polygon points="338,-127 338,-149 360,-149 360,-127 338,-127" fill=none stroke=black /><polygon points="360,-127 360,-149 382,-149 382,-127 360,-127" fill=#9fc5e8 stroke=transparent /><polygon points="360,-127 360,-149 382,-149 382,-127 360,-127" fill=none stroke=black /><polygon points="382,-127 382,-149 404,-149 404,-127 382,-127" fill=#9fc5e8 stroke=transparent /><polygon points="382,-127 382,-149 404,-149 404,-127 382,-127" fill=none stroke=black /><polygon points="404,-127 404,-149 426,-149 426,-127 404,-127" fill=#9fc5e8 stroke=transparent /><polygon points="404,-127 404,-149 426,-149 426,-127 404,-127" fill=none stroke=black /><polygon points="426,-127 426,-149 448,-149 448,-127 426,-127" fill=#9fc5e8 stroke=transparent /><polygon points="426,-127 426,-149 448,-149 448,-127 426,-127" fill=none stroke=black /><polygon points="338,-105 338,-127 360,-127 360,-105 338,-105" fill=#9fc5e8 stroke=transparent /><polygon points="338,-105 338,-127 360,-127 360,-105 338,-105" fill=none stroke=black /><polygon points="360,-105 360,-127 382,-127 382,-105 360,-105" fill=#9fc5e8 stroke=transparent /><polygon points="360,-105 360,-127 382,-127 382,-105 360,-105" fill=none stroke=black /><polygon points="382,-105 382,-127 404,-127 404,-105 382,-105" fill=#9fc5e8 stroke=transparent /><polygon points="382,-105 382,-127 404,-127 404,-105 382,-105" fill=none stroke=black /><polygon points="404,-105 404,-127 426,-127 426,-105 404,-105" fill=#9fc5e8 stroke=transparent /><polygon points="404,-105 404,-127 426,-127 426,-105 404,-105" fill=none stroke=black /><polygon points="426,-105 426,-127 448,-127 448,-105 426,-105" fill=#9fc5e8 stroke=transparent /><polygon points="426,-105 426,-127 448,-127 448,-105 426,-105" fill=none stroke=black /><text font-family=Arial font-size=14.00 text-anchor=start x=429 y=-93.8>4,4</text></g><g class=node id=node2><title>linear</title><text font-family=Arial font-size=14.00 text-anchor=start x=8 y=-27.3>0,0</text><text font-family=Arial font-size=14.00 text-anchor=start x=158 y=-27.3>1,0</text><text font-family=Arial font-size=14.00 text-anchor=start x=308 y=-27.3>2,0</text><text font-family=Arial font-size=14.00 text-anchor=start x=458 y=-27.3>3,0</text><text font-family=Arial font-size=14.00 text-anchor=start x=608 y=-27.3>4,0</text><text font-family=Arial font-size=14.00 text-anchor=start x=739 y=-27.3>4,4</text><polygon points="8,-3.5 8,-23.5 38,-23.5 38,-3.5 8,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="8,-3.5 8,-23.5 38,-23.5 38,-3.5 8,-3.5" fill=none stroke=black /><polygon points="38,-3.5 38,-23.5 68,-23.5 68,-3.5 38,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="38,-3.5 38,-23.5 68,-23.5 68,-3.5 38,-3.5" fill=none stroke=black /><polygon points="68,-3.5 68,-23.5 98,-23.5 98,-3.5 68,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="68,-3.5 68,-23.5 98,-23.5 98,-3.5 68,-3.5" fill=none stroke=black /><polygon points="98,-3.5 98,-23.5 128,-23.5 128,-3.5 98,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="98,-3.5 98,-23.5 128,-23.5 128,-3.5 98,-3.5" fill=none stroke=black /><polygon points="128,-3.5 128,-23.5 158,-23.5 158,-3.5 128,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="128,-3.5 128,-23.5 158,-23.5 158,-3.5 128,-3.5" fill=none stroke=black /><polygon points="158,-3.5 158,-23.5 188,-23.5 188,-3.5 158,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="158,-3.5 158,-23.5 188,-23.5 188,-3.5 158,-3.5" fill=none stroke=black /><polygon points="188,-3.5 188,-23.5 218,-23.5 218,-3.5 188,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="188,-3.5 188,-23.5 218,-23.5 218,-3.5 188,-3.5" fill=none stroke=black /><polygon points="218,-3.5 218,-23.5 248,-23.5 248,-3.5 218,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="218,-3.5 218,-23.5 248,-23.5 248,-3.5 218,-3.5" fill=none stroke=black /><polygon points="248,-3.5 248,-23.5 278,-23.5 278,-3.5 248,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="248,-3.5 248,-23.5 278,-23.5 278,-3.5 248,-3.5" fill=none stroke=black /><polygon points="278,-3.5 278,-23.5 308,-23.5 308,-3.5 278,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="278,-3.5 278,-23.5 308,-23.5 308,-3.5 278,-3.5" fill=none stroke=black /><polygon points="308,-3.5 308,-23.5 338,-23.5 338,-3.5 308,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="308,-3.5 308,-23.5 338,-23.5 338,-3.5 308,-3.5" fill=none stroke=black /><polygon points="338,-3.5 338,-23.5 368,-23.5 368,-3.5 338,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="338,-3.5 338,-23.5 368,-23.5 368,-3.5 338,-3.5" fill=none stroke=black /><polygon points="368,-3.5 368,-23.5 398,-23.5 398,-3.5 368,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="368,-3.5 368,-23.5 398,-23.5 398,-3.5 368,-3.5" fill=none stroke=black /><polygon points="398,-3.5 398,-23.5 428,-23.5 428,-3.5 398,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="398,-3.5 398,-23.5 428,-23.5 428,-3.5 398,-3.5" fill=none stroke=black /><polygon points="428,-3.5 428,-23.5 458,-23.5 458,-3.5 428,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="428,-3.5 428,-23.5 458,-23.5 458,-3.5 428,-3.5" fill=none stroke=black /><polygon points="458,-3.5 458,-23.5 488,-23.5 488,-3.5 458,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="458,-3.5 458,-23.5 488,-23.5 488,-3.5 458,-3.5" fill=none stroke=black /><polygon points="488,-3.5 488,-23.5 518,-23.5 518,-3.5 488,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="488,-3.5 488,-23.5 518,-23.5 518,-3.5 488,-3.5" fill=none stroke=black /><polygon points="518,-3.5 518,-23.5 548,-23.5 548,-3.5 518,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="518,-3.5 518,-23.5 548,-23.5 548,-3.5 518,-3.5" fill=none stroke=black /><polygon points="548,-3.5 548,-23.5 578,-23.5 578,-3.5 548,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="548,-3.5 548,-23.5 578,-23.5 578,-3.5 548,-3.5" fill=none stroke=black /><polygon points="578,-3.5 578,-23.5 608,-23.5 608,-3.5 578,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="578,-3.5 578,-23.5 608,-23.5 608,-3.5 578,-3.5" fill=none stroke=black /><polygon points="608,-3.5 608,-23.5 638,-23.5 638,-3.5 608,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="608,-3.5 608,-23.5 638,-23.5 638,-3.5 608,-3.5" fill=none stroke=black /><polygon points="638,-3.5 638,-23.5 668,-23.5 668,-3.5 638,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="638,-3.5 638,-23.5 668,-23.5 668,-3.5 638,-3.5" fill=none stroke=black /><polygon points="668,-3.5 668,-23.5 698,-23.5 698,-3.5 668,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="668,-3.5 668,-23.5 698,-23.5 698,-3.5 668,-3.5" fill=none stroke=black /><polygon points="698,-3.5 698,-23.5 728,-23.5 728,-3.5 698,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="698,-3.5 698,-23.5 728,-23.5 728,-3.5 698,-3.5" fill=none stroke=black /><polygon points="728,-3.5 728,-23.5 758,-23.5 758,-3.5 728,-3.5" fill=#9fc5e8 stroke=transparent /><polygon points="728,-3.5 728,-23.5 758,-23.5 758,-3.5 728,-3.5" fill=none stroke=black /></g></g></svg></div></div><p>Por esse motivo, existe uma ordem de movimentação na memória que você deve conhecer: a dimensão que "se move" ou varia mais rapidamente é sempre a que está posicionada <strong>mais à direita</strong> na declaração.</p><ul><li><code>int vet[</code><strong>5</strong><code>];</code></li><li><code>float mat[5][</code><strong>5</strong><code>];</code></li><li><code>double cub[5][5][</code><strong>5</strong><code>];</code></li><li><code>int X[5][5][5][</code><strong>5</strong><code>];</code></li></ul><p>Independentemente do número de dimensões, o índice mais à direita é o que percorre endereços adjacentes de memória de forma mais imediata.</p><h2 id=inicialização-de-arrays><span class=heading-text>Inicialização de arrays</span><span class=heading-arabic>7.6</span></h2><p>Como você já aprendeu, arrays funcionam como variáveis: a simples declaração reserva um espaço na memória, mas não associa a ele nenhum valor específico. Inicialmente, esse espaço contém apenas o "lixo de memória". Dependendo do software que você estiver desenvolvendo, é fundamental iniciar todas as posições com um valor predefinido.</p><p>Uma abordagem comum é utilizar um laço de repetição para zerar todas as posições do array, conforme demonstrado no código abaixo:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int vet[5];
    int i;
    // Percorre o array atribuindo zero a cada índice
    for (i = 0; i &lt; 5; i++){
        vet[i] = 0;
    }
    system("pause");
    return 0;
}
</code></pre><p>Embora útil para zerar estruturas, essa técnica torna-se pouco prática se você precisar atribuir um valor diferente e específico para cada posição. Nesses casos, a linguagem <strong>C</strong> oferece uma sintaxe simplificada utilizando o <strong>operador de chaves</strong> <code>{ }</code> durante a declaração.</p><h3 id=utilizando-o-operador-de-chaves><span class=heading-text>Utilizando o operador de chaves</span><span class=heading-arabic>7.6.1</span></h3><p>O operador de chaves permite que você defina uma lista de valores, separados por vírgula, que serão atribuídos ao array no momento em que ele é criado. A forma geral é:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>tipo_dado nome_array[tamanho] = { valor1, valor2, ... };
</code></pre><p>Os dados são inseridos na ordem em que aparecem na lista, começando obrigatoriamente pela posição zero. É importante destacar que esta forma de atribuição em lote <strong>só pode ser realizada no momento da declaração</strong> do array.</p><p>Abaixo, compare a praticidade entre as duas formas de inicialização:</p><div style=gap:2%;display:flex><div style=width:49%><pre class="line-numbers language-c" data-lang=C><code class=language-c>// Com o operador { }
#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    // Inicialização direta
    int vet[5] = {15, 12, 9, 1, 35};
    
    system("pause");
    return 0;
}
</code></pre></div><div style=width:49%><pre class="line-numbers language-c" data-lang=C><code class=language-c>// Sem o operador { }
#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int vet[5];
    // Atribuição manual posição por posição
    vet[0] = 15;
    vet[1] = 12;
    vet[2] = 9;
    vet[3] = 1;
    vet[4] = 35;
    
    system("pause");
    return 0;
}
</code></pre></div></div><h3 id=inicializando-matrizes><span class=heading-text>Inicializando Matrizes</span><span class=heading-arabic>7.6.2</span></h3><p>Para arrays de duas dimensões, você pode seguir dois caminhos distintos para a inicialização:</p><ul><li><strong>Lista única</strong>: Utiliza-se apenas um par de chaves. O compilador preenche a matriz linha por linha, mudando para a próxima apenas quando todas as colunas da linha atual estiverem completas. Isso ocorre porque a dimensão mais à direita é a que varia mais rápido na memória.</li><li><strong>Chaves aninhadas</strong>: Utiliza-se um par de chaves para delimitar cada linha da matriz, o que torna o código mais legível e organizado.</li></ul><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    float vetor[3] = {1.5, 22.1, 4.56};
    
    // Forma 1: Lista única
    int matriz1[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
    
    // Forma 2: Grupos por linha (mais didático)
    int matriz2[3][4] = {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}};
    
    system("pause");
    return 0;
}
</code></pre><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Preenchimento parcial</span></div><div class=callout-content><p>Você não é obrigado a definir valores para todas as posições na inicialização. Caso forneça menos valores do que o tamanho total do array, as posições restantes serão automaticamente inicializadas com o valor <strong>ZERO</strong> (ou o caractere nulo <code>\0</code>).</p></div></div><h3 id=inicialização-de-caracteres-strings><span class=heading-text>Inicialização de caracteres (Strings)</span><span class=heading-arabic>7.6.3</span></h3><p>Para arrays de caracteres, você pode inicializar cada posição individualmente com aspas simples, mas a forma mais prática é utilizar <strong>aspas duplas</strong>, que já inclui automaticamente o caractere terminador <code>\0</code>.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>char str1[10] = {'J', 'o', 'a', 'o', '\0'}; // Manual
char str2[10] = "Joao"; // Prático e automático
</code></pre><h3 id=inicialização-sem-tamanho><span class=heading-text>Inicialização sem tamanho</span><span class=heading-arabic>7.6.4</span></h3><p>Uma facilidade adicional da linguagem <strong>C</strong> é a possibilidade de declarar um array sem especificar seu tamanho entre os colchetes. Ao fazer isso, o compilador conta quantos elementos existem na lista de inicialização e define o tamanho fixo do array com base nessa contagem.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>int vetor[] = {1, 2, 3, 4, 5}; // O compilador define tamanho 5
char texto[] = "Linguagem C."; // O tamanho será 13 (12 letras + '\0')
</code></pre><p>No caso de matrizes ou arrays multidimensionais, apenas a <strong>primeira dimensão</strong> pode ter o tamanho omitido; todas as outras dimensões devem ser explicitamente declaradas.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>// O compilador deduzirá 5 linhas baseado nos 10 elementos (10/2 = 5)
int matriz[][2] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; 
</code></pre><h2 id=exemplos-de-uso-de-arrays><span class=heading-text>Exemplos de uso de arrays</span><span class=heading-arabic>7.7</span></h2><p>Nesta seção, você encontrará exemplos práticos que demonstram as operações fundamentais para a manipulação de <strong>vetores</strong> e <strong>matrizes</strong> na linguagem <strong>C</strong>.</p><h3 id=somando-os-elementos-de-um-vetor><span class=heading-text>Somando os elementos de um vetor</span><span class=heading-arabic>7.7.1</span></h3><p>Somar os dados contidos em um array é uma das tarefas mais comuns em programação. O processo consiste em acumular os valores individuais em uma variável específica.</p><p>Para realizar essa operação, você deve seguir estes passos:</p><ul><li><strong>Inicialização</strong>: Declare uma variável (como <code>soma</code>) e atribua a ela o valor <strong>0</strong>. Isso é essencial para eliminar o lixo de memória e garantir que o acumulador comece neutro.</li><li><strong>Percorrimento</strong>: Utilize um laço de repetição, como o <code>for</code>, para acessar cada índice do vetor.</li><li><strong>Acumulação</strong>: A cada iteração, some o valor da posição atual ao conteúdo já existente na variável <code>soma</code>.</li></ul><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int i, lista[5] = {3, 51, 18, 2, 45};
    int soma = 0; // Inicialização vital para o acumulador

    for(i = 0; i &lt; 5; i++)
        soma = soma + lista[i]; // Acumula o valor de cada posição

    printf("Soma = %d\n", soma);
    system("pause");
    return 0;
}
</code></pre><h3 id=encontrando-o-maior-valor-de-um-vetor><span class=heading-text>Encontrando o maior valor de um vetor</span><span class=heading-arabic>7.7.2</span></h3><p>O procedimento para localizar o maior elemento em um conjunto de dados é idêntico para vetores, matrizes ou estruturas multidimensionais.</p><p>Para isso, você utilizará uma variável auxiliar (como <code>Maior</code>):</p><ul><li><strong>Valor Inicial</strong>: Inicialize a variável <code>Maior</code> com o conteúdo da <strong>primeira posição</strong> do vetor (<code>lista[0]</code>). Nunca utilize zero para inicializar, pois se o vetor contiver apenas números negativos, o zero seria erroneamente apontado como o maior valor.</li><li><strong>Comparação</strong>: Percorra o restante do vetor comparando cada posição com o valor armazenado em <code>Maior</code>.</li><li><strong>Atualização</strong>: Se encontrar um valor superior ao atual, a variável <code>Maior</code> assume esse novo número.</li></ul><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int i, lista[5] = {3, 18, 2, 51, 45};
    int Maior = lista[0]; // Começa comparando a partir do primeiro elemento

    for(i = 1; i &lt; 5; i++){
        if(Maior &lt; lista[i]) // Se a posição atual for maior que a armazenada
            Maior = lista[i]; // Atualiza o maior valor encontrado
    }

    printf("Maior = %d\n", Maior);
    system("pause");
    return 0;
}
</code></pre><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Localizando o Menor Valor</span></div><div class=callout-content><p>Para encontrar o menor elemento, a lógica é exatamente a mesma: basta inverter o operador de comparação no comando <code>if</code> para <code>Maior > lista[i]</code>.</p></div></div><h3 id=calculando-a-média-dos-elementos-de-um-vetor><span class=heading-text>Calculando a média dos elementos de um vetor</span><span class=heading-arabic>7.7.3</span></h3><p>O cálculo da média é uma extensão natural da soma. Primeiramente, você deve somar todos os elementos utilizando um laço de repetição e, em seguida, dividir o total pelo número de elementos do array.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int i, lista[5] = {3, 51, 18, 2, 45};
    int soma = 0;
    for(i = 0; i &lt; 5; i++)
        soma = soma + lista[i];

    // Divide pelo total de elementos usando um valor real para precisão
    float media = soma / 5.0; 
    
    printf("Media = %f\n", media);
    system("pause");
    return 0;
}
</code></pre><h3 id=somando-os-elementos-de-uma-matriz><span class=heading-text>Somando os elementos de uma matriz</span><span class=heading-arabic>7.7.4</span></h3><p>A lógica para somar elementos em uma <strong>matriz</strong> é análoga à do vetor, com a necessidade de adaptar o percorrimento para as duas dimensões (linhas e colunas).</p><p>Para processar cada célula, você deve utilizar dois laços de repetição aninhados. Assim como no vetor, a variável acumuladora deve ser inicializada com <strong>0</strong>.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main(){
    int mat[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    int i, j, soma = 0;

    // Dois laços são necessários para percorrer as duas dimensões
    for(i = 0; i &lt; 3; i++)
        for(j = 0; j &lt; 3; j++)
            soma = soma + mat[i][j]; // Acumula cada célula da matriz

    printf("Soma = %d\n", soma);
    system("pause");
    return 0;
}
</code></pre></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Tópicos de Programação II (TEP II)`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>