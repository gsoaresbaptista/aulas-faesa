<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Sistemas Digitais e Microprocessados</title><link media="(prefers-color-scheme: light)" href=/aulas-faesa/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/aulas-faesa/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/aulas-faesa/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Sistemas Digitais e Microprocessados</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#introdução>6.1. Introdução</a></li><li class="toc-item level-2"><a href=#constantes-e-variáveis-booleanas>6.2. Constantes e Variáveis Booleanas</a></li><li class="toc-item level-2"><a href=#tabela-verdade>6.3. Tabela-Verdade</a></li><li class="toc-item level-2"><a href=#operações-booleanas>6.4. Operações booleanas</a></li><li class="toc-item level-3"><a href=#operação-or-ou>6.4.1. Operação OR ('OU')</a></li><li class="toc-item level-3"><a href=#operação-and-e>6.4.2. Operação AND ('E')</a></li><li class="toc-item level-3"><a href=#operação-not-não>6.4.3. Operação NOT ('NÃO')</a></li><li class="toc-item level-3"><a href=#resumo-das-operações-booleanas>6.4.4. Resumo das Operações Booleanas</a></li><li class="toc-item level-2"><a href=#questões>6.5. Questões</a></li><li class="toc-item level-2"><a href=#próximos-passos>6.6. Próximos passos</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=5-codes.html><i class=nav-icon data-lucide=chevron-left></i> Códigos</a><a class="sidebar-nav-link next" href=7-building-circuits-from-expressions.html>Algebra para Circuitos <i class=nav-icon data-lucide=chevron-right></i></a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>6</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>Tabela-verdade e Portas Lógicas</span> <span class="title-ornament right">❧</span></h1><p class=article-date>24/02/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Sistemas Digitais e Microprocessados</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-III>III - Lógica Combinacional - I</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>Tabela-verdade e Portas Lógicas</span></nav></header><div class=article-body><h2 id=introdução><span class=heading-text>Introdução</span><span class=heading-arabic>6.1</span></h2><p>Até aqui foram apresentados os conceitos básicos de circuitos e níveis lógicos, nos quais existem apenas duas condições possíveis: verdadeiro ou falso, representadas de forma natural pelo sistema binário (0 e 1). Para compreender o funcionamento desses circuitos, são necessários métodos que descrevam como as decisões lógicas são tomadas, tema abordado ao longo do capítulo.</p><p>A lógica booleana, criada por George Boole em 1854, utiliza símbolos para representar e simplificar expressões lógicas, permitindo descrever a relação entre entradas e saídas dos circuitos. Com ela, estudam-se as portas lógicas, base dos sistemas digitais, e realizam-se análises, projetos e simplificações de circuitos. Outras ferramentas, como tabelas-verdade, esquemas, diagramas de tempo e linguagens, complementam esse processo. O domínio dessas técnicas, aliado à prática constante, é essencial para o desenvolvimento de habilidade e confiança em sistemas digitais.</p><h2 id=constantes-e-variáveis-booleanas><span class=heading-text>Constantes e Variáveis Booleanas</span><span class=heading-arabic>6.2</span></h2><p>A principal diferença da álgebra booleana e a convencional é que, na booleana, as constantes e variáveis podem ter apenas dois valores possíveis 1 ou 0, enquanto na convencional elas podem assumir qualquer valor numérico. Por conta dessa característica, a álgebra booleana é muito utilizada para representa por nível de tensão presente em uma conexão ou em em terminais de entrada/saída de um circuito.</p><p>Nesse contexto as variáveis booleanas (0 ou 1) não representam efetivamente números, mas o estado do nível de tensão (baixo ou alto, respectivamente). As entradas em circuitos booleanos são na verdade, variáveis lógicas cujos níveis determinam a qualquer momento os níveis da(s) saída(s). Ou seja, para uma determinado circuito, teremos as entradas, por exemplo, $A$ e $B$ e queremos encontrar uma equação da álgebra booleana que nos determina a saída dependendo de como colocamos as entradas, uma vez que elas podem, e certamente irão mudar.</p><p>Pense no exemplo de um sistema de controle de acesso em que a entrada $A$ indica se a campainha foi acionada e a variável $B$ indica se a pessoa possui cadastro facial. A entrada só é permitida quando ambas as condições forem verdadeiras, de modo que a saída é dada por $S = A \text{ E } B$. Como cada pessoa pode ou não acionar a campainha e pode ou não estar cadastrada, os valores de $A$ e $B$ variam, mas a regra lógica permanece a mesma: apenas quando as duas entradas são verdadeiras a saída permite o acesso. Esse raciocínio é análogo às equações da álgebra tradicional, porém limitado a dois valores possíveis, 1 ou 0, que representam verdadeiro ou falso na lógica proposicional.</p><p>Justamente por trabalhar apenas com dois valores, a álgebra booleana é mais simples que a álgebra convencional, não envolvendo frações, números negativos ou operações complexas. Ela se baseia em três operações fundamentais, <code>OR (OU)</code>, <code>AND (E)</code> e <code>NOT (NÃO)</code>, chamadas de operações lógicas. Essas operações são implementadas fisicamente por circuitos digitais conhecidos como portas lógicas, construídas a partir de componentes eletrônicos. A álgebra booleana é utilizada tanto para descrever e analisar essas portas básicas quanto para projetar e estudar circuitos lógicos combinacionais mais complexos.</p><h2 id=tabela-verdade><span class=heading-text>Tabela-Verdade</span><span class=heading-arabic>6.3</span></h2><p>Utilizamos a tabela-verdade como uma forma organizada de descrever como a saída de um circuito lógico depende dos níveis lógicos aplicados às suas entradas. Nela, <strong>relacionamos todas as combinações possíveis das entradas com o nível lógico correspondente da saída</strong>, o que permite compreender claramente o <strong>comportamento do circuito em cada situação</strong>.</p><p>Em uma tabela com duas entradas, analisamos todas as combinações possíveis entre $A$ e $B$ e observamos qual será o valor da saída $x$ em cada caso. Por exemplo, podem existir situações em que ambas as entradas estão em nível 0 e a saída assume nível 1, ou casos em que apenas uma das entradas está em nível 1 e a saída muda de estado. Dessa forma, torna-se possível visualizar como o circuito reage a cada condição de entrada.</p><p>Esse mesmo raciocínio se estende a circuitos com três ou quatro entradas. À medida que o número de entradas aumenta, cresce também o número de combinações possíveis, mas a ideia permanece a mesma: no lado esquerdo da tabela colocamos todas as combinações dos níveis lógicos de entrada e, no lado direito, registramos o nível lógico resultante da saída, que depende exclusivamente do tipo de circuito lógico analisado.</p><p><img alt="Exemplos de tabelas-verdade para circuitos de (a) duas, (b) três e (c) quatro entradas." src=static/tabela_verdade.png></p><p>De modo geral, uma tabela-verdade com $N$ entradas possui $2^N$ combinações possíveis, <strong>organizadas como uma contagem binária</strong>. Essa organização facilita o preenchimento da tabela e garante que nenhuma combinação de entrada seja esquecida, tornando a tabela-verdade uma ferramenta essencial para a análise de circuitos lógicos.</p><hr><p><strong>Problema:</strong> Considere um circuito lógico com duas entradas, $A$ e $B$, e uma saída $x$. A saída assume nível lógico 1 apenas quando exatamente uma das entradas está em nível 1. Nos demais casos, a saída é 0.</p><p><strong>a) Escreva a tabela-verdade para o circuito.</strong></p><p>$$ \begin{array}{c|c||c} A & B & x \\ \hline 0 & 0 & 0 \\ 0 & 1 & 1 \\ 1 & 0 & 1 \\ 1 & 1 & 0 \\ \end{array} $$</p><p><strong>b) Explique, com base na tabela-verdade, como o circuito se comporta quando as entradas possuem o mesmo nível lógico.</strong></p><p>Quando as entradas possuem o mesmo nível lógico (ambas $0$ ou ambas $1$), a saída do circuito é $0$. A saída assume valor $1$ apenas quando exatamente uma das entradas está em nível lógico $1$, caracterizando o comportamento de uma porta lógica do tipo $XOR$ (OU exclusivo).</p><hr><p><strong>Problema:</strong> Uma tabela-verdade com $8$ variáveis de entrada possui quantas linhas?</p><p>Uma tabela-verdade com $N$ variáveis possui $2^N$ linhas. Assim, para $N = 8$:</p><p>$$\boxed{2^8 = 256}$$</p><p>Portanto, a tabela-verdade possui <strong>256 linhas</strong>.</p><h2 id=operações-booleanas><span class=heading-text>Operações booleanas</span><span class=heading-arabic>6.4</span></h2><h3 id=operação-or-ou><span class=heading-text>Operação OR ('OU')</span><span class=heading-arabic>6.4.1</span></h3><p>Para compreendermos como circuitos complexos e compiladores tomam decisões, precisamos retornar às bases da álgebra booleana. A operação OR é o primeiro dos três pilares fundamentais (junto ao AND e NOT) que utilizaremos para descrever o comportamento lógico de qualquer sistema digital.</p><p>Para visualizar essa lógica na prática, pense no funcionamento de uma lâmpada interna de um forno de cozinha. O objetivo é simples: a lâmpada deve acender se o usuário desejar ver a comida ou se for necessário por segurança ao abrir a porta. Podemos modelar esse sistema usando variáveis booleanas:</p><ul><li><strong>Entrada A:</strong> O interruptor manual está acionado? (0 para Não, 1 para Sim)</li><li><strong>Entrada B:</strong> A porta do forno está aberta? (0 para Não, 1 para Sim)</li><li><strong>Saída x:</strong> A lâmpada está acesa? (0 para Apagada, 1 para Acesa)</li></ul><p>Nesse cenário, a lâmpada ($x$) será ativada se $A$ OU $B$ forem verdadeiros. Diferente da aritmética tradicional, na álgebra booleana o símbolo de adição ($+$) representa a operação lógica OR. Portanto, a expressão matemática que define esse comportamento é: $$ x = A + B $$</p><p>Na álgebra booleana, não estamos somando quantidades, mas sim combinando estados lógicos. Diferente da aritmética decimal, onde $1+1=2$, a lógica booleana opera em um sistema de saturação de sinal. Como o valor máximo permitido é 1 (Nível Alto), qualquer combinação de sinais verdadeiros resultará em verdadeiro.</p><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Regra de Ouro Na lógica OR, a operação produz:</span></div><div class=callout-content><p>$$1 + 1 = 1$$ Isso ocorre porque, uma vez que o canal atinge o estado "Verdadeiro", <strong>a adição de mais fontes de sinal</strong> não altera seu estado final.</p></div></div><p>Esse princípio de saturação é escalável. Ao expandirmos o circuito para três entradas ($A$,$B$ e $C$), a expressão resultante é $x = A + B + C$. Se todas as entradas estiverem em nível lógico 1, o resultado permanece inalterado: $x = 1 + 1 + 1 = 1$.</p><p>Para facilitar a transição do pensamento lógico para a implementação, a leitura das expressões deve ser feita da seguinte forma:</p><ul><li>$x = A + B$: Lê-se "x é igual a A <strong>OU</strong> B";</li><li>$x = A + B + C$: Lê-se "x é igual a A <strong>OU</strong> B <strong>OU</strong> C";</li></ul><p>Em termos práticos, dizemos que a saída x será verdadeira (1) sempre que A for verdadeiro, OU B for verdadeiro, OU C for verdadeiro (ou qualquer combinação simultânea entre eles). Abaixo, a representação da operação OR para um sistema de duas variáveis de entrada e uma saída, demonstrando que a saída só é nula quando há ausência total de sinal em todas as entradas, ao lado da tabela vemos a representação da porta lógica.</p><div class=col2><div>$$ \begin{array}{cc||c} A & B & x = A + B + C \\ \hline 0 & 0 & 0 \\ 0 & 1 & 1 \\ 1 & 0 & 1 \\ 1 & 1 & 1 \\ \end{array} $$</div><div><div class=no-break><div class=centered><svg viewbox="0 0 101.508 44.64" class=svg-graph version=1.1 width=150 xmlns=http://www.w3.org/2000/svg xmlns:dc=http://purl.org/dc/elements/1.1/ xmlns:ns2=http://creativecommons.org/ns# xmlns:rdf=http://www.w3.org/1999/02/22-rdf-syntax-ns#><metadata><rdf:rdf><ns2:work><dc:type rdf:resource=http://purl.org/dc/dcmitype/StillImage /><dc:date>2026-02-12T17:56:37.374517</dc:date><dc:format>image/svg+xml</dc:format><dc:creator><ns2:agent><dc:title>Matplotlib v3.10.8, https://matplotlib.org/</dc:title></ns2:agent></dc:creator></ns2:work></rdf:rdf></metadata><defs><style type=text/css>*{stroke-linejoin:round;stroke-linecap:butt}</style></defs><g id=figure_1><g id=patch_1><path d="M 0 44.64 L 101.508 44.64 L 101.508 0 L 0 0 L 0 44.64 z" style=fill:none /></g><g id=axes_1><g id=line2d_1><path d="M 30.288 39.96 L 49.830857 39.893878 L 51.888 39.6 L 53.945143 39.07102 L 56.002286 38.306939 L 58.059429 37.307755 L 60.116571 36.073469 L 62.173714 34.604082 L 64.230857 32.899592 L 66.802286 30.438367 L 69.373714 27.609796 L 71.945143 24.413878 L 73.488 22.32 L 73.488 22.32 L 70.916571 18.903673 L 68.345143 15.854694 L 65.773714 13.173061 L 63.202286 10.858776 L 61.145143 9.271837 L 59.088 7.92 L 57.030857 6.803265 L 54.973714 5.921633 L 52.916571 5.275102 L 50.859429 4.863673 L 48.802286 4.687347 L 48.288 4.68 L 30.288 4.68 L 30.288 4.68 L 32.2752 6.84 L 34.0032 9 L 35.472 11.16 L 36.6816 13.32 L 37.632 15.48 L 38.3232 17.64 L 38.7552 19.8 L 38.928 21.96 L 38.8416 24.12 L 38.496 26.28 L 37.8912 28.44 L 37.0272 30.6 L 35.904 32.76 L 34.5216 34.92 L 32.88 37.08 L 30.9792 39.24 L 30.288 39.96 L 30.288 39.96" clip-path=url(#p8fb559ec71) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_2><path d="M 17.688 31.32 L 36.6816 31.32" clip-path=url(#p8fb559ec71) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_3><path d="M 17.688 13.32 L 36.6816 13.32" clip-path=url(#p8fb559ec71) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_4><path d="M 73.488 22.32 L 86.088 22.32" clip-path=url(#p8fb559ec71) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=text_1><text style="text-anchor:start;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 89.688 26.183125)" x=89.688 y=26.183125>x</text></g><g id=text_2><text style="text-anchor:end;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 14.088 17.183125)" x=14.088 y=17.183125>A</text></g><g id=text_3><text style="text-anchor:end;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 14.088 35.183125)" x=14.088 y=35.183125>B</text></g></g></g><defs><clippath id=p8fb559ec71><rect height=44.64 width=101.508 x=0 y=0 /></clippath></defs></svg></div></div> $$ x = A + B $$</div></div><p>Reiterando, as entradas A e B são níveis lógicos de tensão, e a saída x é um nível lógico de tensão cujo valor é o resultado da operação OR entre A e B; ou seja, $x = A + B$. Em outras palavras, a porta OR opera de modo que sua saída será ALTA (nível lógico 1) se a entrada A ou B ou ambas forem nível lógico 1. A saída de uma porta OR será nível BAIXO (nível lógico 0) apenas se todas as entradas forem nível 0. Essa mesma ideia pode ser estendida para quando houver mais de duas entradas, veja abaixo um exemplo para três variáveis de entrada (A, B e C).</p><div class=col2><div>$$ \begin{array}{ccc||c} A & B & C & x = A + B + C \\ \hline 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 1 \\ 0 & 1 & 0 & 1 \\ 0 & 1 & 1 & 1 \\ 1 & 0 & 0 & 1 \\ 1 & 0 & 1 & 1 \\ 1 & 1 & 0 & 1 \\ 1 & 1 & 1 & 1 \end{array} $$</div><div><div class=no-break><div class=centered><svg viewbox="0 0 101.508 47.12" class=svg-graph version=1.1 width=150 xmlns=http://www.w3.org/2000/svg xmlns:dc=http://purl.org/dc/elements/1.1/ xmlns:ns2=http://creativecommons.org/ns# xmlns:rdf=http://www.w3.org/1999/02/22-rdf-syntax-ns#><metadata><rdf:rdf><ns2:work><dc:type rdf:resource=http://purl.org/dc/dcmitype/StillImage /><dc:date>2026-02-12T17:56:37.388011</dc:date><dc:format>image/svg+xml</dc:format><dc:creator><ns2:agent><dc:title>Matplotlib v3.10.8, https://matplotlib.org/</dc:title></ns2:agent></dc:creator></ns2:work></rdf:rdf></metadata><defs><style type=text/css>*{stroke-linejoin:round;stroke-linecap:butt}</style></defs><g id=figure_1><g id=patch_1><path d="M 0 47.12 L 101.508 47.12 L 101.508 0 L 0 0 L 0 47.12 z" style=fill:none /></g><g id=axes_1><g id=line2d_1><path d="M 30.288 41.2 L 49.830857 41.133878 L 51.888 40.84 L 53.945143 40.31102 L 56.002286 39.546939 L 58.059429 38.547755 L 60.116571 37.313469 L 62.173714 35.844082 L 64.230857 34.139592 L 66.802286 31.678367 L 69.373714 28.849796 L 71.945143 25.653878 L 73.488 23.56 L 73.488 23.56 L 70.916571 20.143673 L 68.345143 17.094694 L 65.773714 14.413061 L 63.202286 12.098776 L 61.145143 10.511837 L 59.088 9.16 L 57.030857 8.043265 L 54.973714 7.161633 L 52.916571 6.515102 L 50.859429 6.103673 L 48.802286 5.927347 L 48.288 5.92 L 30.288 5.92 L 30.288 5.92 L 32.2752 8.08 L 34.0032 10.24 L 35.472 12.4 L 36.6816 14.56 L 37.632 16.72 L 38.3232 18.88 L 38.7552 21.04 L 38.928 23.2 L 38.8416 25.36 L 38.496 27.52 L 37.8912 29.68 L 37.0272 31.84 L 35.904 34 L 34.5216 36.16 L 32.88 38.32 L 30.9792 40.48 L 30.288 41.2 L 30.288 41.2" clip-path=url(#p96d448db32) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_2><path d="M 17.688 35.44 L 35.0112 35.44" clip-path=url(#p96d448db32) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_3><path d="M 17.688 23.56 L 38.9316 23.56" clip-path=url(#p96d448db32) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_4><path d="M 17.688 11.68 L 35.0112 11.68" clip-path=url(#p96d448db32) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_5><path d="M 73.488 23.56 L 86.088 23.56" clip-path=url(#p96d448db32) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=text_1><text style="text-anchor:start;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 89.688 27.423125)" x=89.688 y=27.423125>x</text></g><g id=text_2><text style="text-anchor:end;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 14.088 15.543125)" x=14.088 y=15.543125>A</text></g><g id=text_3><text style="text-anchor:end;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 14.088 27.423125)" x=14.088 y=27.423125>B</text></g><g id=text_4><text style="text-anchor:end;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 14.088 39.303125)" x=14.088 y=39.303125>C</text></g></g></g><defs><clippath id=p96d448db32><rect height=47.12 width=101.508 x=0 y=0 /></clippath></defs></svg></div></div> $$ x = A + B + C $$</div></div><h3 id=operação-and-e><span class=heading-text>Operação AND ('E')</span><span class=heading-arabic>6.4.2</span></h3><p>A operação AND é a segunda operação booleana básica. Para visualizar essa lógica na prática, considere o funcionamento de uma secadora de roupas que só opera se o temporizador estiver acima de zero AND (E) a porta estiver fechada. Podemos modelar esse sistema usando variáveis booleanas:</p><ul><li><strong>Entrada A:</strong> O temporizador está acima de zero? (0 para Não, 1 para Sim)</li><li><strong>Entrada B:</strong> A porta está fechada? (0 para Não, 1 para Sim)</li><li><strong>Saída x:</strong> Aquecedor e motor ligados? (0 para Desligado, 1 para Ligado)</li></ul><p>Nesse cenário, a saída ($x$) só será ativada se $A$ E $B$ forem verdadeiros. Na álgebra booleana, o sinal ($\cdot$) representa a operação AND; embora equivalha à multiplicação convencional, ele indica uma relação lógica. A expressão matemática que define esse comportamento é: $$ x = A \cdot B \quad \text{ou} \quad x = AB $$</p><p>Nessa análise, a operação AND sobre variáveis booleanas funciona exatamente como a multiplicação de 0s e 1s. Se qualquer entrada for 0, o produto será 0. A saída só atinge o nível lógico 1 se todas as entradas forem simultaneamente 1.</p><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Regra de Ouro Na lógica AND, a operação produz:</span></div><div class=callout-content><p>$$1 \cdot 1 = 1$$ Isso ocorre porque a saída será 1 <strong>somente quando todas as entradas forem 1</strong>; para todos os outros casos, a saída será 0.</p></div></div><p>Esse princípio de restrição é escalável. Ao expandirmos o circuito para três entradas ($A, B$ e $C$), a expressão resultante é $x = ABC$. Se todas as entradas estiverem em nível lógico 1, o resultado permanece 1. Caso contrário, teremos $x = 0$.</p><p>Para facilitar a transição do pensamento lógico para a implementação, a leitura das expressões deve ser feita da seguinte forma:</p><ul><li>$x = AB$: Lê-se "x é igual a A <strong>E</strong> B";</li><li>$x = ABC$: Lê-se "x é igual a A <strong>E</strong> B <strong>E</strong> C";</li></ul><p>Em termos práticos, dizemos que a saída x será verdadeira (1) somente quando A for verdadeiro, E B for verdadeiro, E C for verdadeiro. Abaixo, a representação da operação AND para duas variáveis de entrada, demonstrando a seletividade da saída, ao lado da tabela vemos a representação da porta lógica.</p><div class=col2><div>$$ \begin{array}{cc||c} A & B & x = AB \\ \hline 0 & 0 & 0 \\ 0 & 1 & 0 \\ 1 & 0 & 0 \\ 1 & 1 & 1 \\ \end{array} $$</div><div><div class=no-break><div class=centered><svg viewbox="0 0 99.708 45.36" class=svg-graph version=1.1 width=150 xmlns=http://www.w3.org/2000/svg xmlns:dc=http://purl.org/dc/elements/1.1/ xmlns:ns2=http://creativecommons.org/ns# xmlns:rdf=http://www.w3.org/1999/02/22-rdf-syntax-ns#><metadata><rdf:rdf><ns2:work><dc:type rdf:resource=http://purl.org/dc/dcmitype/StillImage /><dc:date>2026-02-12T17:56:37.398337</dc:date><dc:format>image/svg+xml</dc:format><dc:creator><ns2:agent><dc:title>Matplotlib v3.10.8, https://matplotlib.org/</dc:title></ns2:agent></dc:creator></ns2:work></rdf:rdf></metadata><defs><style type=text/css>*{stroke-linejoin:round;stroke-linecap:butt}</style></defs><g id=figure_1><g id=patch_1><path d="M 0 45.36 L 99.708 45.36 L 99.708 0 L 0 0 L 0 45.36 z" style=fill:none /></g><g id=axes_1><g id=line2d_1><path d="M 53.688 40.68 L 54.841264 40.643017 L 55.989789 40.53222 L 57.128855 40.348065 L 58.253783 40.091308 L 59.359948 39.763003 L 60.442806 39.364502 L 61.497907 38.89744 L 62.520916 38.363737 L 63.507628 37.765586 L 64.45399 37.105445 L 65.356111 36.386027 L 66.210286 35.610288 L 67.013004 34.781416 L 67.760967 33.902816 L 68.451101 32.9781 L 69.08057 32.011066 L 69.646788 31.005689 L 70.147427 29.9661 L 70.580432 28.896571 L 70.944021 27.801497 L 71.236702 26.685377 L 71.457272 25.552798 L 71.604824 24.408414 L 71.678752 23.256928 L 71.678752 22.103072 L 71.604824 20.951586 L 71.457272 19.807202 L 71.236702 18.674623 L 70.944021 17.558503 L 70.580432 16.463429 L 70.147427 15.3939 L 69.646788 14.354311 L 69.08057 13.348934 L 68.451101 12.3819 L 67.760967 11.457184 L 67.013004 10.578584 L 66.210286 9.749712 L 65.356111 8.973973 L 64.45399 8.254555 L 63.507628 7.594414 L 62.520916 6.996263 L 61.497907 6.46256 L 60.442806 5.995498 L 59.359948 5.596997 L 58.253783 5.268692 L 57.128855 5.011935 L 55.989789 4.82778 L 54.841264 4.716983 L 53.688 4.68 L 53.688 4.68 L 30.288 4.68 L 30.288 22.68 L 30.288 40.68 L 53.688 40.68" clip-path=url(#p595d1e2f5d) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_2><path d="M 17.688 31.68 L 30.288 31.68" clip-path=url(#p595d1e2f5d) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_3><path d="M 17.688 13.68 L 30.288 13.68" clip-path=url(#p595d1e2f5d) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_4><path d="M 71.688 22.68 L 84.288 22.68" clip-path=url(#p595d1e2f5d) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=text_1><text style="text-anchor:start;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 87.888 26.543125)" x=87.888 y=26.543125>x</text></g><g id=text_2><text style="text-anchor:end;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 14.088 17.543125)" x=14.088 y=17.543125>A</text></g><g id=text_3><text style="text-anchor:end;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 14.088 35.543125)" x=14.088 y=35.543125>B</text></g></g></g><defs><clippath id=p595d1e2f5d><rect height=45.36 width=99.708 x=0 y=0 /></clippath></defs></svg></div></div> $$ x = AB $$</div></div><p>As entradas A e B são níveis lógicos de tensão, e a saída x é o resultado do produto lógico entre elas. Observe que, no diagrama, a porta AND possui uma base reta, o que a diferencia visualmente da porta OR. Essa mesma lógica se estende para sistemas com mais entradas, como no exemplo abaixo para três variáveis (A, B e C).</p><div class=col2><div>$$ \begin{array}{ccc||c} A & B & C & x = ABC \\ \hline 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 1 & 1 & 0 \\ 1 & 0 & 0 & 0 \\ 1 & 0 & 1 & 0 \\ 1 & 1 & 0 & 0 \\ 1 & 1 & 1 & 1 \end{array} $$</div><div><div class=no-break><div class=centered><svg viewbox="0 0 99.708 47.12" class=svg-graph version=1.1 width=150 xmlns=http://www.w3.org/2000/svg xmlns:dc=http://purl.org/dc/elements/1.1/ xmlns:ns2=http://creativecommons.org/ns# xmlns:rdf=http://www.w3.org/1999/02/22-rdf-syntax-ns#><metadata><rdf:rdf><ns2:work><dc:type rdf:resource=http://purl.org/dc/dcmitype/StillImage /><dc:date>2026-02-12T17:56:37.409398</dc:date><dc:format>image/svg+xml</dc:format><dc:creator><ns2:agent><dc:title>Matplotlib v3.10.8, https://matplotlib.org/</dc:title></ns2:agent></dc:creator></ns2:work></rdf:rdf></metadata><defs><style type=text/css>*{stroke-linejoin:round;stroke-linecap:butt}</style></defs><g id=figure_1><g id=patch_1><path d="M 0 47.12 L 99.708 47.12 L 99.708 0 L 0 0 L 0 47.12 z" style=fill:none /></g><g id=axes_1><g id=line2d_1><path d="M 53.688 41.56 L 54.841264 41.523017 L 55.989789 41.41222 L 57.128855 41.228065 L 58.253783 40.971308 L 59.359948 40.643003 L 60.442806 40.244502 L 61.497907 39.77744 L 62.520916 39.243737 L 63.507628 38.645586 L 64.45399 37.985445 L 65.356111 37.266027 L 66.210286 36.490288 L 67.013004 35.661416 L 67.760967 34.782816 L 68.451101 33.8581 L 69.08057 32.891066 L 69.646788 31.885689 L 70.147427 30.8461 L 70.580432 29.776571 L 70.944021 28.681497 L 71.236702 27.565377 L 71.457272 26.432798 L 71.604824 25.288414 L 71.678752 24.136928 L 71.678752 22.983072 L 71.604824 21.831586 L 71.457272 20.687202 L 71.236702 19.554623 L 70.944021 18.438503 L 70.580432 17.343429 L 70.147427 16.2739 L 69.646788 15.234311 L 69.08057 14.228934 L 68.451101 13.2619 L 67.760967 12.337184 L 67.013004 11.458584 L 66.210286 10.629712 L 65.356111 9.853973 L 64.45399 9.134555 L 63.507628 8.474414 L 62.520916 7.876263 L 61.497907 7.34256 L 60.442806 6.875498 L 59.359948 6.476997 L 58.253783 6.148692 L 57.128855 5.891935 L 55.989789 5.70778 L 54.841264 5.596983 L 53.688 5.56 L 53.688 5.56 L 30.288 5.56 L 30.288 23.56 L 30.288 41.56 L 53.688 41.56" clip-path=url(#p4fb32fe7ce) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_2><path d="M 17.688 35.44 L 30.288 35.44" clip-path=url(#p4fb32fe7ce) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_3><path d="M 17.688 23.56 L 30.288 23.56" clip-path=url(#p4fb32fe7ce) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_4><path d="M 17.688 11.68 L 30.288 11.68" clip-path=url(#p4fb32fe7ce) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_5><path d="M 71.688 23.56 L 84.288 23.56" clip-path=url(#p4fb32fe7ce) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=text_1><text style="text-anchor:start;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 87.888 27.423125)" x=87.888 y=27.423125>x</text></g><g id=text_2><text style="text-anchor:end;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 14.088 15.543125)" x=14.088 y=15.543125>A</text></g><g id=text_3><text style="text-anchor:end;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 14.088 27.423125)" x=14.088 y=27.423125>B</text></g><g id=text_4><text style="text-anchor:end;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 14.088 39.303125)" x=14.088 y=39.303125>C</text></g></g></g><defs><clippath id=p4fb32fe7ce><rect height=47.12 width=99.708 x=0 y=0 /></clippath></defs></svg></div></div> $$ x = ABC $$</div></div><p>Para fechar a trindade lógica fundamental, aqui está a reestruturação da Operação NOT, seguindo rigorosamente a disposição visual e o padrão de texto que você estabeleceu para as operações OR e AND. Markdown</p><h3 id=operação-not-não><span class=heading-text>Operação NOT ('NÃO')</span><span class=heading-arabic>6.4.3</span></h3><p>A operação <strong>NOT</strong>, também conhecida como <strong>Inversão</strong> ou <strong>Complemento</strong>, diferencia-se das operações OR e AND por um detalhe fundamental: ela é uma operação unária, ou seja, é realizada sobre uma única variável de entrada. Sua função é atuar como um inversor de estado, transformando um nível lógico em seu oposto absoluto.</p><p>Para visualizar essa lógica na prática, considere um circuito de aviso para um botão de pressão. Muitas vezes, o sistema precisa disparar um sinal justamente quando o botão <strong>não</strong> está sendo pressionado (como uma trava de segurança que deve estar ativa enquanto o operador não interage com a máquina). Podemos modelar esse sistema usando variáveis booleanas:</p><ul><li><strong>Entrada A:</strong> O botão está sendo pressionado? (0 para Não, 1 para Sim)</li><li><strong>Saída x:</strong> Estado de "Não pressionado"? (0 para Falso, 1 para Verdadeiro)</li></ul><p>Nesse cenário, a saída ($x$) será o inverso da entrada $A$. Na álgebra booleana, representamos essa operação através de uma barra sobre o nome da variável ($\bar{A}$) ou, ocasionalmente, por um apóstrofo ($A'$). A expressão matemática que define esse comportamento é: $$ x = \bar{A} \quad \text{ou} \quad x = A' $$</p><p>Dizer que $x = \bar{A}$ significa que $x$ é o complemento de $A$. Se o valor de entrada é 0, o resultado é 1; se a entrada é 1, o resultado é 0.</p><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Regra de Ouro Na lógica NOT, a operação produz:</span></div><div class=callout-content><p>$$\bar{0} = 1 \quad \text{e} \quad \bar{1} = 0$$ Isso ocorre porque o inversor sempre fornece em sua saída o <strong>nível lógico oposto</strong> ao que foi aplicado em sua entrada.</p></div></div><p>Diferente das operações anteriores, a operação NOT não é "escalável" no sentido de adicionar mais entradas a uma mesma porta; cada inversão requer seu próprio circuito dedicado. Para facilitar a leitura, a expressão $x = \bar{A}$ é lida como "<strong>x é igual a A negado</strong>" ou "<strong>x é o inverso de A</strong>".</p><p>Abaixo, observamos a representação da operação NOT, demonstrando sua tabela-verdade simplificada ao lado do símbolo da porta lógica (Inversor). Note que a presença do pequeno círculo no símbolo é o que denota formalmente a inversão.</p><div class=col2><div><p>$$ \begin{array}{c||c} A & x = \bar{A} \\ \hline 0 & 1 \\ 1 & 0 \end{array} $$</p></div><div><div class=no-break><div class=centered><svg viewbox="0 0 105.108 45.36" class=svg-graph version=1.1 width=150 xmlns=http://www.w3.org/2000/svg xmlns:dc=http://purl.org/dc/elements/1.1/ xmlns:ns2=http://creativecommons.org/ns# xmlns:rdf=http://www.w3.org/1999/02/22-rdf-syntax-ns#><metadata><rdf:rdf><ns2:work><dc:type rdf:resource=http://purl.org/dc/dcmitype/StillImage /><dc:date>2026-02-12T17:56:37.420350</dc:date><dc:format>image/svg+xml</dc:format><dc:creator><ns2:agent><dc:title>Matplotlib v3.10.8, https://matplotlib.org/</dc:title></ns2:agent></dc:creator></ns2:work></rdf:rdf></metadata><defs><style type=text/css>*{stroke-linejoin:round;stroke-linecap:butt}</style></defs><g id=figure_1><g id=patch_1><path d="M 0 45.36 L 105.108 45.36 L 105.108 0 L 0 0 L 0 45.36 z" style=fill:none /></g><g id=axes_1><g id=patch_2><path d="M 65.388 27 C 66.533677 27 67.632585 26.544818 68.442701 25.734701 C 69.252818 24.924585 69.708 23.825677 69.708 22.68 C 69.708 21.534323 69.252818 20.435415 68.442701 19.625299 C 67.632585 18.815182 66.533677 18.36 65.388 18.36 C 64.242323 18.36 63.143415 18.815182 62.333299 19.625299 C 61.523182 20.435415 61.068 21.534323 61.068 22.68 C 61.068 23.825677 61.523182 24.924585 62.333299 25.734701 C 63.143415 26.544818 64.242323 27 65.388 27 L 65.388 27 z" clip-path=url(#pb863c5795b) style=fill:none;stroke:#333;stroke-width:2px;stroke-linejoin:miter /></g><g id=line2d_1><path d="M 17.688 22.68 L 37.668 22.68 M 69.708 22.68 L 89.688 22.68" clip-path=url(#pb863c5795b) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=line2d_2><path d="M 37.668 4.68 L 61.068 22.68 L 37.668 40.68 L 37.668 4.68" clip-path=url(#pb863c5795b) style=fill:none;stroke:#333;stroke-width:2px;stroke-linecap:round /></g><g id=text_1><text style="text-anchor:start;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 93.288 26.543125)" x=93.288 y=26.543125>x</text></g><g id=text_2><text style="text-anchor:end;fill:#333;font-family:DejaVu Sans,Bitstream Vera Sans,Computer Modern Sans Serif,Lucida Grande,Verdana,Geneva,Lucid,Arial,Helvetica,Avant Garde,sans-serif;font-size:14px" transform="rotate(-0 14.088 26.543125)" x=14.088 y=26.543125>A</text></g></g></g><defs><clippath id=pb863c5795b><rect height=45.36 width=105.108 x=0 y=0 /></clippath></defs></svg></div></div> $$ x = \bar{A} $$</div></div><p>Um detalhe importante para a análise de circuitos complexos é o efeito de forma de onda: o inversor complementa o sinal em todos os pontos. Se o sinal de entrada for uma sequência de pulsos, a saída será exatamente o "espelho" desses pulsos. Essa característica é essencial para converter lógicas "Ativas em Alto" para "Ativas em Baixo" conforme a necessidade do hardware.</p><h3 id=resumo-das-operações-booleanas><span class=heading-text>Resumo das Operações Booleanas</span><span class=heading-arabic>6.4.4</span></h3><table><thead><tr><th style=text-align:left>Operação</th><th style=text-align:left>Expressão</th><th style=text-align:left>Regra Fundamental</th></tr></thead><tbody><tr><td style=text-align:left><strong>OR</strong></td><td style=text-align:left>$x = A + B$</td><td style=text-align:left>Saída 1 se qualquer entrada for 1</td></tr><tr><td style=text-align:left><strong>AND</strong></td><td style=text-align:left>$x = AB$</td><td style=text-align:left>Saída 1 somente se todas forem 1</td></tr><tr><td style=text-align:left><strong>NOT</strong></td><td style=text-align:left>$x = \bar{A}$</td><td style=text-align:left>Saída é sempre o oposto da entrada</td></tr></tbody></table><h2 id=questões><span class=heading-text>Questões</span><span class=heading-arabic>6.5</span></h2><ol><li><p>Com base na física dos circuitos digitais e na álgebra booleana, refute a ideia de que uma porta OR com 10 entradas em nível lógico 1 geraria uma saída "maior" que 1.<br><br></p></li><li><p>Considere um componente digital cuja tabela-verdade completa ocupa <strong>64 linhas</strong>.</p></li></ol><ul><li>a) Calcule o número exato de variáveis de entrada desse sistema.</li><li>b) Explique por que a tabela-verdade é considerada uma ferramenta inviável para analisar circuitos com grande número de entradas (ex: 32 bits).<br><br></li></ul><ol start=3><li><p>No circuito de iluminação do forno descrito no texto ($x = A + B$), suponha que a porta <strong>OR</strong> foi substituída fisicamente por uma porta <strong>AND</strong>. Descreva o impacto funcional para o usuário, indicando qual é a <strong>única</strong> combinação de entradas que fará a lâmpada acender nesse novo cenário.<br><br></p></li><li><p>Ao aplicar um sinal de <em>clock</em> (pulsos alternados 0 e 1) na entrada de uma porta <strong>NOT</strong>, o que ocorre com a forma de onda na saída em relação à entrada? Desenhe a forma de onda para 3 ciclos de clock (3 sinais degrau) demonstrando a relação entrada/saída.<br><br></p></li><li><p>Compare a tabela-verdade da porta <strong>OR</strong> convencional com a do problema resolvido (lógica <strong>XOR</strong>). Analise especificamente o caso onde as entradas são $A=1$ e $B=1$: explique por que a saída diverge entre as duas lógicas e qual o conceito que difere o "OU" booleano do "OU" exclusivo.<br><br></p></li><li><p>Dada a expressão lógica de saída $S = (A + B) \cdot C$:</p></li></ol><ul><li>a) Descreva a condição lógica necessária para $S=1$ em linguagem natural.</li><li>b) O sistema será acionado se tivermos $A=1$ e $B=1$, mas $C=0$? Justifique sua resposta.<br><br></li></ul><h2 id=próximos-passos><span class=heading-text>Próximos passos</span><span class=heading-arabic>6.6</span></h2><p>No próximo capítulo, <a href=7-building-circuits-from-expressions.html>Algebra para Circuitos</a>, você começará a compreender como podemos transformar expressões booleanas para circuitos digitais, compreendendo, o grande benefício desse formato de expressão.</p></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/aulas-faesa/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Sistemas Digitais e Microprocessados`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>