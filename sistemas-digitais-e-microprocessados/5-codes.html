<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Sistemas Digitais e Microprocessados</title><link media="(prefers-color-scheme: light)" href=/aulas-faesa/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/aulas-faesa/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/aulas-faesa/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Sistemas Digitais e Microprocessados</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#introdução>5.1. Introdução</a></li><li class="toc-item level-2"><a href=#código-bcd>5.2. Código BCD</a></li><li class="toc-item level-2"><a href=#código-gray>5.3. Código Gray</a></li><li class="toc-item level-2"><a href=#relações-entre-as-representações-numéricas>5.4. Relações entre as representações numéricas</a></li><li class="toc-item level-2"><a href=#códigos-alfanuméricos>5.5. Códigos Alfanuméricos</a></li><li class="toc-item level-3"><a href=#código-ascii>5.5.1. Código ASCII</a></li><li class="toc-item level-2"><a href=#bytes-nibbles-e-palavras>5.6. Bytes, Nibbles e Palavras</a></li><li class="toc-item level-2"><a href=#questões>5.7. Questões</a></li><li class="toc-item level-2"><a href=#próximos-passos>5.8. Próximos passos</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=4-conversion-between-systems.html><i class=nav-icon data-lucide=chevron-left></i> Conversão entre Bases</a><a class="sidebar-nav-link next" href=6-truth-tables-and-logic-gates.html>Tabela-verdade e Portas Lógicas <i class=nav-icon data-lucide=chevron-right></i></a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>5</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>Códigos</span> <span class="title-ornament right">❧</span></h1><p class=article-date>23/02/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Sistemas Digitais e Microprocessados</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-II>II - Sistemas Numéricos</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>Códigos</span></nav></header><div class=article-body><h2 id=introdução><span class=heading-text>Introdução</span><span class=heading-arabic>5.1</span></h2><p>Nesta aula, exploraremos como podemos codificar informações de formas variadas. É importante que você note que, embora estejamos manipulando números, não estamos tratando de sistemas de numeração propriamente ditos, ainda que alguns possam ser interpretados dessa forma. Na verdade, lidamos com sistemas que codificam um número em outro formato, funcionando de maneira semelhante a uma cifra de criptografia, com o objetivo de obter benefícios específicos conforme o propósito do sistema de codificação escolhido.</p><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Utilidade</span></div><div class=callout-content><p>Esses códigos podem não parecer tão úteis à primeira vista, entretanto, você os utilizará ao longo da disciplina, mesmo que de forma pontual. O código BCD é amplamente utilizado para projetar displays numéricos em hardware, enquanto o código de Gray será fundamental na etapa de minimização de circuitos por meio do mapa de Karnaugh.</p></div></div><h2 id=código-bcd><span class=heading-text>Código BCD</span><span class=heading-arabic>5.2</span></h2><p>Denominamos como código qualquer representação de números, letras ou palavras por meio de um grupo especial de símbolos. Provavelmente, o exemplo mais familiar para você seja o código Morse, no qual uma série de pontos e traços representa as letras do alfabeto. Até este ponto, vimos que é possível representar qualquer decimal por um binário equivalente, o que nos permite imaginar o sistema de numeração convencional como uma codificação em binário puro. Desse modo, embora todos os sistemas digitais utilizem a numeração binária em suas operações internas, o mundo externo permanece naturalmente decimal. Isso significa que, em certas ocasiões, você desejará converter valores de binário para decimal com facilidade e, por esse motivo, uma maneira de codificar números decimais que combine características dos dois sistemas é empregada em situações determinadas.</p><p>Utilizamos o termo Decimais Codificados em Binário, do inglês BCD (Binary-Coded-Decimal), quando cada dígito de um número decimal é representado individualmente pelo seu equivalente em binário. Como um dígito decimal pode assumir no máximo o valor 9, são necessários 4 bits para codificar cada um deles, visto que o código binário do 9 é $1001_2$. Observe os dois exemplos abaixo para visualizar essa conversão:</p><div class=col2><div style="border-right:1px solid #333;padding-right:25px">$$ \begin{array}{ccc l} 8 & 7 & 4 & \text{(decimal)} \\ \downarrow & \downarrow & \downarrow & \\ 1000 & 0111 & 0100 & \text{(BCD)} \end{array} $$</div><div style=padding-left:25px>$$ \begin{array}{ccc l} 9 & 4 & 3 & \text{(decimal)} \\ \downarrow & \downarrow & \downarrow & \\ 1001 & 0100 & 0011 & \text{(BCD)} \end{array} $$</div></div><p><img alt="Processo de conversão BCD mostrando dígitos decimais mapeados para grupos binários de 4 bits" src=static/bcd_conversion.png></p><p>Perceba que cada dígito é convertido estritamente no seu equivalente binário puro e que são sempre utilizados 4 bits para cada posição decimal. Entretanto, é fundamental notar que o BCD utiliza apenas as combinações de $0000_2$ até $1001_2$ para representar cada dígito, deixando de usar as representações maiores que esta última. Em outras palavras, apenas 10 dos 16 valores possíveis para o grupo de 4 bits são válidos. Caso um desses números proibidos apareça em um sistema, isso normalmente indica a ocorrência de algum erro de processamento. Como o BCD se baseia nesta conversão direta, o processo de retornar do código BCD para o decimal é extremamente simples, consistindo no procedimento inverso em que você deve agrupar os bits de 4 em 4 e transformar cada grupo em seu respectivo número decimal.</p><hr><p><strong>Problema:</strong> Converta $0110100000111001$ (BCD) em seu equivalente decimal.</p><p>$$ \underbrace{0110}_{6} \quad \underbrace{1000}_{8} \quad \underbrace{0011}_{3} \quad \underbrace{1001}_{9} $$</p><p>Como você pode observar, realizamos agrupamentos de 4 bits. No código BCD, essa tarefa é simplificada, pois, como cada dígito foi convertido originalmente para 4 bits, o número resultante sempre apresentará um múltiplo de 4 bits.</p><hr><div class="callout callout-danger"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1=12 x2=12 y1=9 y2=13 /><line x1=12 x2=12 y1=17 y2=17.01 /></svg></span><span class=callout-title-inner>BCD não é um sistema de numeração!</span></div><div class=callout-content><p>É importante que você perceba que o BCD não é outro sistema de numeração como o binário, o decimal ou o hexadecimal. O BCD é, na realidade, o próprio sistema decimal no qual cada dígito individual é codificado em seu equivalente binário, o que torna o número BCD diferente do binário puro.</p></div></div><p>O código binário puro é obtido a partir do número decimal completo, enquanto no código BCD cada dígito decimal é convertido de forma isolada. Para ilustrar essa diferença, veja o exemplo do número 137 comparando as duas representações:</p><p>$$ \begin{aligned} 137_{10} &= 10001001_2 && \text{(binário)} \\ 137_{10} &= 0001 \ 0011 \ 0111 && \text{(BCD)} \end{aligned} $$</p><p>Note que o código BCD requer 12 bits, enquanto o binário puro exige apenas 8 bits para representar o mesmo valor. Embora isso possa parecer ineficiente em termos de armazenamento, a principal vantagem desta representação é a relativa facilidade de conversão. Apenas os grupos de 4 bits dos dígitos de 0 a 9 precisam ser memorizados por você ou pelo sistema. Essa característica é especialmente valiosa do ponto de vista do hardware, pois simplifica os circuitos lógicos que realizam as conversões mútuas.</p><h2 id=código-gray><span class=heading-text>Código Gray</span><span class=heading-arabic>5.3</span></h2><p>Alguns sistemas digitais operam em altas velocidades, como ocorre em máquinas rotativas no controle de posição de um disco rígido. Essas máquinas reagem a variações bruscas nas entradas digitais e, caso várias condições de entrada variem ao mesmo tempo, o sinal pode ser interpretado incorretamente pelo hardware. Para minimizar esse problema, o código de Gray busca representar os números de forma que, quando colocados em sequência numérica, dois valores adjacentes difiram em apenas um bit. Para compreender melhor essa necessidade, tome como exemplo o número $3_{10}$ escrito com 4 bits, que seria $0011_2$. Ao incrementarmos para $4_{10}$, obteríamos $0100_2$. Observe que, nesse caso, mudamos três bits simultaneamente, o que pode causar instabilidades. A tabela abaixo demonstra a transição entre valores binários de três bits e o respectivo código de Gray.</p><p>$$ \begin{array}{ccc|ccc} \mathbf{B_2} & \mathbf{B_1} & \mathbf{B_0} & \mathbf{G_2} & \mathbf{G_1} & \mathbf{G_0} \\ \hline 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 1 \\ 0 & 1 & 0 & 0 & 1 & 1 \\ 0 & 1 & 1 & 0 & 1 & 0 \\ 1 & 0 & 0 & 1 & 1 & 0 \\ 1 & 0 & 1 & 1 & 1 & 1 \\ 1 & 1 & 0 & 1 & 0 & 1 \\ 1 & 1 & 1 & 1 & 0 & 0 \end{array} $$</p><p><img alt="Disco codificador em código Gray mostrando a aplicação física de transições de bit único" src=static/gray_encoder.png></p><p>Assim como no caso do BCD, o código de Gray é apenas uma abstração do número binário e não um sistema de numeração independente. O que fazemos é realizar a contagem em binário e converter cada número para seu equivalente no código Gray. Para converter binário em Gray, você deve começar com o bit mais significativo (MSB) e utilizá-lo como o primeiro bit Gray. Em seguida, compare o binário MSB com o próximo bit binário ($B_1$). Se eles forem iguais, o resultado $G_1$ será 0, mas se forem diferentes, $G_1$ será 1. O processo continua comparando $B_1$ com $B_0$ para encontrar $G_0$. A imagem abaixo resume este fluxo de conversão.</p><p><img alt="Convertendo (a) binário (encode) em Gray e (b) Gray em binário." src=static/tab_2_2.png></p><p>Você pode notar que o MSB em Gray é sempre igual ao MSB em binário. De fato, o processo descrito trata-se de uma operação XOR com o próprio número deslocado. Ou seja, se você tomar um número $B$ qualquer em binário, poderá obter seu equivalente em Gray por meio da fórmula $G = B \oplus (B \gg 1)$. Uma forma prática de descrever isso seria deslocar o valor um bit para a direita, posicioná-lo abaixo do original e realizar um XOR bit a bit, lembrando que, se os bits forem iguais, o resultado será 0 e, se forem diferentes, será 1.</p><hr><p><strong>Problema</strong>: Converta o binário $1011_2$ para o código Gray.</p><p>$$ \begin{array}{r cccc l} & 1 & 0 & 1 & 1 & \text{(Binário original)} \\ \oplus & 0 & 1 & 0 & 1 & \text{(Deslocado p/ direita)} \\ \hline & 1 & 1 & 1 & 0 & \text{(Código Gray)} \end{array}$$</p><p>Ao deslocarmos o número um bit para a direita, perdemos o último bit original e acrescentamos um zero à esquerda para manter a quantidade de bits, permitindo o XOR conforme demonstrado.</p><h2 id=relações-entre-as-representações-numéricas><span class=heading-text>Relações entre as representações numéricas</span><span class=heading-arabic>5.4</span></h2><p>A tabela abaixo apresenta a representação dos números decimais de 1 a 15 nos sistemas binário, hexadecimal e nos códigos BCD e Gray. É importante que você observe, especialmente, como a representação BCD mantém rigorosamente o uso de 4 bits para cada dígito decimal individual.</p><p><img alt="Representação dos números decimais em diferentes códigos." src=static/tabela_codigos_bin_dec.png></p><h2 id=códigos-alfanuméricos><span class=heading-text>Códigos Alfanuméricos</span><span class=heading-arabic>5.5</span></h2><p>Além de dados puramente numéricos, um computador precisa ser capaz de manipular informações de texto. Isso significa que ele deve reconhecer códigos que representem as letras do alfabeto, sinais de pontuação e caracteres especiais. Esses sistemas são conhecidos como códigos alfanuméricos. Um código completo desse tipo inclui 26 letras minúsculas, 26 maiúsculas, 10 dígitos numéricos e diversos sinais de pontuação e símbolos como <code>+</code>, <code>/</code>, <code>#</code>, entre outros, representando basicamente tudo o que você encontra em um teclado.</p><h3 id=código-ascii><span class=heading-text>Código ASCII</span><span class=heading-arabic>5.5.1</span></h3><p>O padrão mais utilizado mundialmente é o Código Padrão Americano para Troca de Informações (ASCII). Ele utiliza 7 bits, o que resulta em $2^7 = 128$ representações possíveis, quantidade suficiente para abranger todos os caracteres padrão e funções de controle como o <code>RETURN</code> e o <code>LINEFEED</code>. A tabela a seguir mostra parte desse código com seus equivalentes em hexadecimal e decimal.</p><p><img alt="Códigos ASCII padrão." src=static/tabela_ascii.png></p><p>O computador utiliza o código ASCII tanto para armazenar informações digitadas quanto para transferir dados para dispositivos externos como impressoras. Veja como você pode aplicar isso em um exemplo prático.</p><hr><p><strong>Problema</strong>: Codifique, em ASCII, a seguinte mensagem, com aspas não inclusas, usando a representação hexadecimal: <em><strong>"COST = <span>$</span>72."</strong></em></p><p>A codificação de cada caractere resulta na seguinte tabela:</p><table><thead><tr><th style=text-align:left>Caractere</th><th style=text-align:left>Código ASCII (hex)</th></tr></thead><tbody><tr><td style=text-align:left>C</td><td style=text-align:left>43</td></tr><tr><td style=text-align:left>O</td><td style=text-align:left>4F</td></tr><tr><td style=text-align:left>S</td><td style=text-align:left>53</td></tr><tr><td style=text-align:left>T</td><td style=text-align:left>54</td></tr><tr><td style=text-align:left>espaço</td><td style=text-align:left>20</td></tr><tr><td style=text-align:left>=</td><td style=text-align:left>3D</td></tr><tr><td style=text-align:left>espaço</td><td style=text-align:left>20</td></tr><tr><td style=text-align:left><span>$</span></td><td style=text-align:left>24</td></tr><tr><td style=text-align:left>7</td><td style=text-align:left>37</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left>32</td></tr></tbody></table><p>Dessa forma, a mensagem final em hexadecimal é representada pela sequência $43\ 4F\ 53\ 54\ 20\ 3D\ 20\ 24\ 37\ 32$.</p><h2 id=bytes-nibbles-e-palavras><span class=heading-text>Bytes, Nibbles e Palavras</span><span class=heading-arabic>5.6</span></h2><p>A maioria dos microcomputadores armazena informações em grupos de 8 bits, recebendo o nome especial de byte. Um byte pode representar qualquer tipo de dado e é a unidade fundamental de medida na computação. Se você tiver uma sequência de 32 bits, por exemplo, terá exatamente 4 bytes. Da mesma forma, para representar o número decimal 846.569 em BCD, você precisaria de 24 bits, o que equivale a 3 bytes, já que cada um dos seis dígitos consome 4 bits.</p><p>Frequentemente, dividimos os números binários em grupos menores de 4 bits, conhecidos como nibbles. Este termo surgiu nos primórdios da computação como uma brincadeira com a palavra byte (mordida), significando uma "mordidinha". Assim, um byte é composto por exatamente dois nibbles. Se você analisar o binário $1001 0101$, o nibble menos significativo é o $0101$, que equivale ao valor decimal 5.</p><p>Finalmente, temos o conceito de palavra (word), que representa a unidade natural de informação com a qual um sistema digital opera. O tamanho da palavra depende da arquitetura do hardware. Enquanto um computador de um forno de micro-ondas pode operar com palavras de 8 bits (um byte), o seu computador pessoal provavelmente lida com palavras de 64 bits (8 bytes) por vez.</p><h2 id=questões><span class=heading-text>Questões</span><span class=heading-arabic>5.7</span></h2><ol><li><p>Converta os seguintes números decimais para o código BCD:</p> <p>(a) 35;</p> <p>(b) 908;</p> <p>(c) 1472.</p></li></ol><br><ol start=2><li><p>Transforme as seguintes sequências em BCD para seus equivalentes decimais: (a) $1000 \ 0010$;</p> <p>(b) $0111 \ 0101 \ 0100$;</p> <p>(c) $0001 \ 0110 \ 0011 \ 1001$.</p> <br></li><li><p>Identifique quais das seguintes sequências de 4 bits são inválidas no código BCD e explique o motivo: $0101$, $1100$, $1001$, $1011$.</p></li></ol><br><ol start=4><li><p>Converta os seguintes números binários puros para o código Gray:</p> <p>(a) $1010_2$;</p> <p>(b) $1111_2$</p> <p>(c) $01101_2$.</p></li></ol><br><ol start=5><li><p>Realize a conversão inversa (Gray para Binário) dos seguintes códigos:</p> <p>(a) $1100_G$;</p> <p>(b) $1011_G$;</p> <p>(c) $1110_G$.</p></li></ol><br><ol start=6><li>Explique o passo a passo da conversão do binário $1001_2$ para Gray, utilizando o método da operação XOR.</li></ol><br><ol start=7><li>Codifique a palavra "Hardware" para o formato ASCII utilizando a representação hexadecimal.<br><br></li><li>Decodifique a seguinte sequência ASCII hexadecimal para texto: $44\ 69\ 67\ 69\ 74\ 61\ 6c$.<br><br></li><li>Determine quantos bytes e quantos nibbles são necessários para representar o número decimal $52931$ no formato BCD.</li></ol><br><ol start=10><li>Explique por que o código BCD é considerado menos eficiente em termos de espaço de memória do que o binário puro e cite uma vantagem que justifique o seu uso em sistemas de hardware.<br><br></li><li>Qual é a característica fundamental do código Gray que o torna ideal para sensores de posição em eixos rotativos e como essa característica evita erros de leitura?<br><br></li><li>Diferencie o conceito de Byte, Nibble e Palavra, explicando como o tamanho da Palavra pode variar entre diferentes arquiteturas de computadores.</li></ol><h2 id=próximos-passos><span class=heading-text>Próximos passos</span><span class=heading-arabic>5.8</span></h2><p>No próximo capítulo, <a href=6-truth-tables-and-logic-gates.html>Tabela-verdade e Portas Lógicas</a>, você estudará os conceitos introdutórios sobre as principais portas lógicas e aprenderá diferentes formas de descrever e analisar o funcionamento dos circuitos digitais, incluindo o uso de tabelas-verdade e uma introdução às expressões da álgebra booleana.</p></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/aulas-faesa/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Sistemas Digitais e Microprocessados`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>