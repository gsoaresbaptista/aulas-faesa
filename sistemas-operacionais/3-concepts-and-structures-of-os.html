<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Sistemas Operacionais</title><link media="(prefers-color-scheme: light)" href=/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Sistemas Operacionais</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#introdução>3.1. Introdução</a></li><li class="toc-item level-3"><a href=#sistemas-operacionais-de-computadores-de-grande-porte>3.1.1. Sistemas operacionais de computadores de grande porte</a></li><li class="toc-item level-3"><a href=#sistemas-operacionais-de-computadores-pessoais>3.1.2. Sistemas operacionais de computadores pessoais</a></li><li class="toc-item level-3"><a href=#sistemas-operacionais-de-tempo-real>3.1.3. Sistemas operacionais de tempo real</a></li><li class="toc-item level-2"><a href=#conceitos-de-sistemas-operacionais>3.2. Conceitos de sistemas operacionais</a></li><li class="toc-item level-3"><a href=#processos>3.2.1. Processos</a></li><li class="toc-item level-3"><a href=#espaços-de-endereçamento>3.2.2. Espaços de endereçamento</a></li><li class="toc-item level-3"><a href=#arquivos>3.2.3. Arquivos</a></li><li class="toc-item level-3"><a href=#entradasaída>3.2.4. Entrada/Saída</a></li><li class="toc-item level-3"><a href=#proteção>3.2.5. Proteção</a></li><li class="toc-item level-3"><a href=#o-interpretador-de-comandos-shell>3.2.6. O interpretador de comandos (shell)</a></li><li class="toc-item level-2"><a href=#chamadas-de-sistema>3.3. Chamadas de sistema</a></li><li class="toc-item level-3"><a href=#chamadas-de-sistema-para-gerenciamento-de-processos>3.3.1. Chamadas de sistema para gerenciamento de processos</a></li><li class="toc-item level-3"><a href=#chamadas-de-sistema-para-gerenciamento-de-arquivos>3.3.2. Chamadas de sistema para gerenciamento de arquivos</a></li><li class="toc-item level-3"><a href=#chamadas-de-sistema-para-gerenciamento-de-diretórios>3.3.3. Chamadas de sistema para gerenciamento de diretórios</a></li><li class="toc-item level-3"><a href=#chamadas-de-sistema-diversas>3.3.4. Chamadas de sistema diversas</a></li><li class="toc-item level-2"><a href=#estrutura-de-sistemas-operacionais>3.4. Estrutura de sistemas operacionais</a></li><li class="toc-item level-3"><a href=#sistemas-monolíticos>3.4.1. Sistemas monolíticos</a></li><li class="toc-item level-3"><a href=#sistemas-de-camadas>3.4.2. Sistemas de camadas</a></li><li class="toc-item level-3"><a href=#micronúcleos>3.4.3. Micronúcleos</a></li><li class="toc-item level-3"><a href=#o-modelo-cliente-servidor>3.4.4. O modelo cliente-servidor</a></li><li class="toc-item level-3"><a href=#máquinas-virtuais>3.4.5. Máquinas virtuais</a></li><li class="toc-item level-4"><a href=#vm370>3.4.5.1. VM/370</a></li><li class="toc-item level-4"><a href=#máquinas-virtuais-redescobertas>3.4.5.2. Máquinas virtuais redescobertas</a></li><li class="toc-item level-4"><a href=#a-máquina-virtual-java>3.4.5.3. A máquina virtual Java</a></li><li class="toc-item level-3"><a href=#exonúcleos>3.4.6. Exonúcleos</a></li><li class="toc-item level-2"><a href=#questões>3.5. Questões</a></li><li class="toc-item level-2"><a href=#próximos-passos>3.6. Próximos passos</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=2-what-is-an-os.html><i class=nav-icon data-lucide=chevron-left></i> O que é um sistema operacional?</a><a class="sidebar-nav-link next" href=4-processes-and-threads.html>Processos e Threads <i class=nav-icon data-lucide=chevron-right></i></a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>3</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>Conceitos e Estruturas de Sistemas Operacionais</span> <span class="title-ornament right">❧</span></h1><p class=article-date>07/02/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Sistemas Operacionais</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-I>I - Introdução</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>Conceitos e Estruturas de Sistemas Operacionais</span></nav></header><div class=article-body><h2 id=introdução><span class=heading-text>Introdução</span><span class=heading-arabic>3.1</span></h2><p>Os sistemas operacionais evoluíram drasticamente ao longo de mais de cinco décadas, resultando em uma linhagem tecnológica vasta e heterogênea, onde nem todos os modelos desenvolvidos alcançaram o mainstream, mas cada um contribuiu para o estado da arte atual. Esta seção analisa brevemente nove variantes fundamentais, desde arquiteturas robustas para mainframes até <em>microkernels</em> para dispositivos vestíveis, estabelecendo uma base conceitual que será revisitada e aprofundada em discussões futuras, permitindo uma compreensão clara de como o software de base se adapta a diferentes restrições de hardware e exigências de processamento.</p><h3 id=sistemas-operacionais-de-computadores-de-grande-porte><span class=heading-text>Sistemas operacionais de computadores de grande porte</span><span class=heading-arabic>3.1.1</span></h3><p>No topo da hierarquia de infraestrutura de TI encontram-se os sistemas operacionais projetados para computadores de grande porte, conhecidos como mainframes. Essas máquinas, ainda onipresentes em centros de processamento de dados de grandes corporações, diferenciam-se drasticamente dos computadores pessoais pela sua massiva capacidade de Entrada e Saída (E/S). É comum que um único mainframe gerencie milhares de discos e volumes de dados na escala de milhões de gigabytes, um desempenho essencial para sua atuação contemporânea como servidores sofisticados em comércio eletrônico de larga escala e transações entre empresas (B2B).</p><p>Esses sistemas são intensamente orientados para o processamento simultâneo de múltiplas tarefas e oferecem, geralmente, três modalidades de serviços fundamentais para operações críticas:</p><table><thead><tr><th style=text-align:left>Modalidade de Serviço</th><th style=text-align:left>Características e Aplicações</th></tr></thead><tbody><tr><td style=text-align:left><strong>Processamento em Lote (Batch)</strong></td><td style=text-align:left>Executa tarefas rotineiras de forma automática, sem a presença de um usuário interativo. Exemplos incluem o processamento de apólices de seguros ou a geração de relatórios de vendas.</td></tr><tr><td style=text-align:left><strong>Processamento de Transações</strong></td><td style=text-align:left>Gerencia um grande volume de pequenas requisições, lidando com centenas ou milhares de operações por segundo. É vital para compensação de cheques bancários ou sistemas de reservas aéreas.</td></tr><tr><td style=text-align:left><strong>Tempo Compartilhado (Timesharing)</strong></td><td style=text-align:left>Permite que múltiplos usuários remotos executem tarefas no computador simultaneamente, como na realização de consultas a um grande banco de dados centralizado.</td></tr></tbody></table><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Evolução e Tendências</span></div><div class=callout-content><p>Muitas vezes, esses sistemas operacionais executam todas as funções acima de maneira integrada. Um exemplo clássico é o OS/390, descendente do histórico OS/360. No entanto, observa-se uma transição gradual no mercado, onde esses sistemas proprietários estão sendo substituídos por variantes UNIX, com destaque para o Linux.</p></div></div><h3 id=sistemas-operacionais-de-computadores-pessoais><span class=heading-text>Sistemas operacionais de computadores pessoais</span><span class=heading-arabic>3.1.2</span></h3><p>A categoria de sistemas operacionais voltados para computadores pessoais representa a interface mais comum da tecnologia no cotidiano. Atualmente, todos os computadores modernos oferecem suporte nativo à multiprogramação, sendo capazes de carregar e gerenciar dezenas de programas simultaneamente logo no momento da inicialização.</p><p>O objetivo primordial desses sistemas é fornecer suporte robusto e intuitivo para um único usuário, facilitando a execução de tarefas essenciais como processamento de texto, edição de planilhas e navegação na internet. A onipresença desses softwares é tão marcante que, frequentemente, o público geral desconhece a existência de outros tipos de sistemas computacionais.</p><div class="callout callout-example"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><path d="M12 11V7"/><path d="M9 11l3 3 3-3"/></svg></span><span class=callout-title-inner>Principais Exemplos</span></div><div class=callout-content><p>A literatura técnica destaca os seguintes sistemas como representantes clássicos desta categoria:</p><ul><li><strong>Base Unix/BSD:</strong> Linux, FreeBSD e OS X (Apple).</li><li><strong>Base Windows:</strong> Windows 7 e Windows 8.</li></ul></div></div><h3 id=sistemas-operacionais-de-tempo-real><span class=heading-text>Sistemas operacionais de tempo real</span><span class=heading-arabic>3.1.3</span></h3><p>Os sistemas operacionais de tempo real definem-se fundamentalmente pelo tratamento do tempo como um parâmetro-chave, sendo essenciais em ambientes onde a precisão temporal dita o sucesso ou o fracasso da operação. Em contextos industriais, por exemplo, computadores monitoram processos de produção e controlam o maquinário com base em prazos rígidos. A sincronia é tão vital que, em uma linha de montagem automotiva, se um robô de soldagem atuar alguns milissegundos antes ou depois do momento programado, o produto será arruinado.</p><p>A classificação desses sistemas depende da tolerância a falhas temporais, dividindo-se em críticos e não críticos, conforme detalhado na tabela a seguir:</p><table><thead><tr><th style=text-align:left>Categoria</th><th style=text-align:left>Definição e Consequências</th><th style=text-align:left>Exemplos Típicos</th></tr></thead><tbody><tr><td style=text-align:left><strong>Tempo Real Crítico (Hard)</strong></td><td style=text-align:left>Exige garantias absolutas de que uma ação ocorrerá em um instante exato. O descumprimento de prazos pode causar danos permanentes ou falhas catastróficas.</td><td style=text-align:left>Controle de processos industriais, aviônica, sistemas militares.</td></tr><tr><td style=text-align:left><strong>Tempo Real Não Crítico (Soft)</strong></td><td style=text-align:left>A perda ocasional de um prazo, embora indesejável, é aceitável e não resulta em danos permanentes.</td><td style=text-align:left>Sistemas de multimídia, áudio digital, smartphones.</td></tr></tbody></table><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Arquitetura e Eficiência</span></div><div class=callout-content><p>Para garantir o cumprimento estrito de prazos nos sistemas críticos, o sistema operacional muitas vezes funciona apenas como uma biblioteca conectada diretamente aos programas aplicativos, como ocorre no sistema <strong>eCos</strong>. Nessa arquitetura, todas as partes do sistema estão estreitamente acopladas e sem proteção entre si, visando maximizar a velocidade de resposta.</p></div></div><p>Existe uma sobreposição funcional considerável entre as categorias de sistemas portáteis, embarcados e de tempo real, visto que quase todos possuem algum aspecto de temporalidade. Uma diferença marcante reside no público e na segurança: enquanto sistemas portáteis e embarcados focam no consumidor final, os de tempo real voltam-se para o uso industrial. Além disso, em sistemas de tempo real e embarcados, o usuário geralmente não tem permissão para adicionar softwares próprios, limitando-se aos programas inseridos pelos projetistas, o que facilita significativamente a proteção e a estabilidade do sistema.</p><h2 id=conceitos-de-sistemas-operacionais><span class=heading-text>Conceitos de sistemas operacionais</span><span class=heading-arabic>3.2</span></h2><p>A compreensão da arquitetura de sistemas operacionais exige o domínio de certas abstrações basilares fornecidas pelo software de sistema, sendo as mais críticas os processos, os espaços de endereçamento e os arquivos. Estas estruturas formam o vocabulário essencial para o gerenciamento de recursos e, embora utilizaremos exemplos práticos extraídos predominantemente do ambiente UNIX para ilustrar esses mecanismos, é crucial notar que implementações análogas sustentam o funcionamento da vasta maioria das plataformas computacionais modernas.</p><h3 id=processos><span class=heading-text>Processos</span><span class=heading-arabic>3.2.1</span></h3><p>O conceito de processo é a pedra angular de todos os sistemas operacionais, podendo ser definido essencialmente como um programa em execução. Todo processo funciona como um contêiner que agrupa as informações vitais para a sua operação, sendo composto por um <strong>espaço de endereçamento</strong> (uma faixa de memória que contém o programa executável, seus dados e a pilha) e um conjunto de <strong>recursos</strong> (registradores, contador de programa, ponteiro de pilha, lista de arquivos abertos e alarmes pendentes).</p><p>Para compreender intuitivamente essa dinâmica, basta observar um sistema de multiprogramação moderno. Um usuário pode, simultaneamente, renderizar um vídeo, navegar na web e receber e-mails em segundo plano. O sistema operacional alterna periodicamente entre esses processos ativos (editor de vídeo, navegador e cliente de e-mail), decidindo qual deles deve utilizar a CPU em determinado momento. Quando um processo é suspenso para dar lugar a outro, é imperativo que ele possa ser reiniciado posteriormente no exato estado em que parou.</p><div class="callout callout-info"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=10 /><path d="M12 16v-4"/><path d="M12 8h.01"/></svg></span><span class=callout-title-inner>A Tabela de Processos</span></div><div class=callout-content><p>Para viabilizar a alternância entre tarefas, o sistema armazena todas as informações do processo (exceto o conteúdo do espaço de endereçamento) em uma estrutura conhecida como <strong>Tabela de Processos</strong>. Cada entrada nessa tabela guarda o estado dos registradores, ponteiros de arquivos e outros dados críticos, garantindo que chamadas de leitura ou escrita continuem corretamente após a retomada. Assim, um processo suspenso consiste em sua <em>imagem do núcleo</em> (espaço de endereçamento) e sua entrada na tabela de processos.</p></div></div><p>As chamadas de sistema gerenciam o ciclo de vida desses processos, desde a criação até o término. Um exemplo clássico ocorre no <strong>shell</strong> (interpretador de comandos): quando um usuário solicita a compilação de um programa, o shell cria um novo processo filho para executar o compilador. Como processos podem criar outros processos recursivamente, forma-se uma hierarquia estrutural, conforme ilustrado abaixo:</p><img src=static/fig_1_13_arvore_processos.png width=50%><p>Além da criação e gerenciamento de memória, os processos precisam se comunicar e lidar com eventos assíncronos. Para isso, utilizam-se temporizadores e <strong>sinais</strong>, que são análogos em software às interrupções de hardware. Se um processo precisa retransmitir uma mensagem perdida na rede após um tempo limite, o sistema operacional envia um sinal de alarme, forçando o processo a pausar sua atividade atual, salvar seu estado e executar uma rotina de tratamento específica antes de retomar.</p><p>Por fim, a segurança e a propriedade dos processos são geridas através de identificadores atribuídos pelo administrador do sistema. A tabela a seguir resume as principais categorias de identificação e permissão:</p><table><thead><tr><th style=text-align:left>Identificador</th><th style=text-align:left>Sigla</th><th style=text-align:left>Descrição</th></tr></thead><tbody><tr><td style=text-align:left><strong>Identificação do Usuário</strong></td><td style=text-align:left>UID</td><td style=text-align:left>Atribuída a cada pessoa autorizada. Todo processo herda a UID de quem o iniciou (incluindo processos filhos).</td></tr><tr><td style=text-align:left><strong>Identificação do Grupo</strong></td><td style=text-align:left>GID</td><td style=text-align:left>Permite associar usuários a grupos específicos para gestão coletiva de permissões.</td></tr><tr><td style=text-align:left><strong>Superusuário / Administrador</strong></td><td style=text-align:left>Root</td><td style=text-align:left>Possui uma UID especial com poderes para sobrepor regras de proteção e acessar qualquer recurso do sistema.</td></tr></tbody></table><h3 id=espaços-de-endereçamento><span class=heading-text>Espaços de endereçamento</span><span class=heading-arabic>3.2.2</span></h3><p>A memória principal é um recurso fundamental em qualquer computador, sendo o local onde os programas em execução são armazenados. Em sistemas operacionais mais rudimentares, a gestão dessa memória é simples, permitindo a execução de apenas um programa por vez. Para que um segundo software seja executado, o primeiro deve ser removido, liberando o espaço físico para o próximo ocupante.</p><p>Contudo, os sistemas operacionais modernos e sofisticados suportam a multiprogramação, permitindo que múltiplos programas residam na memória simultaneamente. Essa convivência exige mecanismos de proteção robustos para evitar que um processo interfira nos dados de outro ou desestabilize o próprio sistema operacional. Embora a implementação dessa proteção ocorra no nível do hardware, seu controle e gerenciamento são responsabilidades exclusivas do sistema operacional.</p><p>A distinção entre a memória física e a abstração lógica é crucial, conforme detalhado na tabela a seguir:</p><table><thead><tr><th style=text-align:left>Conceito</th><th style=text-align:left>Definição</th></tr></thead><tbody><tr><td style=text-align:left><strong>Memória Principal (Física)</strong></td><td style=text-align:left>O hardware real disponível para armazenamento volátil de dados.</td></tr><tr><td style=text-align:left><strong>Espaço de Endereçamento</strong></td><td style=text-align:left>O conjunto de endereços lógicos que um processo pode utilizar, variando de 0 até um valor máximo definido.</td></tr></tbody></table><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>O Desafio da Escala</span></div><div class=callout-content><p>O gerenciamento torna-se complexo quando consideramos arquiteturas modernas de 32 ou 64 bits. Nesses casos, o espaço de endereçamento potencial chega a $2^{32}$ ou $2^{64}$ bytes, respectivamente. Frequentemente, esse espaço lógico excede a quantidade de memória física instalada na máquina.</p></div></div><p>Historicamente, essa discrepância impedia a execução de programas maiores que a memória física. Atualmente, solucionamos esse problema através da técnica de <strong>Memória Virtual</strong>. O sistema operacional mantém apenas parte do espaço de endereçamento na memória principal (RAM) e o restante no disco, realizando a troca (swapping) de trechos de dados conforme a necessidade do processamento.</p><div class="callout callout-success"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg></span><span class=callout-title-inner>A Solução da Memória Virtual</span></div><div class=callout-content><p>Na essência, o sistema operacional cria uma abstração onde o espaço de endereçamento é <strong>desacoplado</strong> da memória física. Isso permite que um programa utilize um espaço de memória maior do que o hardware fisicamente possui, delegando ao sistema a complexidade de gerenciar o fluxo de dados entre o disco e a RAM.</p></div></div><h3 id=arquivos><span class=heading-text>Arquivos</span><span class=heading-arabic>3.2.3</span></h3><p>Um conceito fundamental, suportado por virtualmente todos os sistemas operacionais, é o sistema de arquivos. Uma função primordial do sistema operacional consiste em ocultar as peculiaridades dos discos e outros dispositivos de E/S, apresentando ao programador um modelo agradável e claro de arquivos independentes do dispositivo. Para manipular esses arquivos, chamadas de sistema são necessárias para criar, remover, ler e escrever. Antes que um arquivo possa ser lido, ele deve ser localizado no disco e aberto; após a leitura, deve ser fechado.</p><p>Para fornecer um local para manter os arquivos, a maioria dos sistemas operacionais de computadores pessoais utiliza o conceito de <strong>diretório</strong> como uma forma de agrupamento. Um usuário pode ter diretórios distintos para cursos, correio eletrônico ou páginas da web. As chamadas de sistema permitem criar e remover diretórios, bem como adicionar ou excluir arquivos existentes dentro deles. Como as entradas de diretório podem ser arquivos ou outros diretórios, esse modelo dá origem a uma hierarquia, o sistema de arquivos, conforme ilustrado na figura a seguir:</p><img src=static/fig1_14_sistema_arquivos_departamento.png width=75%><p>Embora ambas as hierarquias (processos e arquivos) sejam organizadas como árvores, as semelhanças encerram-se nesse ponto. Existem diferenças estruturais e funcionais significativas entre elas, detalhadas na tabela abaixo:</p><table><thead><tr><th style=text-align:left>Característica</th><th style=text-align:left>Hierarquia de Processos</th><th style=text-align:left>Hierarquia de Arquivos</th></tr></thead><tbody><tr><td style=text-align:left><strong>Profundidade</strong></td><td style=text-align:left>Geralmente rasa (raramente excede 3 níveis).</td><td style=text-align:left>Profunda (frequentemente 4, 5 ou mais níveis).</td></tr><tr><td style=text-align:left><strong>Duração (Vida)</strong></td><td style=text-align:left>Curta (geralmente minutos).</td><td style=text-align:left>Longa (pode existir por anos).</td></tr><tr><td style=text-align:left><strong>Propriedade e Acesso</strong></td><td style=text-align:left>Controle restrito (geralmente pai-filho).</td><td style=text-align:left>Acesso amplo (mecanismos para grupos/usuários).</td></tr></tbody></table><p>Todo arquivo dentro de uma hierarquia de diretórios pode ser especificado fornecendo o seu <strong>nome de caminho</strong> (path) a partir do topo da hierarquia, o diretório-raiz. Esses nomes de caminho absolutos consistem na lista de diretórios que precisam ser percorridos a partir da raiz para se chegar ao arquivo, com barras separando os componentes. Por exemplo, o caminho <code>/Professores/Prof.Brown/Cursos/CS101</code> indica um caminho absoluto.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Convenção de Caminhos</span></div><div class=callout-content><p>No Windows, o caractere barra invertida (<code>\</code>) é usado como separador em vez da barra (<code>/</code>) por razões históricas. Assim, o caminho acima seria escrito como <code>\Professores\Prof.Brown\Cursos\CS101</code>. No entanto, no contexto acadêmico e neste texto, utiliza-se a convenção UNIX.</p></div></div><p>A todo instante, cada processo possui um <strong>diretório de trabalho atual</strong>. Nomes de caminhos que não começam com uma barra são procurados neste diretório relativo. Os processos podem alterar seu diretório de trabalho emitindo uma chamada de sistema específica. Antes que um arquivo possa ser lido ou escrito, ele precisa ser aberto, momento em que as permissões são verificadas. Se o acesso for permitido, o sistema retorna um pequeno valor inteiro, chamado <strong>descritor de arquivo</strong>, para uso em operações subsequentes.</p><p>Outro conceito crucial no UNIX é a <strong>montagem</strong> do sistema de arquivos. A chamada de sistema <code>mount</code> permite que o sistema de arquivos de uma mídia removível (como CD-ROMs ou USBs) seja agregado à árvore principal do sistema de arquivos-raiz. Isso resolve o problema de endereçamento de dispositivos externos sem criar dependência de nomes de dispositivos (como letras de unidade), integrando tudo em uma única hierarquia lógica.</p><img src=static/fig1_15_montagem_sistema_arquivos.png width=90%><p>Além disso, o UNIX implementa o conceito de <strong>arquivo especial</strong>, que permite que dispositivos de E/S sejam tratados como arquivos. Eles são divididos em duas categorias principais:</p><ul><li><strong>Arquivos especiais de bloco:</strong> Usados para modelar dispositivos que consistem em uma coleção de blocos endereçáveis aleatoriamente, como discos rígidos. Permitem acesso direto a blocos específicos.</li><li><strong>Arquivos especiais de caracteres:</strong> Usados para modelar dispositivos que operam com fluxo de caracteres, como impressoras e modems. Por convenção, esses arquivos são mantidos no diretório <code>/dev</code>.</li></ul><p>Por fim, um aspecto que relaciona processos e arquivos são os <strong>pipes</strong>. Um pipe é uma espécie de pseudoarquivo que conecta dois processos. Quando o processo A deseja enviar dados para o processo B, ele escreve no pipe como se fosse um arquivo de saída, e o processo B lê como se fosse um arquivo de entrada, conforme mostrado na figura abaixo:</p><img src=static/fig1_16_pipes_processos.png width=40%><p>A comunicação entre processos no UNIX assemelha-se muito à leitura e escrita de arquivos comuns. De fato, a única maneira de um processo descobrir se está escrevendo em um arquivo real ou em um pipe é através de uma chamada de sistema especial, o que demonstra a força da abstração de arquivos neste sistema operacional.</p><h3 id=entradasaída><span class=heading-text>Entrada/Saída</span><span class=heading-arabic>3.2.4</span></h3><p>Todos os computadores dependem essencialmente de dispositivos físicos para obter entradas e produzir saídas. A utilidade de um sistema computacional reside justamente na capacidade de o usuário instruir a máquina e receber os resultados do processamento. Existem diversos tipos de dispositivos de entrada e saída (E/S), como teclados, monitores e impressoras, cabendo ao sistema operacional a responsabilidade crítica de gerenciá-los.</p><p>Em consequência dessa necessidade, todo sistema operacional implementa um subsistema de E/S. A estrutura desse software pode ser dividida em duas categorias principais, baseadas na especificidade do hardware controlado:</p><table><thead><tr><th style=text-align:left>Categoria de Software</th><th style=text-align:left>Descrição e Função</th></tr></thead><tbody><tr><td style=text-align:left><strong>Independente do Dispositivo</strong></td><td style=text-align:left>Software genérico que se aplica igualmente bem a muitos ou a todos os dispositivos de E/S, padronizando a interface.</td></tr><tr><td style=text-align:left><strong>Específico do Dispositivo</strong></td><td style=text-align:left>Software dedicado, conhecido como <em>driver</em>, projetado para lidar com as particularidades de um hardware específico.</td></tr></tbody></table><h3 id=proteção><span class=heading-text>Proteção</span><span class=heading-arabic>3.2.5</span></h3><p>Os computadores modernos armazenam grandes volumes de informações que os usuários desejam manter confidenciais, incluindo e-mails, planos de negócios e declarações fiscais. Consequentemente, cabe ao sistema operacional gerenciar a segurança de forma que os recursos, como arquivos, sejam acessíveis apenas por usuários devidamente autorizados.</p><p>Para ilustrar o funcionamento da segurança, tomemos como exemplo o sistema UNIX. Neste ambiente, a proteção de arquivos é controlada por um código binário de 9 bits. Esse código é subdividido em três campos de 3 bits cada, atribuídos respectivamente ao <strong>proprietário</strong>, aos membros do <strong>grupo</strong> do proprietário (definidos pelo administrador do sistema) e aos <strong>demais usuários</strong>.</p><p>Cada campo é composto por três tipos de permissão, conforme detalhado na tabela a seguir:</p><table><thead><tr><th style=text-align:left>Símbolo</th><th style=text-align:left>Permissão</th><th style=text-align:left>Ação em Arquivos</th><th style=text-align:left>Ação em Diretórios</th></tr></thead><tbody><tr><td style=text-align:left><strong>r</strong></td><td style=text-align:left>Leitura (<em>Read</em>)</td><td style=text-align:left>Ler o conteúdo do arquivo.</td><td style=text-align:left>Listar o conteúdo do diretório.</td></tr><tr><td style=text-align:left><strong>w</strong></td><td style=text-align:left>Escrita (<em>Write</em>)</td><td style=text-align:left>Alterar ou salvar o arquivo.</td><td style=text-align:left>Criar/apagar arquivos no diretório.</td></tr><tr><td style=text-align:left><strong>x</strong></td><td style=text-align:left>Execução (<em>Execute</em>)</td><td style=text-align:left>Executar o arquivo como programa.</td><td style=text-align:left>Permissão de busca (entrar no diretório).</td></tr></tbody></table><p>A ausência de uma permissão é representada por um traço (<code>-</code>). Para compreender a aplicação prática desses bits, analise o exemplo abaixo:</p><div class="callout callout-example"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><path d="M12 11V7"/><path d="M9 11l3 3 3-3"/></svg></span><span class=callout-title-inner>Interpretação do código <code>rwxr-x--x</code></span></div><div class=callout-content><p>Este código de permissão deve ser lido em blocos de três:</p><ul><li><strong>Proprietário (<code>rwx</code>):</strong> Tem permissão total para ler, escrever e executar.</li><li><strong>Grupo (<code>r-x</code>):</strong> Pode ler e executar, mas <strong>não</strong> pode escrever (alterar) o arquivo.</li><li><strong>Outros (<code>--x</code>):</strong> Podem apenas executar o arquivo, sem permissão para ler seu conteúdo ou alterá-lo.</li></ul></div></div><p>Além da proteção de arquivos individuais, existem muitas outras questões críticas de segurança, como a proteção do sistema contra intrusos indesejados, sejam eles humanos ou softwares maliciosos como vírus.</p><h3 id=o-interpretador-de-comandos-shell><span class=heading-text>O interpretador de comandos (shell)</span><span class=heading-arabic>3.2.6</span></h3><p>O sistema operacional é, fundamentalmente, o código responsável pela execução das chamadas de sistema. É importante distinguir que editores, compiladores, montadores, ligadores e interpretadores de comandos não fazem parte do sistema operacional em si, embora sejam ferramentas essenciais. O interpretador de comandos, conhecido como <strong>shell</strong>, serve como a principal interface entre o usuário e o sistema (na ausência de uma interface gráfica), fazendo uso intensivo das chamadas de sistema. Exemplos populares incluem <code>sh</code>, <code>csh</code>, <code>ksh</code> e <code>bash</code>.</p><p>O funcionamento do shell segue um ciclo lógico: quando um usuário se conecta, o shell é iniciado e apresenta um <strong>prompt</strong> (como o cifrão <code>$</code>), indicando que aguarda um comando. Ao receber um comando, como <code>date</code>, o shell cria um processo filho e executa o programa solicitado. O shell aguarda o término desse processo filho antes de exibir o prompt novamente para a próxima instrução.</p><p>Uma das funcionalidades mais poderosas do shell é a capacidade de manipular a entrada e a saída de dados, redirecionando fluxos entre arquivos e processos. A tabela abaixo resume os principais operadores de redirecionamento e controle de fluxo:</p><table><thead><tr><th style=text-align:left>Operador</th><th style=text-align:center>Função</th><th style=text-align:left>Exemplo</th><th style=text-align:left>Descrição do Exemplo</th></tr></thead><tbody><tr><td style=text-align:left><code>></code></td><td style=text-align:center>Redirecionamento de Saída</td><td style=text-align:left><code>date >file</code></td><td style=text-align:left>Salva a saída do comando <code>date</code> no arquivo <code>file</code>.</td></tr><tr><td style=text-align:left><code>&lt;</code></td><td style=text-align:center>Redirecionamento de Entrada</td><td style=text-align:left><code>sort &lt;file1 >file2</code></td><td style=text-align:left>O comando <code>sort</code> recebe dados de <code>file1</code> e salva o resultado ordenado em <code>file2</code>.</td></tr><tr><td style=text-align:left><code>\|</code></td><td style=text-align:center>Pipe (Canalização)</td><td style=text-align:left><code>cat f1 f2 \| sort</code></td><td style=text-align:left>A saída do <code>cat</code> (concatenação) vira a entrada imediata do <code>sort</code>.</td></tr><tr><td style=text-align:left><code>&</code></td><td style=text-align:center>Execução em Background</td><td style=text-align:left><code>command &</code></td><td style=text-align:left>O shell não espera o comando terminar e libera o prompt imediatamente.</td></tr></tbody></table><p>Esses recursos permitem a construção de sequências complexas de processamento. Considere o exemplo abaixo, onde três arquivos são concatenados, ordenados alfabeticamente e enviados para a impressora, tudo em uma única linha de comando:</p><pre class="line-numbers language-bash" data-lang=BASH><code class=language-bash>cat file1 file2 file3 | sort >/dev/lp &
</code></pre><p>Neste caso específico, o símbolo <code>&</code> no final instrui o shell a executar toda a tarefa em segundo plano, permitindo que o usuário continue trabalhando enquanto o processamento ocorre.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Interfaces Gráficas (GUI)</span></div><div class=callout-content><p>A maioria dos computadores modernos utiliza uma Interface Gráfica de Usuário (GUI). É fundamental compreender que a GUI, seja o <strong>Gnome/KDE</strong> no Linux ou o <strong>Windows Explorer</strong> no Windows, é apenas um programa sendo executado sobre o sistema operacional, funcionando de maneira análoga a um shell visual. No Linux, isso é evidente pela possibilidade de alternar entre diferentes GUIs; no Windows, embora raro, também é possível substituir a interface padrão alterando registros do sistema.</p></div></div><h2 id=chamadas-de-sistema><span class=heading-text>Chamadas de sistema</span><span class=heading-arabic>3.3</span></h2><p>A interação entre os programas de usuários e o sistema operacional ocorre fundamentalmente através de abstrações. Embora o sistema operacional tenha a função de gerenciar recursos, para o usuário, a interface manifesta-se em operações como criar, ler e deletar arquivos. Para compreender verdadeiramente o funcionamento de um sistema operacional, é imperativo examinar essa interface de perto, especificamente através das <strong>chamadas de sistema</strong>. Embora variem de sistema para sistema, os conceitos subjacentes tendem a ser similares. Adotaremos aqui uma abordagem prática baseada no padrão <strong>POSIX</strong> (International Standard 9945-1), que fundamenta sistemas como UNIX, Linux, BSD e MINIX 3.</p><p>Uma chamada de sistema não é uma simples chamada de função. Como um computador de uma única CPU executa apenas uma instrução por vez, um processo em modo de usuário que necessita de um serviço do sistema (como ler um arquivo) deve executar uma instrução de armadilha, conhecida como <strong>TRAP</strong>. Essa instrução transfere o controle para o sistema operacional, alterando o estado da máquina de modo usuário para modo núcleo (kernel), permitindo a execução de operações privilegiadas.</p><p>Para ilustrar esse mecanismo complexo, analisaremos a chamada de sistema <code>read</code>. Esta função possui três parâmetros essenciais: o descritor do arquivo, um ponteiro para o buffer (onde os dados serão armazenados) e o número de bytes a serem lidos. Em um programa C, a chamada seria estruturada da seguinte forma:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>contador = read(fd, buffer, nbytes);
</code></pre><p>Se a chamada for bem-sucedida, a variável <code>contador</code> recebe o número de bytes lidos. Caso ocorra um erro (parâmetro inválido ou falha de disco), o retorno é -1 e o código do erro é armazenado na variável global <code>errno</code>.</p><p>A execução de uma chamada de sistema envolve uma sequência precisa de etapas. A figura abaixo detalha os 11 passos necessários para realizar a chamada <code>read</code>, desde a preparação na pilha até o retorno ao programa do usuário:</p><img src=static/fig1_17_passos_read.png width=75%><p>Acompanhe a descrição detalhada do fluxo apresentado na figura:</p><ol><li><strong>Empilhamento de Parâmetros (Passos 1-3):</strong> O programa chamador empilha os parâmetros. Compiladores C empilham na ordem inversa (nbytes, &buffer, fd) para facilitar o acesso ao primeiro parâmetro. Note que o buffer é passado por referência (endereço).</li><li><strong>Chamada da Biblioteca (Passo 4):</strong> A rotina de biblioteca <code>read</code> é invocada. Esta é uma chamada de função normal.</li><li><strong>Preparação do Registrador (Passo 5):</strong> A biblioteca coloca o número identificador da chamada de sistema em um registrador específico onde o SO espera encontrá-lo.</li><li><strong>Instrução TRAP (Passo 6):</strong> Executa-se a instrução TRAP. Aqui ocorre a mudança crítica do modo usuário para o modo núcleo e o salto para um endereço fixo no kernel.</li><li><strong>Despacho (Passo 7):</strong> O código do núcleo examina o número da chamada (no registrador) e usa uma tabela de ponteiros para despachar o controle ao tratador correto.</li><li><strong>Execução (Passo 8):</strong> O tratador da chamada de sistema executa a operação solicitada.</li><li><strong>Retorno ao Usuário (Passos 9-10):</strong> Após a conclusão, o controle retorna à rotina de biblioteca (logo após a instrução TRAP) e, em seguida, ao programa do usuário.</li><li><strong>Limpeza da Pilha (Passo 11):</strong> O programa do usuário incrementa o ponteiro da pilha para remover os parâmetros que foram empilhados, finalizando o processo.</li></ol><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>TRAP vs. Chamada de Rotina</span></div><div class=callout-content><p>A instrução TRAP difere de uma chamada de rotina comum em dois aspectos fundamentais:</p><ol><li><strong>Mudança de Modo:</strong> A TRAP altera o estado do processador de modo usuário para modo núcleo, algo que uma chamada comum (<code>CALL</code>) não faz.</li><li><strong>Endereçamento:</strong> A TRAP não salta para um endereço arbitrário, mas sim para locais fixos controlados pelo sistema (vetor de interrupção), garantindo segurança.</li></ol></div></div><p>É importante ressaltar que o sistema operacional pode bloquear o chamador no Passo 9. Se o programa tentar ler do teclado e não houver entrada, ele ficará suspenso. O SO então alocará a CPU para outro processo até que a entrada esteja disponível.</p><p>Por fim, vale notar que o mapeamento entre rotinas da biblioteca POSIX e chamadas de sistema reais não é necessariamente de um para um. O padrão POSIX define a API, mas não a implementação. Algumas funções da biblioteca podem ser executadas inteiramente no espaço do usuário por desempenho, enquanto outras podem agrupar várias funcionalidades em uma única chamada de sistema, dependendo da arquitetura do SO.</p><h3 id=chamadas-de-sistema-para-gerenciamento-de-processos><span class=heading-text>Chamadas de sistema para gerenciamento de processos</span><span class=heading-arabic>3.3.1</span></h3><p>O gerenciamento de processos constitui um dos pilares fundamentais dos sistemas operacionais, sendo operado através de um conjunto específico de chamadas de sistema. A chamada <strong>fork</strong> é a única maneira de criar um novo processo em sistemas compatíveis com POSIX. Ela cria uma cópia exata do processo original, duplicando descritores de arquivos e registradores. Após a execução do <code>fork</code>, o processo original (pai) e a cópia (filho) seguem caminhos distintos. Embora as variáveis tenham valores idênticos no momento da criação, os dados são copiados, de modo que alterações subsequentes em um não afetam o outro, exceto pelo segmento de texto do programa, que é inalterável e compartilhado. O valor de retorno da chamada <code>fork</code> permite distinguir os processos: retorna <strong>zero</strong> para o processo filho e o <strong>PID</strong> (Identificador de Processo) do filho para o processo pai.</p><p>Para facilitar a compreensão das principais chamadas de sistema POSIX, organizamos a tabela abaixo, que agrupa as funções por categoria de gerenciamento:</p><table><thead><tr><th style=text-align:left>Categoria</th><th style=text-align:left>Chamada de Sistema</th><th style=text-align:left>Descrição e Funcionalidade</th></tr></thead><tbody><tr><td style=text-align:left><strong>Processos</strong></td><td style=text-align:left><code>pid = fork()</code></td><td style=text-align:left>Cria um processo filho idêntico ao pai.</td></tr><tr><td style=text-align:left></td><td style=text-align:left><code>pid = waitpid(pid, &statloc, options)</code></td><td style=text-align:left>Aguarda a conclusão de um processo filho.</td></tr><tr><td style=text-align:left></td><td style=text-align:left><code>s = execve(name, argv, environp)</code></td><td style=text-align:left>Substitui a imagem do núcleo de um processo.</td></tr><tr><td style=text-align:left></td><td style=text-align:left><code>exit(status)</code></td><td style=text-align:left>Conclui a execução e devolve o status.</td></tr><tr><td style=text-align:left><strong>Arquivos</strong></td><td style=text-align:left><code>fd = open(file, how, ...)</code></td><td style=text-align:left>Abre arquivo para leitura, escrita ou ambos.</td></tr><tr><td style=text-align:left></td><td style=text-align:left><code>s = close(fd)</code></td><td style=text-align:left>Fecha um arquivo aberto.</td></tr><tr><td style=text-align:left></td><td style=text-align:left><code>n = read(fd, buffer, nbytes)</code></td><td style=text-align:left>Lê dados de um arquivo para um buffer.</td></tr><tr><td style=text-align:left></td><td style=text-align:left><code>n = write(fd, buffer, nbytes)</code></td><td style=text-align:left>Escreve dados de um buffer em um arquivo.</td></tr><tr><td style=text-align:left><strong>Diretórios</strong></td><td style=text-align:left><code>s = mkdir(name, mode)</code></td><td style=text-align:left>Cria um novo diretório.</td></tr><tr><td style=text-align:left></td><td style=text-align:left><code>s = mount(special, name, flag)</code></td><td style=text-align:left>Monta um sistema de arquivos.</td></tr><tr><td style=text-align:left><strong>Diversos</strong></td><td style=text-align:left><code>s = chdir(dirname)</code></td><td style=text-align:left>Altera o diretório de trabalho.</td></tr><tr><td style=text-align:left></td><td style=text-align:left><code>s = kill(pid, signal)</code></td><td style=text-align:left>Envia um sinal para um processo.</td></tr></tbody></table><p>Na maioria dos casos, o processo filho executa um código diferente do pai. Um exemplo clássico é o funcionamento do <strong>shell</strong>. Após ler um comando, o shell cria um processo filho que executa a instrução enquanto o pai aguarda. Para realizar essa espera, utiliza-se a chamada <strong>waitpid</strong>, que suspende a execução até que o filho termine, permitindo recuperar o estado de saída (normal ou erro) através da variável <code>statloc</code>.</p><p>Simultaneamente, o processo filho utiliza a chamada <strong>execve</strong> para substituir sua imagem de memória pelo programa solicitado. Embora existam variações como <code>execl</code> ou <code>execv</code> na biblioteca padrão, todas invocam a chamada de sistema base <code>exec</code>. Abaixo, apresentamos um modelo simplificado da lógica de um interpretador de comandos:</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Lógica Simplificada do Shell</span></div><div class=callout-content><p>O código a seguir ilustra o ciclo infinito de um shell: exibir prompt, ler comando, criar filho (<code>fork</code>), e decidir entre esperar (<code>waitpid</code>) ou executar (<code>execve</code>).</p></div></div><pre class="line-numbers language-c" data-lang=C><code class=language-c>#define TRUE 1

while (TRUE) {
    type_prompt(); /* mostra prompt na tela */
    read_command(command, parameters); /* le entrada do terminal */

    if (fork() != 0) {
        /* Codigo do processo pai */
        waitpid(-1, &status, 0); /* aguarda o processo filho acabar */
    } else {
        /* Codigo do processo filho */
        execve(command, parameters, 0); /* executa o comando */
    }
}
</code></pre><p>A função <code>main</code> da maioria dos programas C recebe três argumentos fundamentais para lidar com a linha de comando: <code>argc</code> (contagem de argumentos), <code>argv</code> (ponteiro para o array de argumentos) e <code>envp</code> (ponteiro para o ambiente). Por exemplo, ao executar <code>cp fd1 fd2</code>, o sistema passa esses nomes de arquivos através do vetor <code>argv</code> para que o programa possa localizá-los e processá-los.</p><p>Por fim, é crucial entender como esses processos ocupam a memória. Em sistemas UNIX, a memória é dividida em três segmentos principais: <strong>texto</strong> (código), <strong>dados</strong> (variáveis) e <strong>pilha</strong>. Conforme ilustrado na figura a seguir, o segmento de dados cresce para cima, enquanto a pilha cresce para baixo, deixando uma lacuna de endereçamento livre entre eles para expansão dinâmica.</p><img src=static/fig1_20_layout_memoria.png width=35%><p>Embora a pilha cresça automaticamente, a expansão do segmento de dados é gerida explicitamente. A chamada de sistema <code>brk</code> define o novo endereço de término do segmento de dados, embora programadores geralmente utilizem a função de biblioteca <code>malloc</code> para alocação dinâmica, abstraindo o uso direto do <code>brk</code>.</p><h3 id=chamadas-de-sistema-para-gerenciamento-de-arquivos><span class=heading-text>Chamadas de sistema para gerenciamento de arquivos</span><span class=heading-arabic>3.3.2</span></h3><p>Muitas chamadas de sistema relacionam-se diretamente ao sistema de arquivos. Nesta seção, o foco recairá sobre as chamadas que operam sobre arquivos individuais, deixando para um momento posterior aquelas que envolvem diretórios ou o sistema de arquivos como um todo. O ciclo de vida básico de manipulação de um arquivo começa com a necessidade de abri-lo antes de qualquer leitura ou escrita. A chamada de sistema <code>open</code> é responsável por essa tarefa, exigindo o nome do arquivo (seja um caminho absoluto ou relativo ao diretório de trabalho) e um código de modo de acesso.</p><p>Os códigos de acesso determinam como o arquivo será manipulado, conforme descrito na tabela abaixo:</p><table><thead><tr><th style=text-align:left>Flag de Acesso</th><th style=text-align:left>Significado</th><th style=text-align:left>Descrição</th></tr></thead><tbody><tr><td style=text-align:left><strong>O_RDONLY</strong></td><td style=text-align:left><em>Read Only</em></td><td style=text-align:left>Abre o arquivo apenas para leitura.</td></tr><tr><td style=text-align:left><strong>O_WRONLY</strong></td><td style=text-align:left><em>Write Only</em></td><td style=text-align:left>Abre o arquivo apenas para escrita.</td></tr><tr><td style=text-align:left><strong>O_RDWR</strong></td><td style=text-align:left><em>Read/Write</em></td><td style=text-align:left>Abre o arquivo para leitura e escrita.</td></tr><tr><td style=text-align:left><strong>O_CREAT</strong></td><td style=text-align:left><em>Create</em></td><td style=text-align:left>Cria um novo arquivo caso ele não exista.</td></tr></tbody></table><p>Uma vez aberto, o sistema retorna um <strong>descritor de arquivo</strong>, que será utilizado nas operações subsequentes. Após o término do uso, o arquivo deve ser fechado através da chamada <code>close</code>, o que libera o descritor para ser reutilizado em uma nova chamada <code>open</code>. As operações de leitura e escrita são realizadas pelas chamadas <code>read</code> e <code>write</code>, respectivamente, sendo que <code>write</code> possui os mesmos parâmetros de <code>read</code>.</p><p>Embora a leitura e a escrita sequenciais sejam comuns, certas aplicações necessitam de <strong>acesso aleatório</strong> a partes específicas de um arquivo. Para gerenciar isso, o sistema mantém um ponteiro associado a cada arquivo que indica a posição atual (byte) a ser lido ou escrito. A chamada de sistema <code>lseek</code> permite alterar explicitamente o valor desse ponteiro.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Funcionamento do lseek</span></div><div class=callout-content><p>A função <code>lseek</code> aceita três parâmetros fundamentais para reposicionar o ponteiro do arquivo:</p><ol><li><strong>Descritor de arquivo:</strong> O identificador do arquivo aberto.</li><li><strong>Posição (Offset):</strong> O deslocamento desejado.</li><li><strong>Referência:</strong> Define se a posição é relativa ao <strong>início</strong>, à <strong>posição atual</strong> ou ao <strong>fim</strong> do arquivo.</li></ol><p>O valor retornado é a nova posição absoluta em bytes após a mudança.</p></div></div><p>Por fim, o sistema operacional UNIX registra metadados cruciais para cada arquivo, como tipo (regular, especial, diretório), tamanho e hora da última modificação. Para acessar essas informações, os programas utilizam a chamada de sistema <code>stat</code>.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>// Exemplo de estrutura de chamada
int stat(const char *name, struct stat *buf);
int fstat(int fd, struct stat *buf);
</code></pre><p>A diferença principal entre as duas variações reside no primeiro parâmetro: <code>stat</code> recebe o nome do caminho do arquivo, enquanto <code>fstat</code> opera sobre um descritor de arquivo já aberto, mas ambas preenchem a estrutura apontada por <code>buf</code> com as mesmas informações detalhadas.</p><h3 id=chamadas-de-sistema-para-gerenciamento-de-diretórios><span class=heading-text>Chamadas de sistema para gerenciamento de diretórios</span><span class=heading-arabic>3.3.3</span></h3><p>Além das operações em arquivos individuais, o sistema operacional oferece chamadas que gerenciam diretórios e o sistema de arquivos como um todo. As operações mais básicas incluem <strong>mkdir</strong> e <strong>rmdir</strong>, utilizadas respectivamente para criar e remover diretórios vazios. Um conceito mais sofisticado é introduzido pela chamada <strong>link</strong>, cuja finalidade é permitir que um mesmo arquivo apareça sob dois ou mais nomes, frequentemente em diretórios distintos.</p><p>A criação de um link difere fundamentalmente da cópia de um arquivo. Ao compartilhar um arquivo via link, qualquer alteração realizada por um usuário é instantaneamente visível para os outros, pois existe apenas uma instância física do arquivo no disco. Em contrapartida, mudanças em cópias afetam apenas a versão específica editada. Para ilustrar o funcionamento do link, considere o cenário onde dois usuários, <em>ast</em> e <em>jim</em>, possuem diretórios próprios. Se <em>ast</em> executa a chamada de sistema abaixo, o arquivo <code>memo</code> de <em>jim</em> passa a aparecer também no diretório de <em>ast</em> com o nome <code>note</code>.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>link("/usr/jim/memo", "/usr/ast/note");
</code></pre><p>A partir desse momento, <code>/usr/jim/memo</code> e <code>/usr/ast/note</code> referem-se exatamente ao mesmo arquivo. A figura a seguir demonstra o estado dos diretórios antes e depois dessa operação de ligação:</p><img src=static/fig1_21_ligacao_diretorios.png width=95%><p>Para compreender a mecânica por trás disso, é necessário entender o conceito de <strong>i-número</strong> (ou i-nó). Todo arquivo no UNIX é identificado por um número único, que serve de índice em uma tabela de i-nós contendo metadados como proprietário e localização dos blocos no disco. Um diretório, conceitualmente, é apenas um arquivo que contém um conjunto de pares (<em>i-número</em>, <em>nome em ASCII</em>).</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Estrutura de Diretório</span></div><div class=callout-content><p>O comando <code>link</code> não duplica o conteúdo do arquivo; ele apenas cria uma <strong>nova entrada de diretório</strong> com um nome (possivelmente novo) apontando para o i-número de um arquivo já existente.</p></div></div><p>No exemplo da figura acima, observe que após a ligação, duas entradas (nos diretórios de <em>jim</em> e <em>ast</em>) apontam para o mesmo i-número (70). Se qualquer uma dessas entradas for removida posteriormente usando a chamada <strong>unlink</strong>, a outra permanece intacta. O arquivo só é efetivamente removido do disco quando o contador de referências no i-nó chega a zero, ou seja, quando não existem mais entradas de diretório apontando para ele.</p><p>Outra funcionalidade crítica para a integridade do sistema é a chamada <strong>mount</strong>, que permite a fusão de dois sistemas de arquivos distintos em uma única hierarquia. É comum ter o sistema raiz em uma partição e arquivos de usuário ou dispositivos externos (como pen drives USB) em outras. A chamada <code>mount</code> anexa o sistema de arquivos do dispositivo externo à árvore principal, eliminando a necessidade de o usuário saber em qual unidade física o arquivo reside.</p><img src=static/fig1_22_montagem_sistema_arquivos.png width=95%><p>Um comando típico para realizar essa operação, montando a unidade <code>/dev/sdb0</code> no diretório <code>/mnt</code>, seria:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>mount("/dev/sdb0", "/mnt", 0);
</code></pre><p>O primeiro parâmetro especifica o arquivo especial de bloco do dispositivo, o segundo define o ponto de montagem na árvore, e o terceiro controla flags de leitura/escrita. Após a montagem, os arquivos do dispositivo tornam-se acessíveis através do caminho do diretório, integrando mídias removíveis de forma transparente. Quando o acesso não for mais necessário, o sistema de arquivos pode ser desconectado utilizando a chamada <strong>umount</strong>.</p><h3 id=chamadas-de-sistema-diversas><span class=heading-text>Chamadas de sistema diversas</span><span class=heading-arabic>3.3.4</span></h3><p>Além das funções de gerenciamento de processos e arquivos, o sistema operacional oferece uma variedade de outras chamadas de sistema essenciais. Nesta seção, examinaremos quatro delas: <code>chdir</code>, <code>chmod</code>, <code>kill</code> e <code>time</code>. Elas desempenham papéis cruciais na navegação de diretórios, segurança, comunicação entre processos e contagem de tempo.</p><p>A tabela abaixo resume a funcionalidade de cada uma dessas chamadas:</p><table><thead><tr><th style=text-align:left>Chamada de Sistema</th><th style=text-align:left>Função Principal</th><th style=text-align:left>Exemplo de Uso Prático</th></tr></thead><tbody><tr><td style=text-align:left><strong>chdir</strong></td><td style=text-align:left>Altera o diretório de trabalho atual.</td><td style=text-align:left>Evita a digitação repetitiva de caminhos absolutos longos.</td></tr><tr><td style=text-align:left><strong>chmod</strong></td><td style=text-align:left>Altera o modo de proteção de um arquivo.</td><td style=text-align:left>Define permissões de leitura, escrita e execução.</td></tr><tr><td style=text-align:left><strong>kill</strong></td><td style=text-align:left>Envia sinais a processos.</td><td style=text-align:left>Permite comunicação ou encerramento forçado de processos.</td></tr><tr><td style=text-align:left><strong>time</strong></td><td style=text-align:left>Retorna o tempo atual em segundos.</td><td style=text-align:left>Baseia-se no "Epoch" (1º de janeiro de 1970).</td></tr></tbody></table><p>A chamada <code>chdir</code> facilita a navegação no sistema de arquivos. Ao alterar o diretório de trabalho, o sistema permite que o usuário referencie arquivos de forma relativa, simplificando os comandos. Por exemplo, após executar <code>chdir("/usr/ast/test")</code>, qualquer tentativa de abrir o arquivo "xyz" será interpretada automaticamente como <code>/usr/ast/test/xyz</code>.</p><p>No que tange à segurança, o UNIX atribui a todo arquivo um modo de proteção, composto por bits de leitura, escrita e execução para o proprietário, o grupo e outros usuários. A chamada <code>chmod</code> permite alterar esses bits. O código abaixo exemplifica como configurar um arquivo para ser "somente leitura" para todos, exceto o proprietário (usando a notação octal 0644):</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>chdir("/usr/ast/test"); /* Muda o diretório */
chmod("file", 0644);    /* Define permissões: rw-r--r-- */
</code></pre><p>Para a comunicação entre processos, utiliza-se a chamada <code>kill</code>. Apesar do nome sugestivo, sua função primária é enviar <strong>sinais</strong>. Se o processo destinatário estiver preparado para capturar o sinal, uma rotina de tratamento específica é executada. No entanto, se o processo não estiver preparado para lidar com o sinal recebido, a ação padrão é encerrar (matar) o processo, o que explica a origem do nome da chamada.</p><p>Por fim, o padrão POSIX define rotinas para lidar com o tempo. A chamada <code>time</code> retorna o tempo atual medido em segundos decorridos desde a "Era UNIX" ou <strong>Epoch</strong> (meia-noite de 1º de janeiro de 1970).</p><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>O Problema do Ano 2106</span></div><div class=callout-content><p>Em computadores que utilizam palavras de 32 bits, o valor máximo que a chamada <code>time</code> pode retornar (presumindo um inteiro <strong>sem sinal</strong>) é $2^{32} - 1$ segundos. Esse valor corresponde a aproximadamente 136 anos.</p><p>Isso significa que, no ano de <strong>2106</strong>, sistemas UNIX de 32 bits baseados em inteiros sem sinal atingirão seu limite e poderão falhar, de maneira análoga ao famoso "Bug do Milênio" (Y2K). Embora pareça distante, a recomendação técnica para sistemas de longa vida é a migração para arquiteturas de 64 bits.</p></div></div><h2 id=estrutura-de-sistemas-operacionais><span class=heading-text>Estrutura de sistemas operacionais</span><span class=heading-arabic>3.4</span></h2><p>Após explorarmos a interface externa apresentada ao programador, o foco desloca-se agora para a arquitetura interna dos sistemas operacionais. A análise de como esses sistemas são construídos por dentro revela um amplo espectro de possibilidades de design e implementação.</p><p>Nas seções seguintes, examinaremos seis estruturas distintas que foram testadas na prática, oferecendo uma visão abrangente sobre a engenharia de software de sistemas:</p><ul><li><strong>Sistemas Monolíticos:</strong> Onde o núcleo opera como um único programa em espaço de kernel.</li><li><strong>Sistemas de Camadas:</strong> Organização hierárquica onde cada nível confia apenas no nível inferior.</li><li><strong>Micronúcleos:</strong> Filosofia de manter o núcleo o menor possível, movendo serviços para o espaço do usuário.</li><li><strong>Sistemas Cliente-Servidor:</strong> Variação onde processos servidores respondem a requisições de clientes.</li><li><strong>Máquinas Virtuais:</strong> Abstração que cria múltiplas instâncias isoladas de hardware.</li><li><strong>Exonúcleos:</strong> Foco na alocação segura de recursos brutos, sem abstrações de alto nível.</li></ul><p>Antes de detalhar essas arquiteturas, é pertinente estabelecer um paralelo entre os ambientes operacionais mais comuns. A figura e a tabela a seguir ilustram a correspondência aproximada entre as chamadas de sistema UNIX (discutidas anteriormente) e as chamadas da API Win32.</p><img src=static/fig1_23_api_win32_vs_unix.png width=90%><p>Embora o Windows possua um número vastamente superior de chamadas de sistema, muitas sem equivalente direto no UNIX, as funções essenciais de gerenciamento mapeiam-se da seguinte forma para fins de comparação:</p><table><thead><tr><th style=text-align:left>Funcionalidade</th><th style=text-align:left>UNIX (POSIX)</th><th style=text-align:left>Win32 API (Windows)</th></tr></thead><tbody><tr><td style=text-align:left><strong>Criação de Processo</strong></td><td style=text-align:left><code>fork</code></td><td style=text-align:left><code>CreateProcess</code></td></tr><tr><td style=text-align:left><strong>Espera de Processo</strong></td><td style=text-align:left><code>waitpid</code></td><td style=text-align:left><code>WaitForSingleObject</code></td></tr><tr><td style=text-align:left><strong>Execução de Programa</strong></td><td style=text-align:left><code>execve</code></td><td style=text-align:left>(Combinado em <code>CreateProcess</code>)</td></tr><tr><td style=text-align:left><strong>Saída de Processo</strong></td><td style=text-align:left><code>exit</code></td><td style=text-align:left><code>ExitProcess</code></td></tr><tr><td style=text-align:left><strong>Abrir Arquivo</strong></td><td style=text-align:left><code>open</code></td><td style=text-align:left><code>CreateFile</code></td></tr><tr><td style=text-align:left><strong>Ler Arquivo</strong></td><td style=text-align:left><code>read</code></td><td style=text-align:left><code>ReadFile</code></td></tr><tr><td style=text-align:left><strong>Escrever Arquivo</strong></td><td style=text-align:left><code>write</code></td><td style=text-align:left><code>WriteFile</code></td></tr><tr><td style=text-align:left><strong>Fechar Arquivo</strong></td><td style=text-align:left><code>close</code></td><td style=text-align:left><code>CloseHandle</code></td></tr><tr><td style=text-align:left><strong>Criar Diretório</strong></td><td style=text-align:left><code>mkdir</code></td><td style=text-align:left><code>CreateDirectory</code></td></tr><tr><td style=text-align:left><strong>Remover Arquivo</strong></td><td style=text-align:left><code>unlink</code></td><td style=text-align:left><code>DeleteFile</code></td></tr></tbody></table><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Complexidade da API Win32</span></div><div class=callout-content><p>É importante enfatizar que a API Win32 é significativamente mais complexa que o padrão POSIX. Enquanto o UNIX foca em primitivas simples, o Windows tende a fornecer chamadas ricas em parâmetros. A tabela acima é uma simplificação didática para demonstrar a equivalência funcional.</p></div></div><h3 id=sistemas-monolíticos><span class=heading-text>Sistemas monolíticos</span><span class=heading-arabic>3.4.1</span></h3><p>De longe a organização mais comum no design de software de base, a abordagem monolítica caracteriza-se pela execução de todo o sistema operacional como um único programa em modo núcleo. O sistema é construído como uma coleção de rotinas ligadas a um único grande binário executável. Nesta arquitetura, qualquer procedimento tem a liberdade de chamar qualquer outro procedimento, caso este ofereça alguma computação útil necessária.</p><p>Embora essa liberdade irrestrita proporcione alta eficiência de execução, a interdependência de milhares de procedimentos pode resultar em um sistema complexo e de difícil compreensão. Além disso, a estabilidade é comprometida, pois uma falha crítica em qualquer rotina individual tem o potencial de derrubar todo o sistema operacional. Para construir o programa objeto, compilam-se todas as rotinas individuais que são posteriormente unificadas por um ligador (<em>linker</em>). Em termos de engenharia de software, praticamente não há ocultação de informações, pois todas as rotinas são visíveis entre si, ao contrário de estruturas modulares onde o acesso é restrito a pontos de entrada oficiais.</p><p>Mesmo dentro dessa estrutura maciça, existe uma organização lógica para o processamento de chamadas de sistema. Os serviços são solicitados colocando-se parâmetros em um local definido (como a pilha) e executando uma instrução de desvio de controle (<em>trap</em>). Essa instrução alterna a máquina do modo usuário para o modo núcleo e transfere o controle para o sistema operacional. O sistema então consulta uma tabela de despacho que contém ponteiros para as rotinas de serviço correspondentes.</p><p>Essa organização sugere uma estrutura básica dividida em três níveis funcionais, conforme ilustrado na figura a seguir:</p><img src=static/fig1_24_estrutura_monolitica.png width=75%><p>Cada nível desempenha um papel específico no atendimento às solicitações do usuário, detalhado na tabela abaixo:</p><table><thead><tr><th style=text-align:left>Nível da Estrutura</th><th style=text-align:left>Função Principal</th></tr></thead><tbody><tr><td style=text-align:left><strong>Programa Principal</strong></td><td style=text-align:left>Invoca a rotina de serviço requisitada após a interrupção (<em>trap</em>).</td></tr><tr><td style=text-align:left><strong>Rotinas de Serviço</strong></td><td style=text-align:left>Executam as chamadas de sistema específicas (o trabalho real do SO).</td></tr><tr><td style=text-align:left><strong>Rotinas Utilitárias</strong></td><td style=text-align:left>Auxiliam as rotinas de serviço em tarefas comuns, como buscar dados do usuário.</td></tr></tbody></table><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Extensões Dinâmicas (DLLs e Bibliotecas Compartilhadas)</span></div><div class=callout-content><p>Embora o núcleo seja monolítico, muitos sistemas modernos suportam extensões carregáveis sob demanda, como drivers de dispositivos e sistemas de arquivos.</p><ul><li><strong>UNIX:</strong> Utiliza bibliotecas compartilhadas.</li><li><strong>Windows:</strong> Utiliza <strong>DLLs</strong> (<em>Dynamic Link Libraries</em>, ou bibliotecas de ligação dinâmica). O diretório <code>C:\Windows\system32</code> tipicamente contém milhares desses arquivos, essenciais para a flexibilidade do sistema.</li></ul></div></div><h3 id=sistemas-de-camadas><span class=heading-text>Sistemas de camadas</span><span class=heading-arabic>3.4.2</span></h3><p>Uma generalização da abordagem monolítica consiste em organizar o sistema operacional como uma hierarquia de camadas, onde cada nível é construído sobre a camada imediatamente inferior. O primeiro sistema construído sob essa filosofia foi o sistema <strong>THE</strong>, desenvolvido na Technische Hogeschool Eindhoven, na Holanda, por E. W. Dijkstra e seus estudantes em 1968. O THE era um sistema em lote simples projetado para o computador Electrologica X8, que possuía uma memória restrita de 32 K palavras de 27 bits.</p><p>A arquitetura do sistema THE foi dividida em seis camadas distintas, conforme ilustrado na figura a seguir:</p><img src=static/fig1_25_camadas_the.png width=60%><p>Cada camada tinha uma responsabilidade específica e fornecia uma abstração para as camadas superiores, simplificando o desenvolvimento. A estrutura funcional é detalhada na tabela abaixo:</p><table><thead><tr><th style=text-align:left>Camada</th><th style=text-align:left>Função Principal</th><th style=text-align:left>Abstração Fornecida</th></tr></thead><tbody><tr><td style=text-align:left><strong>0</strong></td><td style=text-align:left>Alocação do processador e multiprogramação.</td><td style=text-align:left>Processos sequenciais (abstração de múltiplas CPUs).</td></tr><tr><td style=text-align:left><strong>1</strong></td><td style=text-align:left>Gerenciamento de memória e paginação (tambor magnético).</td><td style=text-align:left>Memória virtual (independência do armazenamento físico).</td></tr><tr><td style=text-align:left><strong>2</strong></td><td style=text-align:left>Comunicação Operador-Processo.</td><td style=text-align:left>Console de operação individual para cada processo.</td></tr><tr><td style=text-align:left><strong>3</strong></td><td style=text-align:left>Gerenciamento de E/S e <em>buffering</em>.</td><td style=text-align:left>Dispositivos de E/S abstratos e simplificados.</td></tr><tr><td style=text-align:left><strong>4</strong></td><td style=text-align:left>Programas de Usuário.</td><td style=text-align:left>Ambiente de execução isolado do hardware bruto.</td></tr><tr><td style=text-align:left><strong>5</strong></td><td style=text-align:left>Operador do Sistema.</td><td style=text-align:left>Controle geral do sistema.</td></tr></tbody></table><p>Outra generalização importante do conceito de camadas foi implementada no sistema <strong>MULTICS</strong>. Em vez de camadas lineares, o MULTICS utilizava uma série de <strong>anéis concêntricos</strong>. Os anéis internos eram mais privilegiados que os externos. Quando um procedimento em um anel exterior necessitava chamar um procedimento em um anel interior, ele executava uma instrução de desvio (TRAP). Os parâmetros dessa chamada eram rigorosamente verificados antes que o acesso fosse concedido, garantindo a segurança.</p><p>A diferença fundamental entre as duas abordagens reside na implementação da proteção. Enquanto o esquema de camadas do THE era principalmente um suporte de projeto (compilado em um único programa executável), o mecanismo de anéis do MULTICS estava presente em tempo de execução e era imposto pelo hardware. O hardware permitia designar segmentos de memória protegidos contra leitura, escrita ou execução.</p><div class="callout callout-example"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><path d="M12 11V7"/><path d="M9 11l3 3 3-3"/></svg></span><span class=callout-title-inner>Aplicação Prática dos Anéis</span></div><div class=callout-content><p>A vantagem do mecanismo de anéis é a extensibilidade para subsistemas de usuário. Imagine um professor que deseja criar um sistema automático de notas:</p><ul><li>O programa do professor (corretor) roda no **anel *n***.</li><li>Os programas dos estudantes (submetidos para teste) rodam no <strong>anel <em>n</em> + 1</strong>.</li></ul><p>Dessa forma, os programas dos estudantes podem ser executados e analisados pelo corretor, mas o hardware impede que eles acessem ou alterem os dados (como as notas) que residem no anel mais privilegiado.</p></div></div><h3 id=micronúcleos><span class=heading-text>Micronúcleos</span><span class=heading-arabic>3.4.3</span></h3><p>A decisão sobre onde traçar a linha divisória entre o modo núcleo e o modo usuário é fundamental no design de sistemas operacionais. Tradicionalmente, a abordagem de camadas coloca a maior parte das funcionalidades dentro do núcleo. No entanto, existe um forte argumento em defesa do <strong>micronúcleo</strong>, que preconiza manter o mínimo possível de código rodando em modo privilegiado. A justificativa principal é a confiabilidade: erros no código do núcleo podem derrubar o sistema instantaneamente, enquanto processos de usuário, com menos privilégios, têm falhas contidas.</p><p>Estudos sobre engenharia de software indicam que a densidade de erros em sistemas industriais sérios varia entre dois e dez erros por mil linhas de código. Aplicando essa métrica a um sistema operacional monolítico moderno, que pode conter cinco milhões de linhas, é provável que existam entre 10.000 e 50.000 bugs no núcleo. Embora nem todos sejam fatais, essa vulnerabilidade explica por que fabricantes de hardware ainda incluem botões de reinicialização física em seus equipamentos, algo incomum em outros dispositivos eletrônicos de consumo.</p><p>A filosofia do micronúcleo visa atingir alta confiabilidade dividindo o sistema em módulos pequenos e bem definidos. Apenas o micronúcleo executa em modo núcleo; todo o restante, incluindo drivers de dispositivos e sistemas de arquivos, roda como processos de usuário com poderes limitados. A tabela abaixo ilustra o impacto dessa arquitetura na estabilidade do sistema:</p><table><thead><tr><th style=text-align:left>Característica</th><th style=text-align:left>Sistema Monolítico</th><th style=text-align:left>Sistema de Micronúcleo</th></tr></thead><tbody><tr><td style=text-align:left><strong>Localização dos Drivers</strong></td><td style=text-align:left>Dentro do Núcleo (Kernel Mode)</td><td style=text-align:left>Processos de Usuário (User Mode)</td></tr><tr><td style=text-align:left><strong>Acesso à Memória</strong></td><td style=text-align:left>Irrestrito</td><td style=text-align:left>Restrito e Controlado</td></tr><tr><td style=text-align:left><strong>Falha em Driver (ex: Áudio)</strong></td><td style=text-align:left>O sistema inteiro trava (Crash/Tela Azul)</td><td style=text-align:left>Apenas o som para, o sistema continua estável</td></tr><tr><td style=text-align:left><strong>Recuperação</strong></td><td style=text-align:left>Reinicialização total necessária</td><td style=text-align:left>O componente pode ser reiniciado individualmente</td></tr></tbody></table><p>Embora sistemas de desktop comuns (exceto o OS X, baseado no Mach) raramente usem micronúcleos puros, eles são dominantes em aplicações críticas como aviônica, sistemas militares e industriais. Exemplos notáveis incluem Integrity, QNX, L4 e o <strong>MINIX 3</strong>. O MINIX 3, em particular, leva a modularidade ao extremo e serve como um excelente estudo de caso, sendo um sistema compatível com POSIX e de código aberto.</p><p>O núcleo do MINIX 3 é extremamente enxuto, contendo cerca de 12.000 linhas de C e 1.400 linhas de Assembly. Ele gerencia apenas o essencial: tratamento de interrupções, escalonamento básico e comunicação entre processos (troca de mensagens). A estrutura de processos resultante é visualizada na figura a seguir, onde os tratadores de chamadas de núcleo são rotulados como <em>Sys</em>:</p><img src=static/fig1_26_estrutura_processo_minix3.png width=60%><p>Fora do núcleo, o sistema organiza-se em camadas de processos em modo usuário. Na base, encontram-se os drivers de dispositivos. Como não possuem acesso direto às portas físicas de E/S, eles devem solicitar ao núcleo que realize a escrita ou leitura, permitindo que o sistema verifique as permissões de acesso antes de executar a operação. Acima dos drivers, residem os servidores (como o servidor de arquivos e o gerenciador de processos), que executam a maior parte do trabalho do sistema operacional.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>O Servidor de Reencarnação</span></div><div class=callout-content><p>Uma característica distintiva do MINIX 3 é o <strong>Servidor de Reencarnação</strong>. Sua função é monitorar a saúde dos outros servidores e drivers. Se um driver de áudio ou de rede falhar, este servidor detecta o problema e substitui o componente defeituoso automaticamente, sem intervenção do usuário, conferindo ao sistema uma capacidade de "autocura".</p></div></div><p>A segurança é reforçada através de restrições rigorosas. Cada processo possui permissões granulares: drivers só tocam em portas autorizadas e a comunicação entre processos é controlada. Além disso, essa arquitetura facilita a separação entre <strong>política e mecanismo</strong>. O núcleo fornece o mecanismo (por exemplo, como trocar de processo), enquanto processos de usuário definem a política (quais prioridades atribuir), permitindo um núcleo menor e mais estável.</p><h3 id=o-modelo-cliente-servidor><span class=heading-text>O modelo cliente-servidor</span><span class=heading-arabic>3.4.4</span></h3><p>Uma variação arquitetural importante, frequentemente derivada da filosofia do micronúcleo, é o <strong>modelo cliente-servidor</strong>. Esta abordagem distingue duas classes fundamentais de processos: os servidores, responsáveis por prestar serviços, e os clientes, que consomem esses serviços. Embora a camada inferior seja muitas vezes um micronúcleo, a essência do modelo reside na separação clara de responsabilidades e na comunicação via troca de mensagens.</p><p>Para solicitar um serviço, o processo cliente constrói uma mensagem detalhando sua requisição e a envia ao processo servidor apropriado. O servidor processa a solicitação e retorna uma resposta. Uma das grandes vantagens desse modelo é a capacidade de abstração e transparência de localização. Como a comunicação ocorre via mensagens, o cliente não precisa saber se o servidor está sendo executado localmente na mesma máquina ou remotamente através de uma rede.</p><img src=static/fig1_27_cliente_servidor_rede.png width=90%><p>Essa flexibilidade permite que o modelo cliente-servidor seja aplicado tanto em sistemas monousuários quanto em grandes redes distribuídas, como a Web, onde PCs residenciais atuam como clientes solicitando páginas a grandes servidores remotos.</p><table><thead><tr><th style=text-align:left>Componente</th><th style=text-align:left>Função Principal</th><th style=text-align:left>Exemplo Prático</th></tr></thead><tbody><tr><td style=text-align:left><strong>Cliente</strong></td><td style=text-align:left>Inicia a solicitação de serviço através de mensagens.</td><td style=text-align:left>Navegador Web (solicita uma página).</td></tr><tr><td style=text-align:left><strong>Servidor</strong></td><td style=text-align:left>Processa a requisição, executa o trabalho e retorna a resposta.</td><td style=text-align:left>Servidor Web (entrega o HTML/conteúdo).</td></tr><tr><td style=text-align:left><strong>Rede/Kernel</strong></td><td style=text-align:left>Transporta a mensagem (transparente para o cliente).</td><td style=text-align:left>Internet ou Barramento de Mensagens Local.</td></tr></tbody></table><h3 id=máquinas-virtuais><span class=heading-text>Máquinas virtuais</span><span class=heading-arabic>3.4.5</span></h3><p>Os lançamentos iniciais do OS/360 caracterizavam-se por serem estritamente sistemas em lote (<em>batch</em>). No entanto, a crescente necessidade dos usuários por operações interativas via terminal impulsionou diversos grupos, tanto dentro quanto fora da IBM, a desenvolverem sistemas de compartilhamento de tempo. A resposta oficial da IBM, o TSS/360, enfrentou problemas severos de desempenho e atrasos, resultando em seu abandono após consumir cerca de 50 milhões de dólares em desenvolvimento.</p><p>Paralelamente a esse insucesso, pesquisadores do Centro Científico da IBM em Cambridge, Massachusetts, produziram uma arquitetura alternativa radicalmente diferente que obteve êxito comercial e técnico. A trajetória desses sistemas está resumida na tabela abaixo:</p><table><thead><tr><th style=text-align:left>Sistema</th><th style=text-align:left>Status e Impacto</th></tr></thead><tbody><tr><td style=text-align:left><strong>OS/360</strong></td><td style=text-align:left>Sistema original de lote. Carecia de interatividade.</td></tr><tr><td style=text-align:left><strong>TSS/360</strong></td><td style=text-align:left>Tentativa falha de <em>time-sharing</em>. Lento e custoso.</td></tr><tr><td style=text-align:left><strong>CP/CMS</strong></td><td style=text-align:left>O sistema inovador de Cambridge que introduziu a virtualização eficiente.</td></tr><tr><td style=text-align:left><strong>z/VM</strong></td><td style=text-align:left>O descendente moderno, padrão da indústria atual.</td></tr></tbody></table><p>O legado desse desenvolvimento persiste no moderno <strong>z/VM</strong>, amplamente executado nos computadores de grande porte da família <strong>IBM zSeries</strong>. Esses equipamentos constituem a espinha dorsal de grandes centros de processamento de dados corporativos, sendo fundamentais para servidores de comércio eletrônico. Eles são capazes de processar milhares de transações por segundo e gerenciar bancos de dados cujos tamanhos atingem a escala de milhões de gigabytes.</p><div class="callout callout-success"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg></span><span class=callout-title-inner>Consolidação da Tecnologia</span></div><div class=callout-content><p>A aceitação do sistema desenvolvido em Cambridge pela IBM marcou um ponto de virada, transformando a virtualização de uma ideia experimental em um produto comercial viável que sustenta a infraestrutura crítica mundial até hoje.</p></div></div><h4 id=vm370><span class=heading-text>VM/370</span><span class=heading-arabic>3.4.5.1</span></h4><p>O sistema originalmente denominado CP/CMS, e mais tarde renomeado <strong>VM/370</strong> (Seawright e MacKinnon, 1979), foi fundamentado em uma observação astuta sobre a natureza dos sistemas operacionais. Seus criadores notaram que um sistema de compartilhamento de tempo fornece simultaneamente duas funcionalidades distintas: multiprogramação e uma máquina estendida com uma interface mais conveniente que o hardware bruto. A essência inovadora do VM/370 reside na separação completa dessas duas funções.</p><p>O núcleo do sistema, conhecido como <strong>Monitor de Máquina Virtual</strong>, opera diretamente sobre o hardware e realiza a multiprogramação. Sua função não é fornecer uma abstração de alto nível, mas sim criar várias <strong>máquinas virtuais</strong> para a camada seguinte. Diferentemente de outros sistemas operacionais, essas máquinas virtuais não são máquinas estendidas com arquivos e recursos abstratos. Em vez disso, elas são cópias exatas do hardware exposto, incluindo modos núcleo/usuário, dispositivos de E/S, interrupções e todas as características da máquina física, conforme ilustrado na figura a seguir:</p><img src=static/fig1_28_monitor_maquina_virtual.png width=75%><p>Como cada máquina virtual é idêntica ao hardware original, cada uma delas possui a capacidade de executar qualquer sistema operacional que rodaria diretamente no hardware físico. Isso permite que diferentes máquinas virtuais executem, simultaneamente, diferentes sistemas operacionais. No contexto do VM/370 original da IBM, era comum observar a seguinte configuração mista:</p><table><thead><tr><th style=text-align:left>Tipo de Sistema</th><th style=text-align:left>Exemplo de OS</th><th style=text-align:left>Uso Típico</th></tr></thead><tbody><tr><td style=text-align:left><strong>Batch (Lote)</strong></td><td style=text-align:left>OS/360</td><td style=text-align:left>Processamento de transações pesadas ou tarefas em lote.</td></tr><tr><td style=text-align:left><strong>Interativo</strong></td><td style=text-align:left>CMS (Conversational Monitor System)</td><td style=text-align:left>Sistema monousuário para programadores e tempo compartilhado.</td></tr></tbody></table><p>O funcionamento técnico dessa virtualização envolve um processo de interceptação e simulação. Quando um programa CMS executa uma chamada de sistema, esta é desviada para o sistema operacional residente em sua própria máquina virtual (o próprio CMS), e não diretamente para o VM/370. O CMS, agindo como se estivesse no hardware real, emite instruções normais de E/S para ler seu disco virtual.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>O Mecanismo de Simulação</span></div><div class=callout-content><p>As instruções de E/S emitidas pelo sistema hóspede (CMS) são interceptadas (capturadas por uma armadilha) pelo VM/370. O monitor então executa essas instruções como parte de sua simulação do hardware real. Ao separar a multiprogramação da provisão da máquina estendida, cada parte torna-se mais simples, flexível e fácil de manter.</p></div></div><p>Em sua encarnação moderna, o sistema evoluiu para o <strong>z/VM</strong>. Diferentemente do uso histórico com sistemas monousuários desmontados como o CMS, o z/VM é frequentemente utilizado para executar sistemas operacionais completos e modernos. Por exemplo, os mainframes zSeries são capazes de hospedar centenas ou milhares de máquinas virtuais Linux operando lado a lado com sistemas operacionais IBM tradicionais, consolidando servidores e serviços em uma única infraestrutura robusta.</p><h4 id=máquinas-virtuais-redescobertas><span class=heading-text>Máquinas virtuais redescobertas</span><span class=heading-arabic>3.4.5.2</span></h4><p>Embora a IBM tenha disponibilizado produtos de máquina virtual há quatro décadas, e empresas como Oracle e Hewlett-Packard tenham implementado suporte em servidores de alto desempenho, a virtualização foi amplamente ignorada no universo dos PCs até recentemente. Contudo, uma convergência de novas necessidades, softwares e tecnologias transformou esse conceito em um tópico de alto interesse.</p><p><strong>Motivações para o Renascimento da Virtualização</strong></p><p>A adoção massiva dessa tecnologia é impulsionada por demandas específicas de diferentes setores, desde a consolidação de servidores corporativos até a flexibilidade para usuários finais. A tabela abaixo resume os principais cenários de uso:</p><table><thead><tr><th style=text-align:left>Cenário</th><th style=text-align:left>Problema Anterior</th><th style=text-align:left>Solução via Virtualização</th></tr></thead><tbody><tr><td style=text-align:left><strong>Consolidação de Servidores</strong></td><td style=text-align:left>Execução de múltiplos serviços (Web, FTP, E-mail) em máquinas físicas separadas ou com risco de conflito em um único SO.</td><td style=text-align:left>Executar todos os serviços na mesma máquina física, isolados em VMs, sem que a falha de um derrube os outros.</td></tr><tr><td style=text-align:left><strong>Hospedagem Web</strong></td><td style=text-align:left>Escolha binária entre hospedagem compartilhada (barata, sem controle) e dedicada (cara, flexível).</td><td style=text-align:left>Oferta de máquinas virtuais (VPS). O cliente tem controle total (root) a uma fração do custo de um servidor dedicado.</td></tr><tr><td style=text-align:left><strong>Usuários Finais</strong></td><td style=text-align:left>Necessidade de reiniciar o computador (<em>dual-boot</em>) para usar sistemas diferentes (ex: Windows e Linux).</td><td style=text-align:left>Execução simultânea de múltiplos sistemas operacionais para acessar aplicativos exclusivos de cada plataforma.</td></tr></tbody></table><p>Para compreender a implementação técnica dessas soluções, é fundamental analisar a arquitetura dos <strong>Hipervisores</strong>. O termo "monitor de máquina virtual" foi modernamente renomeado para <strong>Hipervisor de Tipo 1</strong>, embora ambos os termos sejam usados. A figura a seguir ilustra a evolução e as variações dessas estruturas:</p><img src=static/fig1_29_hipervisores_tipos.png width=90%><p><strong>O Desafio da Implementação em x86</strong></p><p>Apesar da atratividade do conceito, a implementação em PCs enfrentou obstáculos técnicos severos. Para que um software de virtualização funcione, a CPU deve ser virtualizável (Popek e Goldberg, 1974). Quando um SO hóspede tenta executar uma instrução privilegiada (como modificar a PSW ou realizar E/S), o hardware deve gerar uma armadilha (<em>trap</em>) para o hipervisor, permitindo a emulação segura.</p><div class="callout callout-failure"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=10 /><path d="m15 9-6 6"/><path d="m9 9 6 6"/></svg></span><span class=callout-title-inner>O Problema do Pentium e x86</span></div><div class=callout-content><p>Em CPUs antigas da família x86, notadamente o Pentium e seus clones, as tentativas de executar instruções privilegiadas em modo usuário eram simplesmente ignoradas pelo hardware, em vez de gerar uma armadilha. Essa falha arquitetural impediu a virtualização direta, exigindo o uso de interpretadores lentos (como o Bochs) ou técnicas complexas de tradução binária.</p></div></div><p>A situação mudou com pesquisas acadêmicas na década de 1990, como o <strong>Disco</strong> (Stanford) e o <strong>Xen</strong> (Cambridge), que pavimentaram o caminho para produtos comerciais como <strong>VMware Workstation</strong>, <strong>VirtualBox</strong>, <strong>KVM</strong> e <strong>Hyper-V</strong>.</p><p><strong>Evolução e Classificação dos Hipervisores</strong></p><p>A evolução técnica partiu da simples interpretação para a <strong>tradução binária</strong>, onde blocos de código são traduzidos e armazenados em cache para reutilização (conforme a Figura 1.29b). O passo seguinte, adotado por quase todos os hipervisores comerciais modernos de desktop, foi a adição de um <strong>módulo de núcleo</strong> para realizar tarefas pesadas (Figura 1.29c). Embora tecnicamente híbridos, esses sistemas são classificados como <strong>Hipervisores de Tipo 2</strong>.</p><p>A distinção prática entre os dois tipos principais é vital para a compreensão da arquitetura de sistemas:</p><table><thead><tr><th style=text-align:left>Característica</th><th style=text-align:left>Hipervisor Tipo 1 (Bare Metal)</th><th style=text-align:left>Hipervisor Tipo 2 (Hosted)</th></tr></thead><tbody><tr><td style=text-align:left><strong>Execução</strong></td><td style=text-align:left>Roda diretamente sobre o hardware (sem SO subjacente).</td><td style=text-align:left>Roda sobre um Sistema Operacional Hospedeiro (Windows, Linux).</td></tr><tr><td style=text-align:left><strong>Gerenciamento</strong></td><td style=text-align:left>Gerencia sua própria armazenagem e particionamento bruto.</td><td style=text-align:left>Usa o sistema de arquivos do SO hospedeiro (disco virtual = arquivo).</td></tr><tr><td style=text-align:left><strong>Exemplos</strong></td><td style=text-align:left>Xen, VMware ESXi, Hyper-V (Server).</td><td style=text-align:left>VMware Workstation, VirtualBox.</td></tr><tr><td style=text-align:left><strong>Inicialização</strong></td><td style=text-align:left>O Hipervisor é o primeiro software a carregar.</td><td style=text-align:left>O SO Hospedeiro carrega primeiro, depois o Hipervisor é iniciado como aplicação.</td></tr></tbody></table><p>Quando um sistema operacional hóspede é inicializado em um Hipervisor Tipo 2, ele se comporta como se estivesse no hardware real, iniciando processos e interfaces gráficas. Contudo, existe uma abordagem alternativa chamada <strong>Paravirtualização</strong>. Nela, o sistema operacional hóspede é modificado para remover as instruções de controle problemáticas e colaborar com o hipervisor, diferindo da virtualização pura onde o SO hóspede não tem consciência de que está sendo virtualizado.</p><h4 id=a-máquina-virtual-java><span class=heading-text>A máquina virtual Java</span><span class=heading-arabic>3.4.5.3</span></h4><p>Uma aplicação distinta e fundamental do conceito de virtualização encontra-se na execução de programas Java. Quando a Sun Microsystems desenvolveu a linguagem de programação Java, criou simultaneamente uma arquitetura de computador abstrata denominada <strong>JVM</strong> (Java Virtual Machine, ou Máquina Virtual Java). Diferentemente das abordagens tradicionais, o compilador Java não produz código de máquina nativo para um processador específico (como x86 ou SPARC). Em vez disso, ele gera código para a JVM, que é posteriormente executado por um programa interpretador.</p><p>A principal vantagem dessa arquitetura é a <strong>portabilidade</strong>. O código compilado para a JVM pode ser enviado pela internet e executado em qualquer computador que possua um interpretador JVM instalado, independentemente do hardware ou sistema operacional subjacente. Se o compilador produzisse binários específicos (por exemplo, apenas para processadores SPARC), esses programas não poderiam ser distribuídos e executados universalmente com a mesma facilidade. Embora fosse teoricamente possível distribuir um emulador de SPARC, a arquitetura da JVM foi projetada para ser muito mais simples de interpretar.</p><p>Para ilustrar a diferença de abordagem, a tabela abaixo compara a compilação nativa tradicional com o modelo da JVM:</p><table><thead><tr><th style=text-align:left>Característica</th><th style=text-align:left>Compilação Nativa (ex: C/C++)</th><th style=text-align:left>Compilação Java (JVM)</th></tr></thead><tbody><tr><td style=text-align:left><strong>Produto do Compilador</strong></td><td style=text-align:left>Código de máquina específico (Binário x86, ARM, etc.).</td><td style=text-align:left><em>Bytecode</em> (Instruções para a JVM).</td></tr><tr><td style=text-align:left><strong>Execução</strong></td><td style=text-align:left>Direta pelo hardware (CPU).</td><td style=text-align:left>Interpretada pela JVM (Software).</td></tr><tr><td style=text-align:left><strong>Portabilidade</strong></td><td style=text-align:left>Baixa (Requer recompilação para cada plataforma).</td><td style=text-align:left>Alta ("Escreva uma vez, execute em qualquer lugar").</td></tr><tr><td style=text-align:left><strong>Dependência</strong></td><td style=text-align:left>Sistema Operacional e Hardware.</td><td style=text-align:left>Presença da JVM instalada.</td></tr></tbody></table><p>Além da portabilidade, o uso da JVM oferece benefícios significativos de segurança. Como o código é executado por um intermediário (o interpretador), é possível implementar verificações rigorosas no código recebido antes de sua execução.</p><div class="callout callout-success"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg></span><span class=callout-title-inner>Segurança e "Sandbox"</span></div><div class=callout-content><p>Se o interpretador for implementado adequadamente, os programas JVM podem ser executados em um <strong>ambiente protegido</strong> (frequentemente chamado de <em>sandbox</em>). Isso garante que o código não possa roubar dados, corromper a memória ou causar danos ao sistema hospedeiro, uma característica vital para aplicações distribuídas via internet.</p></div></div><h3 id=exonúcleos><span class=heading-text>Exonúcleos</span><span class=heading-arabic>3.4.6</span></h3><p>Uma estratégia distinta da virtualização tradicional, que clona a máquina inteira, consiste em dividir a máquina real, fornecendo a cada usuário um subconjunto estrito dos recursos disponíveis. Nesta abordagem, em vez de simular um disco completo para cada máquina virtual, o sistema pode alocar, por exemplo, os blocos de disco de 0 a 1.023 para uma máquina e os blocos de 1.024 a 2.047 para a próxima.</p><p>Na camada inferior, operando em modo núcleo, encontra-se um programa denominado <strong>exonúcleo</strong> (Engler et al., 1995). Sua tarefa fundamental é alocar recursos às máquinas virtuais e verificar cada tentativa de uso para assegurar que nenhuma máquina tente acessar os recursos alheios. Cada máquina virtual, no nível do usuário, executa seu próprio sistema operacional, similar ao VM/370 ou ao modo virtual 8086 do Pentium, mas com a restrição de utilizar apenas os recursos explicitamente alocados.</p><p>A principal vantagem técnica do esquema do exonúcleo é a eliminação de uma camada de mapeamento, o que reduz significativamente a sobrecarga do sistema. A tabela a seguir compara as duas abordagens de gerenciamento de recursos:</p><table><thead><tr><th style=text-align:left>Característica</th><th style=text-align:left>Máquinas Virtuais Tradicionais</th><th style=text-align:left>Arquitetura de Exonúcleo</th></tr></thead><tbody><tr><td style=text-align:left><strong>Estratégia</strong></td><td style=text-align:left>Clonagem (Simulação de Hardware).</td><td style=text-align:left>Particionamento (Divisão de Recursos).</td></tr><tr><td style=text-align:left><strong>Visão do Disco</strong></td><td style=text-align:left>Cada VM "pensa" que tem um disco completo (Blocos 0 a Max).</td><td style=text-align:left>O SO sabe quais blocos físicos possui (ex: 1024 a 2047).</td></tr><tr><td style=text-align:left><strong>Gerenciamento</strong></td><td style=text-align:left>O VMM mantém tabelas complexas para remapear endereços virtuais para físicos.</td><td style=text-align:left>O Exonúcleo apenas registra qual recurso pertence a qual VM.</td></tr><tr><td style=text-align:left><strong>Sobrecarga</strong></td><td style=text-align:left>Alta (devido ao remapeamento constante).</td><td style=text-align:left>Baixa (apenas verificação de proteção).</td></tr></tbody></table><div class="callout callout-success"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg></span><span class=callout-title-inner>Eficiência de Desempenho</span></div><div class=callout-content><p>Ao remover a necessidade de remapear endereços de disco e outros recursos, o exonúcleo mantém as máquinas virtuais isoladas umas das outras com um custo computacional mínimo. Ele separa a multiprogramação (no núcleo) do código do sistema operacional (no usuário) de forma mais eficiente que a virtualização clássica, limitando-se a manter as máquinas virtuais distantes umas das outras.</p></div></div><h2 id=questões><span class=heading-text>Questões</span><span class=heading-arabic>3.5</span></h2><p><strong>1.</strong> O texto descreve a evolução e a diversidade dos sistemas operacionais. Associe corretamente o tipo de sistema operacional (Coluna A) à sua característica ou exemplo principal (Coluna B).</p><table><thead><tr><th style=text-align:left>Coluna A</th><th style=text-align:left>Coluna B</th></tr></thead><tbody><tr><td style=text-align:left>(1) Mainframe / Grande Porte</td><td style=text-align:left>( ) O sistema operacional funciona frequentemente apenas como uma biblioteca ligada à aplicação; foca em prazos rígidos.</td></tr><tr><td style=text-align:left>(2) Tempo Real Crítico (Hard)</td><td style=text-align:left>( ) Otimizado para processar milhares de transações por segundo e gerenciar volumes massivos de E/S; ex: OS/390.</td></tr><tr><td style=text-align:left>(3) Computadores Pessoais</td><td style=text-align:left>( ) Sistemas onde a perda ocasional de um prazo é aceitável e não causa danos permanentes; ex: Áudio digital.</td></tr><tr><td style=text-align:left>(4) Tempo Real Não Crítico (Soft)</td><td style=text-align:left>( ) Focado em fornecer uma interface robusta para um único usuário e suportar multitarefa para aplicações de escritório e web.</td></tr></tbody></table><p><strong>2.</strong> Sobre o mecanismo de <strong>Chamadas de Sistema</strong> e a instrução <strong>TRAP</strong>, analise as afirmações abaixo e assinale a alternativa correta:</p><ul><li>a) A instrução TRAP é idêntica a uma chamada de função comum (<code>CALL</code>), pois apenas desvia o fluxo para um endereço de memória onde reside a função do sistema.</li><li>b) A principal função da TRAP é alternar o estado do processador de modo usuário para modo núcleo (kernel), permitindo a execução de operações privilegiadas de forma segura.</li><li>c) As chamadas de sistema no padrão POSIX são executadas inteiramente em modo usuário para garantir que uma falha no driver não derrube o sistema operacional.</li><li>d) O comando <code>read</code> acessa diretamente o hardware do disco sem passar pelo sistema operacional, utilizando a TRAP apenas para notificar o término da leitura.</li></ul><p><strong>3.</strong> Considere um sistema UNIX de 32 bits que utiliza um inteiro <strong>sem sinal</strong> para contar o tempo (chamada de sistema <code>time</code>). O texto menciona o "Problema do Ano 2106".</p><ul><li>a) Explique o que é o "Epoch" e qual a data base utilizada.</li><li>b) Sabendo que o valor máximo de um inteiro sem sinal de 32 bits é $2^{32} - 1$, calcule aproximadamente quantos anos esse contador pode registrar a partir do Epoch.</li><li>c) Por que a migração para arquiteturas de 64 bits é recomendada para solucionar este problema definitivamente?</li></ul><p><strong>4.</strong> O gerenciamento de processos utiliza chamadas específicas como <code>fork</code> e <code>execve</code>. Analise o trecho de código abaixo, que simula um shell simplificado, e responda:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>if (fork() != 0) {
    waitpid(-1, &status, 0);
} else {
    execve(command, parameters, 0);
}
</code></pre><ul><li>a) Qual valor a chamada <code>fork()</code> retorna para o processo <strong>pai</strong> e qual valor ela retorna para o processo <strong>filho</strong>?</li><li>b) Qual é a função da chamada <code>waitpid</code> neste contexto e o que aconteceria com o shell (pai) se ela não fosse utilizada?</li><li>c) O que a chamada <code>execve</code> faz com a imagem de memória do processo filho?</li></ul><p><strong>5.</strong> A segurança em sistemas UNIX é gerida por bits de permissão. Considere um arquivo com as permissões exibidas como <code>rwxr-x--x</code>.</p><ul><li>a) Converta essa representação simbólica para a notação <strong>octal</strong> utilizada pela chamada <code>chmod</code> (lembrando que r=4, w=2, x=1).</li><li>b) Descreva detalhadamente o que o <strong>Grupo</strong> e os <strong>Outros</strong> usuários podem e não podem fazer com este arquivo.</li></ul><p><strong>6.</strong> Sobre as Arquiteturas de Sistemas Operacionais, marque (V) para Verdadeiro ou (F) para Falso:</p><ul><li>( ) <strong>Sistemas Monolíticos:</strong> Todo o sistema operacional roda como um único programa em modo núcleo; uma falha em um driver de áudio pode travar todo o computador.</li><li>( ) <strong>Micronúcleos:</strong> Visam alta confiabilidade movendo a maior parte do código (como drivers e sistemas de arquivos) para o espaço do usuário; ex: MINIX 3.</li><li>( ) <strong>Sistemas de Camadas:</strong> No modelo do sistema THE, a camada de mais alto nível era responsável pelo gerenciamento de memória e paginação.</li><li>( ) <strong>Máquinas Virtuais (Tipo 2):</strong> O hipervisor roda diretamente sobre o hardware ("bare metal"), sem a necessidade de um sistema operacional hospedeiro como Windows ou Linux.</li><li>( ) <strong>Exonúcleos:</strong> Em vez de clonar a máquina, essa arquitetura particiona os recursos (ex: blocos de disco específicos) e permite que cada máquina virtual gerencie seus próprios recursos alocados sem remapeamento complexo.</li></ul><p><strong>7.</strong> O sistema de arquivos UNIX permite a criação de links. Analise o cenário onde o usuário <em>ast</em> executa o comando <code>link("/usr/jim/memo", "/usr/ast/note")</code>.</p><ul><li>a) O conteúdo do arquivo <code>memo</code> é duplicado no disco para criar o arquivo <code>note</code>? Justifique usando o conceito de <strong>i-número</strong>.</li><li>b) Se o usuário <em>jim</em> remover o arquivo original <code>memo</code> usando <code>unlink</code>, o que acontece com o arquivo <code>note</code> de <em>ast</em> e com o conteúdo no disco? Explique o conceito de contador de referências.</li></ul><p><strong>8.</strong> Ordene cronologicamente as etapas que ocorrem durante a execução da chamada de sistema <code>read</code>, conforme descrito na arquitetura monolítica/POSIX:</p><ul><li>(A) A biblioteca coloca o número da chamada de sistema em um registrador.</li><li>(B) O tratador da chamada de sistema executa a operação solicitada (trabalho real).</li><li>(C) O programa do usuário empilha os parâmetros (nbytes, &buffer, fd).</li><li>(D) A instrução TRAP é executada, mudando para modo núcleo.</li><li>(E) O código do núcleo usa uma tabela de despacho para encontrar o tratador correto.</li><li>(F) A biblioteca retorna ao programa do usuário, que limpa a pilha.</li></ul><p><strong>9.</strong> Diferencie <strong>Hipervisores de Tipo 1</strong> e <strong>Hipervisores de Tipo 2</strong> com base em:</p><ul><li>a) Localização da execução (sobre o que eles rodam?).</li><li>b) Exemplos de softwares comerciais citados no texto para cada tipo.</li></ul><p><strong>10.</strong> Explique a filosofia do <strong>Modelo Cliente-Servidor</strong> em sistemas operacionais locais (não em rede) e como ela se relaciona com a arquitetura de Micronúcleos. Cite o benefício de "transparência de localização" mencionado no texto.</p><h2 id=próximos-passos><span class=heading-text>Próximos passos</span><span class=heading-arabic>3.6</span></h2><p>Na próxima aula, <a href=4-processes-and-threads.html>Processos e Threads</a>, aprofundaremos nossa visão sobre a unidade fundamental de execução. Deixaremos de ver o processo apenas como uma abstração estática para entender sua dinâmica interna: estados de execução, escalonamento e a distinção crucial entre processos pesados e threads leves. Investigaremos como o sistema operacional orquestra a alternância rápida da CPU para criar a ilusão de paralelismo e como evitar condições de corrida em ambientes concorrentes.</p></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Sistemas Operacionais`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>