<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Sistemas Operacionais</title><link media="(prefers-color-scheme: light)" href=/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Sistemas Operacionais</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#introdução>4.1. Introdução</a></li><li class="toc-item level-3"><a href=#o-modelo-de-processo>4.1.1. O modelo de processo</a></li><li class="toc-item level-3"><a href=#criação-de-processos>4.1.2. Criação de processos</a></li><li class="toc-item level-3"><a href=#término-de-processos>4.1.3. Término de processos</a></li><li class="toc-item level-3"><a href=#hierarquias-de-processos>4.1.4. Hierarquias de processos</a></li><li class="toc-item level-3"><a href=#estados-de-processos>4.1.5. Estados de processos</a></li><li class="toc-item level-3"><a href=#implementação-de-processos>4.1.6. Implementação de processos</a></li><li class="toc-item level-3"><a href=#modelando-a-multiprogramação>4.1.7. Modelando a multiprogramação</a></li><li class="toc-item level-2"><a href=#threads>4.2. Threads</a></li><li class="toc-item level-3"><a href=#utilização-de-threads>4.2.1. Utilização de threads</a></li><li class="toc-item level-3"><a href=#o-modelo-de-thread-clássico>4.2.2. O modelo de thread clássico</a></li><li class="toc-item level-3"><a href=#threads-posix>4.2.3. Threads POSIX</a></li><li class="toc-item level-3"><a href=#implementando-threads-no-espaço-do-usuário>4.2.4. Implementando threads no espaço do usuário</a></li><li class="toc-item level-3"><a href=#implementando-threads-no-núcleo>4.2.5. Implementando threads no núcleo</a></li><li class="toc-item level-3"><a href=#implementações-híbridas>4.2.6. Implementações híbridas</a></li><li class="toc-item level-3"><a href=#ativações-pelo-escalonador>4.2.7. Ativações pelo escalonador</a></li><li class="toc-item level-3"><a href=#threads-pop-up>4.2.8. Threads pop-up</a></li><li class="toc-item level-3"><a href=#convertendo-código-de-um-thread-em-código-multithread>4.2.9. Convertendo código de um thread em código multithread</a></li><li class="toc-item level-2"><a href=#questões>4.3. Questões</a></li><li class="toc-item level-2"><a href=#próximos-passos>4.4. Próximos passos</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=3-concepts-and-structures-of-os.html><i class=nav-icon data-lucide=chevron-left></i> Conceitos e Estruturas de Sistemas Operacionais</a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>4</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>Processos e Threads</span> <span class="title-ornament right">❧</span></h1><p class=article-date>07/02/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Sistemas Operacionais</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-II>II - Processos e Threads</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>Processos e Threads</span></nav></header><div class=article-body><h2 id=introdução><span class=heading-text>Introdução</span><span class=heading-arabic>4.1</span></h2><p>Iniciamos agora um estudo detalhado sobre o projeto e a construção de sistemas operacionais, focando naquele que é considerado o conceito mais central desta área: o processo. Trata-se de uma abstração de um programa em execução, sendo que todos os demais elementos dependem dessa definição. O projetista e o estudante de sistemas operacionais devem desenvolver uma compreensão profunda sobre o que constitui um processo o mais cedo possível, visto que esta é uma das abstrações mais antigas e vitais fornecidas por esses sistemas.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Definição de Processo</span></div><div class=callout-content><p>Processos dão suporte à possibilidade de haver operações pseudoconcorrentes mesmo quando existe apenas uma CPU disponível, transformando uma única unidade física de processamento em múltiplas CPUs virtuais. Sem a abstração de processo, a computação moderna não poderia existir.</p></div></div><p>Neste contexto, examinaremos detalhadamente os processos e seus "primos", os threads. Ao observarmos o funcionamento dos computadores modernos, notamos que eles frequentemente realizam várias tarefas ao mesmo tempo. Embora usuários habituados possam não estar totalmente cientes desse fato, a análise de cenários práticos ajuda a esclarecer este ponto, conforme ilustrado nos exemplos a seguir:</p><div class="callout callout-example"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><path d="M12 11V7"/><path d="M9 11l3 3 3-3"/></svg></span><span class=callout-title-inner>Cenários de Execução Concorrente</span></div><div class=callout-content><p><strong>1. O Servidor Web</strong> Solicitações de páginas chegam de toda parte. Ao receber uma requisição, o servidor verifica se a página está em cache. Se estiver, ela é enviada imediatamente. Caso contrário, inicia-se uma solicitação de acesso ao disco. Como o acesso ao disco é lento do ponto de vista da CPU, muitas outras solicitações podem chegar durante essa espera. Com múltiplos discos, novas solicitações podem ser processadas antes mesmo da conclusão da primeira.</p><p><strong>2. O Computador Pessoal (PC)</strong> Ao inicializar o sistema, muitos processos são iniciados secretamente (background). Um processo pode aguardar e-mails, enquanto outro executa o antivírus periodicamente. Simultaneamente, o usuário pode imprimir arquivos e salvar fotos em um pen-drive enquanto navega na Web. Toda essa atividade requer um sistema de multiprogramação robusto para ser gerenciada.</p></div></div><p>É evidente que é necessário um método para modelar e controlar essa concorrência, e é aqui que processos e threads desempenham um papel crucial. Em qualquer sistema de multiprogramação, a CPU alterna de um processo para outro rapidamente, executando cada um por dezenas ou centenas de milissegundos.</p><p>Estritamente falando, em um dado instante a CPU executa apenas um processo, mas no curso de um segundo ela pode trabalhar em vários deles, criando uma ilusão de paralelismo. Para diferenciar essa alternância rápida do paralelismo físico real, utilizamos terminologias distintas detalhadas na tabela abaixo:</p><table><thead><tr><th style=text-align:left>Conceito</th><th style=text-align:left>Descrição Técnica</th><th style=text-align:left>Hardware Típico</th></tr></thead><tbody><tr><td style=text-align:left><strong>Pseudoparalelismo</strong></td><td style=text-align:left>A CPU alterna rapidamente entre processos, criando a ilusão de simultaneidade.</td><td style=text-align:left>Uma única CPU compartilhando tempo.</td></tr><tr><td style=text-align:left><strong>Verdadeiro Paralelismo</strong></td><td style=text-align:left>Múltiplas instruções são executadas literalmente ao mesmo tempo em unidades físicas distintas.</td><td style=text-align:left>Sistemas multiprocessadores (duas ou mais CPUs compartilhando memória).</td></tr></tbody></table><p>Como ter controle sobre múltiplas atividades em paralelo é uma tarefa complexa para os seres humanos, os projetistas de sistemas operacionais desenvolveram ao longo dos anos o modelo conceitual de <strong>processos sequenciais</strong>. Esse modelo torna o paralelismo mais fácil de lidar, e suas consequências compõem a base para o entendimento profundo do gerenciamento de sistemas computacionais.</p><h3 id=o-modelo-de-processo><span class=heading-text>O modelo de processo</span><span class=heading-arabic>4.1.1</span></h3><p>Nesse modelo, todos os softwares executáveis no computador, incluindo frequentemente o sistema operacional, são organizados em uma série de processos sequenciais. Um <strong>processo</strong> é, fundamentalmente, uma instância de um programa em execução, contendo os valores atuais do contador do programa, registradores e variáveis. Conceitualmente, cada processo possui sua própria CPU virtual. Na realidade, a CPU física alterna entre os processos constantemente, mas, para fins de compreensão do sistema, é mais simples imaginar uma coleção de processos sendo executados em pseudo-paralelismo do que tentar rastrear a troca frenética da CPU. Esse mecanismo de alternância rápida é denominado <strong>multiprogramação</strong>.</p><p>A visualização desse conceito é essencial para distinguir entre a perspectiva física e a lógica. A figura a seguir ilustra essa distinção, mostrando como a memória organiza os programas e como o fluxo de controle é percebido:</p><img src=static/fig2_1_multiprogramacao.png width=90%><p>Ao analisar a imagem acima, observamos em <strong>(a)</strong> um computador multiprogramando quatro programas na memória. Em <strong>(b)</strong>, vemos quatro processos, cada um com seu próprio <strong>contador de programa lógico</strong> e fluxo de controle, sendo executados independentemente. Embora exista apenas um <strong>contador de programa físico</strong>, seu valor é salvo no contador lógico do processo na memória sempre que a execução é interrompida e restaurado quando ela retorna. Em <strong>(c)</strong>, nota-se que, ao longo do tempo, todos os processos progridem, embora apenas um esteja ativo em um dado instante.</p><p>Embora a maioria das CPUs modernas seja <em>multicore</em> (com dois ou mais núcleos), assumiremos neste capítulo, para fins de simplificação, a existência de apenas uma CPU. O princípio permanece o mesmo: mesmo com dois núcleos, cada um só pode executar um processo por vez.</p><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Desafios de Temporização na Multiprogramação</span></div><div class=callout-content><p>Com o chaveamento rápido da CPU, a velocidade de execução de um processo não é uniforme nem necessariamente reproduzível. <strong>Processos não devem ser programados com suposições rígidas sobre tempo.</strong></p><p><strong>Exemplo Prático:</strong> Considere um processo de áudio que deve tocar música sincronizada com um vídeo. O processo pode iniciar um <em>loop</em> ocioso para aguardar o momento exato. Se a CPU trocar de processo durante esse <em>loop</em>, o áudio poderá retornar atrasado, perdendo a sincronia com o vídeo. Para sistemas de tempo real com prazos críticos (em milissegundos), medidas especiais são necessárias.</p></div></div><p>A distinção entre um <strong>processo</strong> e um <strong>programa</strong> é sutil, porém crucial. Um programa é uma entidade passiva (como um arquivo em disco), enquanto um processo é uma entidade ativa. Para ilustrar essa diferença, utilizamos uma analogia clássica:</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Analogia: O Cientista e o Bolo</span></div><div class=callout-content><p>Imagine um cientista da computação preparando um bolo de aniversário.</p><table><thead><tr><th style=text-align:left>Elemento da Cozinha</th><th style=text-align:left>Conceito de S.O.</th></tr></thead><tbody><tr><td style=text-align:left><strong>A Receita</strong></td><td style=text-align:left>O <strong>Programa</strong> (algoritmo expresso em notação).</td></tr><tr><td style=text-align:left><strong>O Cientista</strong></td><td style=text-align:left>O <strong>Processador (CPU)</strong>.</td></tr><tr><td style=text-align:left><strong>Os Ingredientes</strong></td><td style=text-align:left>Os <strong>Dados de Entrada</strong>.</td></tr><tr><td style=text-align:left><strong>Preparar o Bolo</strong></td><td style=text-align:left>O <strong>Processo</strong> (a atividade em execução).</td></tr></tbody></table><p><strong>Cenário de Interrupção:</strong> Se o filho do cientista entra chorando (uma interrupção de alta prioridade), o cientista registra onde parou na receita (salva o estado do processo atual) e muda para o "programa" de primeiros socorros. Ao terminar, ele recupera o estado salvo e continua o bolo.</p><p><strong>Conclusão:</strong> Um processo é uma atividade com estado, entrada, saída e um programa. O processador é compartilhado entre vários processos através de um algoritmo de escalonamento.</p></div></div><p>Por fim, é importante notar que instâncias diferentes do mesmo programa são processos distintos. Se você abrir dois processadores de texto simultaneamente, haverá dois processos separados. Embora o sistema operacional possa otimizar o uso da memória compartilhando o código do programa, conceitualmente eles permanecem como duas linhas de execução independentes.</p><h3 id=criação-de-processos><span class=heading-text>Criação de processos</span><span class=heading-arabic>4.1.2</span></h3><p>Sistemas operacionais necessitam de mecanismos eficientes para criar processos. Em sistemas muito simples ou projetados para uma única aplicação, como o controlador de um forno de micro-ondas, é possível que todos os processos necessários sejam carregados no momento em que o sistema é ligado. Contudo, em sistemas de propósito geral, é indispensável a capacidade de criar e terminar processos dinamicamente durante a operação.</p><p>Existem quatro eventos principais que desencadeiam a criação de processos, detalhados na tabela a seguir:</p><table><thead><tr><th style=text-align:left>Evento de Criação</th><th style=text-align:left>Contexto e Descrição</th></tr></thead><tbody><tr><td style=text-align:left><strong>Inicialização do Sistema</strong></td><td style=text-align:left>Ocorre quando o sistema operacional é carregado, criando processos essenciais de primeiro e segundo plano.</td></tr><tr><td style=text-align:left><strong>Chamada de Sistema</strong></td><td style=text-align:left>Um processo em execução solicita a criação de um novo processo para auxiliar em sua tarefa.</td></tr><tr><td style=text-align:left><strong>Solicitação do Usuário</strong></td><td style=text-align:left>O usuário inicia um programa via linha de comando ou interface gráfica (clique duplo).</td></tr><tr><td style=text-align:left><strong>Início de Tarefa em Lote</strong></td><td style=text-align:left>Em mainframes, o sistema inicia um processo automaticamente quando há recursos disponíveis para a próxima tarefa da fila.</td></tr></tbody></table><p>Durante a inicialização do sistema, diversos processos são iniciados. Alguns operam em primeiro plano, interagindo com usuários humanos, enquanto outros funcionam em segundo plano, desempenhando funções específicas como gerenciar e-mails ou servir páginas web. Estes processos de segundo plano, que permanecem inativos até serem solicitados, possuem uma denominação específica:</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>O que são Daemons?</span></div><div class=callout-content><p>Processos que operam em segundo plano para lidar com atividades como e-mail, impressão e serviços web são chamados de <strong>daemons</strong>.</p><ul><li><strong>No UNIX:</strong> O comando <code>ps</code> pode ser usado para listar esses processos.</li><li><strong>No Windows:</strong> O Gerenciador de Tarefas desempenha função similar de visualização.</li></ul></div></div><p>A criação de novos processos por um processo já existente é particularmente útil para dividir tarefas. Por exemplo, ao processar uma grande quantidade de dados de uma rede, um processo pode focar na busca dos dados enquanto um segundo processo os manipula, permitindo paralelismo real em sistemas multiprocessadores. Em sistemas interativos, ações simples como clicar em um ícone iniciam novos processos, que podem ou não abrir janelas visuais, dependendo do sistema operacional (UNIX ou Windows).</p><p>Do ponto de vista técnico, a criação sempre envolve uma chamada de sistema. A implementação dessa chamada varia drasticamente entre os sistemas operacionais UNIX e Windows, conforme comparado abaixo:</p><table><thead><tr><th style=text-align:left>Característica</th><th style=text-align:left>UNIX (Posix, Linux, MacOS)</th><th style=text-align:left>Windows (Win32)</th></tr></thead><tbody><tr><td style=text-align:left><strong>Chamada Principal</strong></td><td style=text-align:left><code>fork</code></td><td style=text-align:left><code>CreateProcess</code></td></tr><tr><td style=text-align:left><strong>Mecanismo</strong></td><td style=text-align:left><code>fork</code> cria um clone exato do processo pai. Posteriormente, <code>execve</code> é usado para carregar o novo programa.</td><td style=text-align:left><code>CreateProcess</code> realiza tanto a criação quanto o carregamento do programa em uma única chamada.</td></tr><tr><td style=text-align:left><strong>Complexidade</strong></td><td style=text-align:left>Processo em dois passos. Permite manipulação de descritores de arquivos (redirecionamento de E/S) antes da execução do novo código.</td><td style=text-align:left>Chamada única com cerca de 10 parâmetros (programa, segurança, prioridade, janelas, etc.).</td></tr><tr><td style=text-align:left><strong>Espaço de Endereço</strong></td><td style=text-align:left>Inicialmente, o filho é uma cópia do pai. Utiliza <em>copy-on-write</em> (cópia-na-escrita) para otimização.</td><td style=text-align:left>Os espaços de endereços do pai e do filho são diferentes desde o início.</td></tr></tbody></table><p>É crucial notar que, em ambos os sistemas, após a criação, o processo pai e o processo filho possuem espaços de endereçamento distintos. Se um processo altera uma variável em sua memória, essa mudança <strong>não</strong> é visível para o outro. No UNIX, embora a memória possa ser compartilhada inicialmente para leitura via <em>copy-on-write</em>, qualquer tentativa de escrita provoca uma cópia física da página de memória, garantindo que a memória modificável nunca seja compartilhada inadvertidamente. Recursos como arquivos abertos, todavia, podem ser compartilhados dependendo da implementação.</p><h3 id=término-de-processos><span class=heading-text>Término de processos</span><span class=heading-arabic>4.1.3</span></h3><p>Após a criação e o início da execução, todo processo realiza sua função designada. No entanto, o ciclo de vida de um processo é finito; mais cedo ou mais tarde, ele deve terminar. Esse encerramento ocorre geralmente devido a uma de quatro condições principais, que variam entre a conclusão natural do trabalho e interrupções forçadas por erros ou intervenções externas.</p><p>A tabela abaixo detalha as causas fundamentais para o fim de um processo, classificando-as pela natureza da ocorrência:</p><table><thead><tr><th style=text-align:left>Motivo do Término</th><th style=text-align:left>Natureza</th><th style=text-align:left>Descrição e Contexto</th></tr></thead><tbody><tr><td style=text-align:left><strong>1. Saída Normal</strong></td><td style=text-align:left>Voluntária</td><td style=text-align:left>O processo conclui sua tarefa com sucesso. Exemplo: um compilador termina a tradução do código ou o usuário fecha o navegador.</td></tr><tr><td style=text-align:left><strong>2. Saída por Erro</strong></td><td style=text-align:left>Voluntária</td><td style=text-align:left>O processo detecta um problema lógico (como um arquivo de entrada inexistente) e decide encerrar a execução de forma controlada.</td></tr><tr><td style=text-align:left><strong>3. Erro Fatal</strong></td><td style=text-align:left>Involuntária</td><td style=text-align:left>Ocorrem falhas graves decorrentes de <em>bugs</em>, como instrução ilegal, referência a memória inexistente ou divisão por zero.</td></tr><tr><td style=text-align:left><strong>4. Morto por Outro</strong></td><td style=text-align:left>Involuntária</td><td style=text-align:left>Um processo executa uma chamada de sistema para forçar o encerramento de outro processo (ex: Gerenciador de Tarefas).</td></tr></tbody></table><p>Quando um processo termina voluntariamente, ele comunica esse fato ao sistema operacional através de chamadas específicas: <code>exit</code> no UNIX e <code>ExitProcess</code> no Windows. Em aplicações interativas baseadas em tela, como processadores de texto, essa ação é desencadeada visualmente pelo usuário ao clicar em um ícone de fechar, o que permite ao software limpar arquivos temporários antes de sair.</p><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Tratamento de Erros: Lote vs. Interativo</span></div><div class=callout-content><p>A forma como o erro é tratado depende da interface do programa:</p><ul><li><strong>Linha de Comando (Ex: Compilador):</strong> Se o usuário digita <code>cc foo.c</code> e o arquivo não existe, o programa anuncia o erro e encerra imediatamente (Saída por Erro).</li><li><strong>Interface Gráfica (Interativo):</strong> Geralmente não fecha o programa diante de dados incorretos. Em vez disso, exibe uma caixa de diálogo pedindo que o usuário tente novamente.</li></ul></div></div><p>Nos casos de erro fatal, o sistema operacional intervém. No entanto, em alguns sistemas como o UNIX, um processo pode instruir o sistema de que deseja lidar com certos erros sozinho (capturando o sinal), evitando o término abrupto. Já no cenário de morte forçada por outro processo, é necessária a devida autorização de segurança. As chamadas utilizadas são <code>kill</code> (UNIX) e <code>TerminateProcess</code> (Win32).</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Independência de Processos Filhos</span></div><div class=callout-content><p>Em alguns sistemas operacionais teóricos ou antigos, o encerramento de um processo pai acarretava a morte imediata de todos os seus processos filhos. É importante notar que <strong>nem o UNIX nem o Windows funcionam dessa maneira</strong>. Nesses sistemas modernos, os processos filhos continuam sua execução independentemente do destino de seu criador.</p></div></div><h3 id=hierarquias-de-processos><span class=heading-text>Hierarquias de processos</span><span class=heading-arabic>4.1.4</span></h3><p>Em diversos sistemas operacionais, a criação de um processo estabelece um vínculo duradouro entre o criador (pai) e a criatura (filho). À medida que o processo filho gera seus próprios descendentes, forma-se uma estrutura hierárquica. É fundamental observar que, diferentemente da biologia de animais que utilizam a reprodução sexual, um processo possui apenas um pai, embora possa ter zero ou múltiplos filhos.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Analogia Biológica</span></div><div class=callout-content><p>A estrutura de reprodução de processos assemelha-se mais à de uma <strong>hidra</strong> (reprodução assexuada/brotamento) do que à de um mamífero ou uma vaca. A linhagem é direta e singular na origem.</p></div></div><p>No ambiente <strong>UNIX</strong>, essa hierarquia é rígida e funcional. Um processo e todos os seus descendentes constituem um <strong>grupo de processos</strong>. Essa estruturação permite, por exemplo, que um sinal enviado pelo teclado seja entregue simultaneamente a todos os membros do grupo associado àquela janela. Individualmente, cada processo tem autonomia para tratar esse sinal: capturá-lo, ignorá-lo ou aceitar a ação padrão (geralmente, o encerramento). A importância dessa árvore genealógica é visível na inicialização do sistema:</p><ol><li>O processo <strong>init</strong> é carregado na raiz da imagem de inicialização.</li><li>Ele lê a configuração de terminais e realiza um <em>fork</em> (bifurcação) para criar um novo processo para cada terminal.</li><li>Esses processos aguardam uma conexão bem-sucedida.</li><li>Após o login, um <em>shell</em> é executado para aceitar novos comandos, expandindo a árvore.</li></ol><p>Consequentemente, todos os processos em um sistema UNIX pertencem a uma única árvore global enraizada no <em>init</em>, e um pai nunca pode "deserdar" seus filhos. Em contrapartida, o <strong>Windows</strong> adota uma filosofia distinta, onde a hierarquia é muito mais tênue, conforme comparado na tabela a seguir:</p><table><thead><tr><th style=text-align:left>Característica</th><th style=text-align:left>UNIX</th><th style=text-align:left>Windows</th></tr></thead><tbody><tr><td style=text-align:left><strong>Estrutura</strong></td><td style=text-align:left>Árvore única e rígida (Root/Init).</td><td style=text-align:left>Plana. Todos os processos são essencialmente iguais.</td></tr><tr><td style=text-align:left><strong>Vínculo Pai-Filho</strong></td><td style=text-align:left>Permanente. O pai define o grupo de processos.</td><td style=text-align:left>Temporário e transferível via <em>Handles</em>.</td></tr><tr><td style=text-align:left><strong>Controle</strong></td><td style=text-align:left>Baseado na ancestralidade direta.</td><td style=text-align:left>Baseado na posse do <em>token</em> (handle) de controle.</td></tr><tr><td style=text-align:left><strong>Herança</strong></td><td style=text-align:left>Processos não podem ser deserdados.</td><td style=text-align:left>O <em>handle</em> pode ser passado a outro processo, invalidando a hierarquia original.</td></tr></tbody></table><p>No Windows, o único vestígio de hierarquia surge na criação, quando o pai recebe um identificador especial (<em>handle</em>) para controlar o filho. Contudo, como esse identificador pode ser transferido livremente para terceiros, a noção de "família" se dissolve, permitindo que qualquer processo que possua o <em>handle</em> controle a execução, diferentemente da estrutura familiar fixa do UNIX.</p><h3 id=estados-de-processos><span class=heading-text>Estados de processos</span><span class=heading-arabic>4.1.5</span></h3><p>Embora cada processo opere como uma entidade independente, possuindo seu próprio contador de programa e estado interno, é frequente a necessidade de interação entre eles. Um cenário comum é quando a saída de um processo serve de entrada para outro. Considere o seguinte comando <em>shell</em>:</p><pre class="line-numbers language-bash" data-lang=BASH><code class=language-bash>cat chapter1 chapter2 chapter3 | grep tree
</code></pre><p>Neste exemplo, o primeiro processo (<code>cat</code>) concatena três arquivos e envia o resultado como saída. O segundo processo (<code>grep</code>) filtra essas informações, selecionando apenas as linhas que contêm a palavra "tree". A sincronia entre eles depende da velocidade relativa e da complexidade de cada programa. Se o <code>grep</code> estiver pronto para processar, mas o <code>cat</code> ainda não tiver enviado dados, o <code>grep</code> deverá ser bloqueado.</p><p>É crucial distinguir as razões pelas quais um processo para. O bloqueio lógico ocorre quando um processo não pode continuar porque aguarda um dado externo (como no exemplo acima). Já a parada por decisão do sistema ocorre quando o sistema operacional decide alocar a CPU para outro processo, mesmo que o primeiro esteja apto a continuar.</p><p>Para sistematizar essas condições, definimos três estados fundamentais em que um processo pode se encontrar:</p><table><thead><tr><th style=text-align:left>Estado</th><th style=text-align:left>Descrição e Condição</th></tr></thead><tbody><tr><td style=text-align:left><strong>Em Execução</strong></td><td style=text-align:left>O processo está, de fato, utilizando a CPU naquele instante.</td></tr><tr><td style=text-align:left><strong>Pronto</strong></td><td style=text-align:left>O processo é executável e está disposto a rodar, mas está temporariamente parado para dar lugar a outro.</td></tr><tr><td style=text-align:left><strong>Bloqueado</strong></td><td style=text-align:left>O processo é incapaz de ser executado até que um evento externo (como uma entrada de dados) ocorra.</td></tr></tbody></table><p>A dinâmica entre esses estados é regida por transições específicas, conforme ilustrado no diagrama de estados a seguir:</p><img src=static/fig2_2_diagrama_estados.png width=50%><p>Analisando a figura acima, identificamos quatro transições possíveis, numeradas de 1 a 4, que descrevem o ciclo de vida operacional do processo:</p><ol><li><strong>Bloqueio (Execução $\rightarrow$ Bloqueado):</strong> Ocorre quando o sistema operacional percebe que o processo não pode continuar imediatamente. Isso pode ser voluntário (chamada de sistema <code>pause</code>) ou automático (leitura de um <em>pipe</em> ou terminal vazio).</li><li><strong>Preempção (Execução $\rightarrow$ Pronto):</strong> Esta transição é causada pelo <strong>escalonador</strong> de processos. O sistema decide que o processo atual já usou a CPU por tempo suficiente e deve ceder lugar a outro.</li><li><strong>Seleção (Pronto $\rightarrow$ Execução):</strong> Também gerida pelo escalonador, ocorre quando chega a vez de um processo na fila "Pronto" assumir a CPU novamente.</li><li><strong>Desbloqueio (Bloqueado $\rightarrow$ Pronto):</strong> Acontece quando o evento externo aguardado se concretiza (ex: a entrada de dados chega). Se não houver outro processo em execução, a transição 3 pode ocorrer imediatamente após.</li></ol><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>O Papel do Escalonador</span></div><div class=callout-content><p>O escalonamento — a decisão de quem executa, quando e por quanto tempo — é vital para o equilíbrio do sistema. Algoritmos complexos são desenvolvidos para garantir tanto a eficiência global (uso da CPU) quanto a justiça individual (nenhum processo fica estagnado).</p></div></div><p>Essa abstração permite visualizar o sistema operacional em camadas. No nível mais baixo, temos o escalonador, que oculta os detalhes complexos de interrupções e gerenciamento de hardware (disco, fita, terminais). Acima dele, reside uma variedade de processos de usuário e de sistema.</p><img src=static/fig2_3_modelo_escalonador.png width=50%><p>Conforme demonstrado na figura acima, quando ocorre uma interrupção (como a leitura de um disco concluída), o sistema não precisa lidar com "interrupções cruas" o tempo todo, mas sim gerenciar estados de processos. O processo que aguardava o disco (estado Bloqueado) é movido para o estado Pronto (transição 4), tornando-se elegível para execução novamente. Esse modelo transforma a complexidade do hardware em um fluxo lógico de processos bloqueando e desbloqueando.</p><h3 id=implementação-de-processos><span class=heading-text>Implementação de processos</span><span class=heading-arabic>4.1.6</span></h3><p>Para viabilizar o modelo de processos, o sistema operacional mantém uma estrutura de dados centralizada conhecida como tabela de processos, ou Bloco de Controle de Processos (PCB). Esta tabela funciona como um arranjo de registros onde cada entrada é dedicada a um processo específico, armazenando todos os dados necessários para que o sistema possa suspender sua execução e retomá-la posteriormente sem qualquer perda de continuidade.</p><p>Os campos contidos nessa tabela são vitais para a integridade do sistema, abrangendo desde o estado da CPU até o gerenciamento de recursos externos. A organização dessas informações geralmente segue três categorias principais:</p><table><thead><tr><th style=text-align:left>Gerenciamento de Processos</th><th style=text-align:left>Gerenciamento de Memória</th><th style=text-align:left>Gerenciamento de Arquivos</th></tr></thead><tbody><tr><td style=text-align:left>Contador de programa (PC)</td><td style=text-align:left>Ponteiro para segmento de texto</td><td style=text-align:left>Diretório raiz</td></tr><tr><td style=text-align:left>Registradores e Ponteiro de pilha</td><td style=text-align:left>Ponteiro para segmento de dados</td><td style=text-align:left>Descritores de arquivos abertos</td></tr><tr><td style=text-align:left>Estado do processo (Pronto, Bloqueado)</td><td style=text-align:left>Ponteiro para segmento de pilha</td><td style=text-align:left>IDs de usuário e grupo (UID/GID)</td></tr><tr><td style=text-align:left>Prioridade e Parâmetros de escalonamento</td><td style=text-align:left>Limites de memória e proteção</td><td style=text-align:left>Atributos de permissão</td></tr></tbody></table><p>Embora os campos exatos variem entre sistemas operacionais, a Figura 2.4 ilustra os elementos universais necessários para a transparência na troca de contexto.</p><img src=static/fig_2_4_campos_tabela_processos.png width=95%><p>A ilusão de múltiplos processos executando simultaneamente em uma única CPU é sustentada por um mecanismo de hardware e software coordenado. Quando ocorre um evento de entrada ou saída, como uma interrupção de disco, o hardware consulta o vetor de interrupção, um local fixo na memória que aponta para o endereço da rotina de serviço correspondente.</p><p>O hardware realiza o salvamento inicial, empilhando o contador de programa e a palavra de estado do processo (PSW) atual. A partir desse ponto, o software assume o controle através de uma sequência rigorosa:</p><ol><li><strong>Salvamento de Estado:</strong> Uma rotina em linguagem de montagem salva os registradores na entrada da tabela de processos.</li><li><strong>Troca de Pilha:</strong> O ponteiro de pilha é redirecionado para uma pilha temporária do sistema operacional.</li><li><strong>Execução em C:</strong> Uma rotina em linguagem de alto nível (C) processa a lógica específica da interrupção.</li><li><strong>Escalonamento:</strong> O escalonador decide qual processo deve ocupar a CPU a seguir.</li><li><strong>Retomada:</strong> O código em montagem carrega o estado do novo processo escolhido, reiniciando sua execução.</li></ol><p>Este ciclo garante que, embora um processo possa ser interrompido milhares de vezes por segundo, ele sempre retorne exatamente ao estado anterior, mantendo a integridade lógica da computação. O resumo detalhado deste fluxo, desde o hardware até o escalonador, pode ser observado na Figura 2.5.</p><div class="callout callout-important"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Nota Técnica</span></div><div class=callout-content><p>Operações de baixo nível, como a manipulação direta do ponteiro de pilha e o salvamento de registradores específicos, são executadas obrigatoriamente em linguagem de montagem, pois não podem ser expressas de forma nativa e segura em C.</p></div></div><h3 id=modelando-a-multiprogramação><span class=heading-text>Modelando a multiprogramação</span><span class=heading-arabic>4.1.7</span></h3><p>A utilização da CPU pode ser significativamente aperfeiçoada através do uso da multiprogramação. De maneira direta, se um processo médio realiza computações apenas 20% do tempo em que reside na memória, a presença de cinco processos simultâneos deveria, teoricamente, manter a CPU ocupada o tempo todo. Entretanto, esse modelo inicial é irrealisticamente otimista, pois presume tacitamente que todos os processos jamais estarão aguardando por uma entrada ou saída (E/S) ao mesmo tempo.</p><p>Um modelo mais refinado examina o uso da CPU sob um ponto de vista probabilístico. Supondo que um processo passe uma fração $p$ de seu tempo esperando pela conclusão de dispositivos de E/S, e havendo $n$ processos na memória, a probabilidade de todos os processos estarem em espera simultânea, momento em que a CPU ficaria ociosa, é $p^n$. A partir disso, a eficiência do sistema é calculada:</p><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Fórmula de Utilização da CPU</span></div><div class=callout-content><p>A utilização da CPU é dada pela fórmula: $Utilização = 1 - p^n$. Onde <strong>n</strong> representa o grau de multiprogramação.</p></div></div><p>Este comportamento é detalhado na figura a seguir, que ilustra a utilização como uma função do número de processos:</p><img src=static/fig2_6_utilizacao_cpu.png width=60%><p>Observando os dados, fica claro que se os processos passam 80% do tempo em espera de E/S, são necessários pelo menos 10 processos na memória para que o desperdício da CPU seja inferior a 10%. É importante notar que tempos de espera de 80% ou mais são comuns, tanto em processos interativos, que aguardam cliques ou entradas de teclado, quanto em servidores que realizam intensas operações de disco.</p><p>Embora o modelo probabilístico seja uma aproximação e presuma que os processos são independentes, o que nem sempre ocorre em sistemas de CPU única onde processos prontos precisam esperar o processador ser liberado, ele ainda é válido para demonstrar como a multiprogramação ocupa a CPU em momentos de ócio. O funcionamento interno desse sistema, especialmente quando ocorrem interrupções que permitem a troca de processos, segue uma sequência rigorosa de hardware e software:</p><table><thead><tr><th style=text-align:left>Ordem</th><th style=text-align:left>Etapa do Processamento de Interrupção</th><th style=text-align:left>Descrição Técnica</th></tr></thead><tbody><tr><td style=text-align:left><strong>1</strong></td><td style=text-align:left>Empilhamento de Hardware</td><td style=text-align:left>O hardware empilha o contador de programa e outros estados essenciais.</td></tr><tr><td style=text-align:left><strong>2</strong></td><td style=text-align:left>Carga do Contador</td><td style=text-align:left>O hardware carrega o novo contador de programa a partir do arranjo de interrupções.</td></tr><tr><td style=text-align:left><strong>3</strong></td><td style=text-align:left>Salvamento de Registradores</td><td style=text-align:left>Um procedimento em linguagem de montagem salva o estado atual dos registradores.</td></tr><tr><td style=text-align:left><strong>4</strong></td><td style=text-align:left>Configuração de Pilha</td><td style=text-align:left>Ocorre a configuração de uma nova pilha de execução para o serviço.</td></tr><tr><td style=text-align:left><strong>5</strong></td><td style=text-align:left>Serviço em C</td><td style=text-align:left>O serviço de interrupção em C executa, lendo e armazenando a entrada temporariamente.</td></tr><tr><td style=text-align:left><strong>6</strong></td><td style=text-align:left>Escalonamento</td><td style=text-align:left>O escalonador decide qual será o próximo processo a entrar em execução.</td></tr><tr><td style=text-align:left><strong>7</strong></td><td style=text-align:left>Retorno ao Assembly</td><td style=text-align:left>O procedimento em C retorna o controle para o código de baixo nível.</td></tr><tr><td style=text-align:left><strong>8</strong></td><td style=text-align:left>Início do Processo</td><td style=text-align:left>O procedimento em linguagem de montagem inicia o novo processo atual.</td></tr></tbody></table><p>Este modelo permite realizar previsões específicas sobre o desempenho. Considere um computador com 8 GB de memória, onde o sistema operacional e suas tabelas ocupam 2 GB e cada programa de usuário também ocupa 2 GB. Esta configuração permite três programas simultâneos. Com uma espera de E/S de 80%, a utilização da CPU é de $1 - 0,8^3$, aproximadamente 49%. Ao dobrar a memória para 16 GB, o grau de multiprogramação sobe para sete processos, elevando a utilização para 79%, um ganho de 30% na eficiência. Uma nova adição de 8 GB elevaria a utilização para 91%, um incremento de apenas 12%, o que permite ao gestor decidir se o investimento adicional em hardware é economicamente viável frente ao ganho marginal de desempenho.</p><h2 id=threads><span class=heading-text>Threads</span><span class=heading-arabic>4.2</span></h2><p>Diferente dos sistemas operacionais tradicionais, onde cada processo possui apenas um espaço de endereçamento e um único fluxo de execução, as arquiteturas modernas permitem a existência de múltiplos threads de controle compartilhando o mesmo ambiente de memória. Essa estrutura possibilita que diversas tarefas operem em quase paralelo, funcionando como processos independentes que, contudo, dividem os mesmos recursos e dados. A implementação desse modelo otimiza a performance e a organização do software, permitindo que diferentes partes de um programa executem simultaneamente sem o isolamento total imposto por processos distintos.</p><h3 id=utilização-de-threads><span class=heading-text>Utilização de threads</span><span class=heading-arabic>4.2.1</span></h3><p>Para viabilizar o modelo de processos, o sistema operacional mantém uma estrutura de dados centralizada conhecida como tabela de processos, ou Bloco de Controle de Processos (PCB), que funciona como um arranjo de registros onde cada entrada é dedicada a um processo específico. Essas entradas armazenam dados cruciais para que o sistema possa suspender a execução e retomá-la sem perda de continuidade, incluindo o contador de programa, ponteiros de pilha e o estado dos arquivos abertos. A organização dessas informações geralmente segue categorias fundamentais para a integridade do sistema, conforme detalhado na tabela abaixo:</p><table><thead><tr><th style=text-align:left>Gerenciamento de Processos</th><th style=text-align:left>Gerenciamento de Memória</th><th style=text-align:left>Gerenciamento de Arquivos</th></tr></thead><tbody><tr><td style=text-align:left>Contador de programa (PC)</td><td style=text-align:left>Ponteiro para segmento de texto</td><td style=text-align:left>Diretório raiz</td></tr><tr><td style=text-align:left>Registradores e Pilha</td><td style=text-align:left>Ponteiro para segmento de dados</td><td style=text-align:left>Descritores de arquivos</td></tr><tr><td style=text-align:left>Estado do processo</td><td style=text-align:left>Limites de memória e proteção</td><td style=text-align:left>Permissões (UID/GID)</td></tr></tbody></table><p>A ilusão de múltiplos processos simultâneos em uma única CPU é sustentada por um mecanismo coordenado entre hardware e software. Quando ocorre uma interrupção, como uma operação de disco, o hardware consulta o vetor de interrupção e empilha a palavra de estado do processo atual. A partir disso, uma rotina em linguagem de montagem salva os registradores na tabela de processos e configura uma pilha temporária para que o serviço de interrupção em C possa executar. Após o processamento, o escalonador decide qual será o próximo processo, e o controle retorna ao código em montagem para carregar o novo estado. Este ciclo garante que, mesmo interrompido milhares de vezes, o processo retorne ao estado preciso em que se encontrava, conforme ilustrado no esquema de fluxo abaixo:</p><img src=static/fig_2_5_esqueleto_interrupcao.png width=50%><p>Diferente do isolamento total dos processos, as threads surgem como "miniprocessos" que compartilham o mesmo espaço de endereçamento. Enquanto um processo tradicional tem um único thread de controle, aplicações modernas utilizam múltiplos threads para realizar atividades simultâneas de forma mais simples e rápida. Criar uma thread pode ser de 10 a 100 vezes mais veloz do que criar um processo, o que é vital quando a demanda muda dinamicamente. Um exemplo clássico é o processador de texto, que utiliza threads distintas para interagir com o usuário, reformatar o documento em segundo plano e realizar backups periódicos no disco.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Exemplo de Servidor Web</span></div><div class=callout-content><p>Em um servidor, um thread despachante lê as requisições e as passa para threads operários ociosos. Se um operário precisa buscar algo no disco, ele é bloqueado, mas os outros continuam trabalhando, permitindo que a CPU processe outras demandas em vez de ficar ociosa.</p></div></div><p>A escolha do modelo de implementação impacta diretamente o desempenho e a facilidade de desenvolvimento. Enquanto o modelo de thread única é simples, porém lento por bloquear a CPU em cada operação de E/S, o modelo multithread retém a simplicidade das chamadas bloqueantes com alto desempenho. Existe ainda a abordagem de máquina de estados finitos, que utiliza chamadas não bloqueantes e interrupções, alcançando alta performance ao custo de uma programação extremamente complexa, onde o estado deve ser salvo manualmente a cada transição.</p><p>O uso de threads também é essencial em sistemas com múltiplas CPUs, onde o paralelismo real é atingido. Em aplicações de processamento de dados intensivo, o uso de threads de entrada, processamento e saída permite que todas as etapas ocorram simultaneamente, desde que as chamadas de sistema bloqueiem apenas a thread solicitante, preservando a execução das demais entidades dentro do mesmo processo.</p><h3 id=o-modelo-de-thread-clássico><span class=heading-text>O modelo de thread clássico</span><span class=heading-arabic>4.2.2</span></h3><p>O modelo de processo fundamenta-se em dois pilares independentes: o agrupamento de recursos e a execução. Enquanto os processos são utilizados para organizar recursos relacionados, como espaços de endereçamento, arquivos abertos e tratadores de sinais, as threads são as entidades efetivamente escalonadas para execução na CPU. Ao separar esses conceitos, permitimos que múltiplas linhas de execução ocorram no mesmo ambiente de maneira cooperativa, transformando o que antes era um processo pesado em uma estrutura de multithread, onde cada thread funciona como um "processo leve".</p><p>Diferente de processos independentes que compartilham recursos físicos como discos e impressoras, threads dentro de um mesmo processo compartilham o mesmo espaço de endereçamento e variáveis globais. Isso significa que não há proteção de memória entre elas: uma thread pode ler ou escrever na pilha de outra. Essa ausência de barreiras é intencional, partindo do princípio de que os threads de um mesmo usuário foram criados para colaborar em uma tarefa comum, e não para competir. A distinção visual entre processos tradicionais e um processo multithread é apresentada a seguir:</p><p>A gestão dessas entidades exige que cada thread mantenha seu próprio estado de execução para garantir a independência lógica. A tabela abaixo detalha quais itens são mantidos de forma global (por processo) e quais são estritamente individuais (por thread):</p><table><thead><tr><th style=text-align:left>Itens Compartilhados (Por Processo)</th><th style=text-align:left>Itens Individuais (Por Thread)</th></tr></thead><tbody><tr><td style=text-align:left>Espaço de endereçamento e variáveis globais</td><td style=text-align:left>Contador de programa (PC)</td></tr><tr><td style=text-align:left>Arquivos abertos e processos filhos</td><td style=text-align:left>Registradores da CPU</td></tr><tr><td style=text-align:left>Alarmes e sinais pendentes</td><td style=text-align:left>Pilha de execução (Stack)</td></tr><tr><td style=text-align:left>Informações de contabilidade e estatísticas</td><td style=text-align:left>Estado (Execução, Pronto, Bloqueado)</td></tr></tbody></table><p>Cada thread possui sua própria pilha, que armazena o histórico de rotinas chamadas, variáveis locais e endereços de retorno, conforme ilustrado na figura:</p><img src=static/fig_2_13_pilhas_threads.png width=50%><p>No ciclo de vida de uma aplicação multithread, o processo geralmente inicia com um único thread, que pode gerar novos fluxos através de chamadas de biblioteca como <code>thread_create</code>. Uma vez criados, os threads podem terminar sua execução com <code>thread_exit</code> ou aguardar a finalização de outros via <code>thread_join</code>. Um comando essencial neste modelo é o <code>thread_yield</code>, que permite a um thread abrir mão voluntariamente da CPU. Como muitas vezes não há uma interrupção de relógio forçada para threads como ocorre com processos, essa "cortesia" é fundamental para o paralelismo aparente em sistemas de CPU única.</p><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Complicações de Programação</span></div><div class=callout-content><p>O uso de threads introduz desafios significativos de projeto. Por exemplo, se um thread fecha um arquivo enquanto outro ainda realiza uma leitura, ou se dois threads tentam alocar memória simultaneamente, o sistema pode entrar em estado inconsistente. Além disso, operações como o <code>fork</code> em sistemas UNIX tornam-se complexas: deve o processo filho herdar todos os threads do pai ou apenas o que executou a chamada?</p></div></div><p>Em uma CPU única, o sistema alterna rapidamente entre os threads, criando a ilusão de execução paralela. Se houver três threads limitados pela CPU, cada um parecerá rodar em um processador com um terço da velocidade real. No entanto, o benefício real surge na sobreposição de tarefas de computação e E/S, onde um thread pode continuar ativo enquanto outro aguarda uma resposta do hardware.</p><h3 id=threads-posix><span class=heading-text>Threads POSIX</span><span class=heading-arabic>4.2.3</span></h3><p>Para possibilitar que se escrevam programas com threads portáteis, o IEEE definiu o padrão 1003.1c, conhecido popularmente como Pthreads. A maioria dos sistemas UNIX dá suporte a este pacote, que define mais de 60 chamadas de função para gerenciar o ciclo de vida e o comportamento das threads. Cada thread no modelo POSIX possui propriedades exclusivas, incluindo um identificador, um conjunto de registradores (como o contador de programa) e uma estrutura de atributos que define o tamanho da pilha e os parâmetros de escalonamento. O gerenciamento desses fluxos é realizado através de funções fundamentais que coordenam a criação e a finalização das tarefas, conforme detalhado na tabela abaixo:</p><table><thead><tr><th style=text-align:left>Chamada de Thread</th><th style=text-align:left>Descrição Técnica da Operação</th></tr></thead><tbody><tr><td style=text-align:left><strong>Pthread_create</strong></td><td style=text-align:left>Cria um novo thread e retorna seu identificador, de forma análoga ao PID de um processo.</td></tr><tr><td style=text-align:left><strong>Pthread_exit</strong></td><td style=text-align:left>Conclui a execução do thread atual e libera os recursos de sua pilha.</td></tr><tr><td style=text-align:left><strong>Pthread_join</strong></td><td style=text-align:left>Bloqueia o thread chamador até que um thread específico finalize sua execução.</td></tr><tr><td style=text-align:left><strong>Pthread_yield</strong></td><td style=text-align:left>Libera voluntariamente a CPU para que outro thread possa ser executado.</td></tr><tr><td style=text-align:left><strong>Pthread_attr_init</strong></td><td style=text-align:left>Cria e inicializa uma estrutura de atributos com valores padrão para o thread.</td></tr><tr><td style=text-align:left><strong>Pthread_attr_destroy</strong></td><td style=text-align:left>Remove a estrutura de atributos da memória sem afetar os threads que já a utilizam.</td></tr></tbody></table><p>A criação de um thread com <code>pthread_create</code> é intencionalmente semelhante à chamada de sistema <code>fork</code>, servindo o identificador de thread para referenciar a entidade em outras chamadas. Uma distinção importante entre processos e threads reside na cooperação: enquanto processos são competitivos e buscam o máximo de tempo de CPU, threads de um mesmo processo são colaborativas, uma vez que são escritas pelo mesmo programador para atingir um objetivo comum. Por essa razão, a chamada <code>pthread_yield</code> é essencial, permitindo que um thread "educado" abra mão do processador em favor de outro. Abaixo, observa-se a lógica de implementação em C para a criação de múltiplos threads simultâneos:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;pthread.h>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define NUMBER_OF_THREADS 10

void *print_hello_world(void *tid) {
    /* Esta funcao imprime o identificador do thread e sai. */
    printf("Ola mundo. Boas vindas do thread %d\n", tid);
    pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
    pthread_t threads[NUMBER_OF_THREADS];
    int status, i;
    for(i=0; i &lt; NUMBER_OF_THREADS; i++) {
        printf("Metodo Main. Criando thread %d\n", i);
        status = pthread_create(&threads[i], NULL, print_hello_world, (void *)i);
        if (status != 0) {
            printf("Erro: pthread_create retornou o codigo %d\n", status);
            exit(-1);
        }
    }
    exit(NULL);
}
</code></pre><p>No exemplo acima, o programa principal cria dez threads que anunciam sua existência. É fundamental notar que a ordem das mensagens impressas é indeterminada e pode variar a cada execução, pois depende de como o escalonador do sistema operacional distribui o tempo de CPU entre os threads prontos. Além das funções de ciclo de vida, o padrão Pthreads oferece mecanismos robustos para gerenciar atributos de prioridade e segurança, garantindo que a execução paralela seja tanto eficiente quanto previsível dentro do ambiente compartilhado do processo.</p><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Gestão de Atributos</span></div><div class=callout-content><p>O uso de <code>pthread_attr_init</code> permite que o desenvolvedor ajuste finamente o comportamento de cada thread antes mesmo de sua criação, definindo, por exemplo, se o thread deve começar em um estado "destacado" (detached), onde seus recursos são reciclados automaticamente após o término sem a necessidade de um <code>pthread_join</code>.</p></div></div><h3 id=implementando-threads-no-espaço-do-usuário><span class=heading-text>Implementando threads no espaço do usuário</span><span class=heading-arabic>4.2.4</span></h3><p>Existem duas abordagens principais para a implementação de threads: no espaço do usuário e no núcleo, sendo a escolha entre elas um tema clássico na arquitetura de sistemas operacionais. Na implementação inteiramente no espaço do usuário, o núcleo desconhece a existência das threads, gerenciando o processo como se possuísse um único fluxo de execução. Esta técnica utiliza uma biblioteca de tempo de execução (<em>runtime system</em>) que atua como um supervisor local, gerenciando uma tabela de threads privada para cada processo. Essa tabela armazena estados vitais, como o contador de programa, registradores e ponteiro de pilha, funcionando de forma análoga à tabela de processos do núcleo, porém em um nível hierárquico superior, conforme ilustrado na figura a seguir:</p><img src=static/fig_2_16a_threads_usuario.png width=40%><p>A principal vantagem deste método é a eficiência extrema no chaveamento de contexto. Como o escalonamento ocorre via chamadas de rotinas locais, não há necessidade de gerar uma armadilha (<em>trap</em>) para o núcleo, nem de esvaziar caches de memória ou realizar trocas de contexto pesadas no hardware. Se a CPU possuir instruções específicas para salvar e carregar registradores, a troca entre threads pode ser ordens de magnitude mais rápida do que uma chamada de sistema. Além disso, as threads de usuário permitem que cada processo adote seu próprio algoritmo de escalonamento customizado e possuem maior escalabilidade, visto que não consomem o limitado espaço de tabela do núcleo.</p><p>No entanto, essa arquitetura enfrenta obstáculos significativos, especialmente em relação às chamadas de sistema bloqueantes. Se um thread realiza uma operação de leitura de teclado e o núcleo bloqueia o processo inteiro por falta de dados, todos os outros threads daquele processo ficam paralisados, anulando um dos maiores benefícios do multithreading. Para mitigar isso, utilizam-se técnicas de verificação prévia, como o uso de códigos envolventes (<em>jackets</em> ou <em>wrappers</em>):</p><div class="callout callout-important"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>O Uso de Wrappers e Select</span></div><div class=callout-content><p>Para evitar o bloqueio total, a biblioteca pode substituir uma chamada de sistema <code>read</code> por um <em>wrapper</em> que utiliza a função <code>select</code>. Esta função verifica se a operação será bloqueada; em caso positivo, o sistema de tempo de execução suspende o thread localmente e passa a CPU para outro thread pronto, sem nunca invocar a interrupção do núcleo de forma perigosa.</p></div></div><p>Além do bloqueio por E/S, as threads de usuário sofrem com o problema das faltas de página (<em>page faults</em>): se uma instrução acessada não estiver na memória física, o núcleo suspende o processo completo até que o dado seja buscado no disco, ignorando que outros threads poderiam continuar executando. Outro desafio é a ausência de interrupções de relógio dentro de um processo; se um thread entra em um laço infinito ou não utiliza voluntariamente o <code>thread_yield</code>, ele monopoliza a CPU indefinidamente, impedindo o escalonamento circular (<em>round-robin</em>).</p><table><thead><tr><th style=text-align:left>Vantagens do Espaço do Usuário</th><th style=text-align:left>Desvantagens do Espaço do Usuário</th></tr></thead><tbody><tr><td style=text-align:left>Alta performance no chaveamento (sem trap para o núcleo).</td><td style=text-align:left>Uma única chamada bloqueante para o núcleo para o processo todo.</td></tr><tr><td style=text-align:left>Portabilidade para sistemas sem suporte nativo a threads.</td><td style=text-align:left>Faltas de página bloqueiam todos os threads do processo.</td></tr><tr><td style=text-align:left>Escalonamento customizado por aplicação.</td><td style=text-align:left>Necessidade de cooperação voluntária para liberar a CPU.</td></tr><tr><td style=text-align:left>Maior escalabilidade para grandes quantidades de threads.</td><td style=text-align:left>Dificuldade em aproveitar aplicações limitadas pela CPU.</td></tr></tbody></table><p>Por fim, o argumento mais crítico contra as threads de usuário reside na sua aplicação prática: programadores utilizam threads justamente em softwares que realizam E/S frequente, como servidores web. Se o sistema exige verificações constantes e complexas para evitar bloqueios, muitas vezes torna-se mais eficiente delegar essa gestão diretamente ao núcleo, que já possui o controle natural sobre as interrupções de hardware e o estado dos processos.</p><h3 id=implementando-threads-no-núcleo><span class=heading-text>Implementando threads no núcleo</span><span class=heading-arabic>4.2.5</span></h3><p>Diferente do modelo anterior, na implementação de threads no núcleo, o sistema operacional tem plena ciência da existência de cada thread e as gerencia diretamente. Nessa arquitetura, não é necessário um sistema de tempo de execução (<em>runtime</em>) em cada processo, nem uma tabela de threads privada no espaço do usuário. Em vez disso, o núcleo mantém uma tabela mestre que controla todos os threads do sistema, conforme ilustrado na figura a seguir:</p><img src=static/fig_2_16b_threads_nucleo.png width=30%><p>Quando um thread precisa ser criado ou destruído, o processo realiza uma chamada de sistema (trap) para o núcleo, que atualiza sua tabela interna. Esta tabela armazena os registradores, o estado e o contexto de cada thread, funcionando como um subconjunto das informações que o núcleo já mantém na tabela de processos tradicional. A principal vantagem dessa abordagem é a capacidade de resposta a eventos de bloqueio:</p><ul><li><strong>Gerenciamento de Bloqueio:</strong> Se um thread realiza uma chamada de sistema bloqueante, o núcleo pode suspender esse thread e escolher imediatamente outro thread do mesmo processo (ou de um processo diferente) para executar.</li><li><strong>Tratamento de Faltas de Página:</strong> Caso um thread cause uma falta de página (<em>page fault</em>), o núcleo não bloqueia o processo inteiro. Ele pode verificar se existem outros threads executáveis no mesmo processo e escaloná-los enquanto a página é buscada no disco.</li></ul><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Reciclagem de Threads</span></div><div class=callout-content><p>Devido ao custo mais elevado de criação e destruição no nível do núcleo, muitos sistemas utilizam a técnica de reciclagem. Em vez de descartar as estruturas de dados quando um thread termina, o núcleo apenas o marca como não executável. Quando um novo thread é solicitado, a estrutura antiga é reativada, economizando tempo de processamento.</p></div></div><p>Embora resolva problemas de bloqueio e não exija chamadas não bloqueantes complexas, o modelo de núcleo possui desvantagens significativas em termos de desempenho. Cada operação de thread (criação, término ou sincronização) exige uma chamada de sistema, que é consideravelmente mais cara do que uma simples chamada de biblioteca no espaço do usuário. Além disso, problemas lógicos complexos permanecem, conforme detalhado na tabela abaixo:</p><table><thead><tr><th style=text-align:left>Problema de Projeto</th><th style=text-align:left>Descrição da Complicação</th></tr></thead><tbody><tr><td style=text-align:left><strong>Bifurcação (Fork)</strong></td><td style=text-align:left>Se um processo com 10 threads é bifurcado, o novo processo deve herdar todos os 10 ou apenas um? A resposta depende se o novo processo executará um novo programa (<code>exec</code>) ou continuará o código atual.</td></tr><tr><td style=text-align:left><strong>Gerenciamento de Sinais</strong></td><td style=text-align:left>Sinais são enviados ao processo. O núcleo deve decidir qual thread específico receberá o sinal ou se todos devem ser notificados simultaneamente.</td></tr><tr><td style=text-align:left><strong>Sobrecarga (Overhead)</strong></td><td style=text-align:left>O custo de mudar o contexto entre threads exige a troca de privilégio para o modo núcleo, o que consome mais ciclos de CPU.</td></tr></tbody></table><p>Dessa forma, a implementação no núcleo oferece maior robustez e paralelismo real para aplicações com muita E/S, mas exige que o programador e o arquiteto de sistemas ponderem o custo das chamadas de sistema frequentes.</p><h3 id=implementações-híbridas><span class=heading-text>Implementações híbridas</span><span class=heading-arabic>4.2.6</span></h3><p>Diversas arquiteturas foram investigadas com o objetivo de unir a alta performance das threads de usuário à robustez e ao paralelismo das threads de núcleo. A solução mais proeminente é o modelo híbrido, que utiliza threads de núcleo como unidades de execução base e multiplexa threads de usuário sobre elas. Essa abordagem permite que o programador determine de forma flexível a proporção entre threads de núcleo e threads de usuário, otimizando o sistema conforme a necessidade da aplicação.</p><p>Neste modelo, o núcleo do sistema operacional enxerga e escalona apenas as threads de núcleo. Sobre cada uma delas, podem existir múltiplas threads de usuário que são criadas, destruídas e escalonadas por um sistema de tempo de execução local, operando de forma idêntica ao modelo de espaço de usuário puro. Cada thread de núcleo atua como uma "CPU virtual" para um conjunto específico de threads de usuário que se revezam para utilizá-la.</p><p>A tabela a seguir resume como as responsabilidades são divididas e os benefícios gerados por essa arquitetura:</p><table><thead><tr><th style=text-align:left>Componente</th><th style=text-align:left>Função no Modelo Híbrido</th><th style=text-align:left>Vantagem Proporcionada</th></tr></thead><tbody><tr><td style=text-align:left><strong>Threads de Núcleo</strong></td><td style=text-align:left>Servem como portadores físicos para a execução e lidam com bloqueios de E/S.</td><td style=text-align:left>Se uma thread bloqueia, o núcleo pode escalonar outra thread de núcleo para manter o processo ativo.</td></tr><tr><td style=text-align:left><strong>Threads de Usuário</strong></td><td style=text-align:left>Gerenciadas pela biblioteca da aplicação para tarefas leves e rápidas.</td><td style=text-align:left>Permite a criação de milhares de fluxos de controle com baixíssimo custo de memória e processamento.</td></tr><tr><td style=text-align:left><strong>Multiplexação</strong></td><td style=text-align:left>Associa dinamicamente threads de usuário às threads de núcleo disponíveis.</td><td style=text-align:left>Proporciona flexibilidade máxima, permitindo o paralelismo real em máquinas multiprocessadas.</td></tr></tbody></table><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Flexibilidade de Design</span></div><div class=callout-content><p>Este modelo, às vezes chamado de modelo <strong>m:n</strong>, permite que o desenvolvedor tenha o melhor de dois mundos: o chaveamento instantâneo entre threads de usuário quando não há bloqueios e a garantia de que o processo não paralisará completamente quando uma operação de sistema for necessária.</p></div></div><img src=static/fig_2_17_modelo_hibrido.png width=50%><p>Dessa forma, as implementações híbridas eliminam a rigidez dos modelos puros. Se uma aplicação possui muitas tarefas pequenas e rápidas, ela pode usar poucas threads de núcleo para muitas de usuário; se a aplicação exige muita comunicação com o hardware, a proporção pode ser ajustada para garantir que sempre haja um caminho de execução disponível no núcleo.</p><h3 id=ativações-pelo-escalonador><span class=heading-text>Ativações pelo escalonador</span><span class=heading-arabic>4.2.7</span></h3><p>As ativações pelo escalonador surgem como uma proposta para unificar a eficiência das threads de usuário com a funcionalidade robusta das threads de núcleo. O objetivo central é permitir que um processo gerencie suas próprias threads no espaço do usuário, mas mantenha a capacidade de reagir a eventos de bloqueio (como faltas de página ou chamadas de sistema) sem paralisar o processo inteiro. Para isso, o núcleo delega a execução a "processadores virtuais", permitindo que o sistema de tempo de execução aloque threads para eles de forma dinâmica e independente.</p><p>O diferencial técnico desta abordagem é a inversão do fluxo de comunicação tradicional através de um mecanismo chamado <strong>upcall</strong>. Em sistemas convencionais, o espaço do usuário solicita serviços ao núcleo; nas ativações pelo escalonador, o núcleo toma a iniciativa de notificar o sistema de tempo de execução sobre eventos relevantes. Este fluxo operacional segue uma lógica específica:</p><ol><li><strong>Bloqueio e Notificação:</strong> Quando um thread é bloqueado (por uma chamada de sistema ou falta de página), o núcleo interrompe a execução e "sobe" para o espaço do usuário, ativando o sistema de tempo de execução em um endereço conhecido.</li><li><strong>Transferência de Contexto:</strong> O núcleo passa para a pilha do sistema de tempo de execução o número do thread afetado e a descrição do evento.</li><li><strong>Reescalonamento Local:</strong> O sistema de tempo de execução marca o thread como bloqueado e imediatamente coloca outro thread pronto para rodar no processador virtual disponível.</li><li><strong>Notificação de Desbloqueio:</strong> Assim que a causa do bloqueio é resolvida (ex: o dado chegou do disco), o núcleo realiza um novo upcall, informando que o thread original pode ser reiniciado ou colocado na lista de prontos.</li></ol><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Violação de Camadas</span></div><div class=callout-content><p>Uma crítica comum a este modelo é que o uso de upcalls viola o princípio de design de sistemas em camadas. Tradicionalmente, camadas superiores chamam as inferiores, mas as inferiores nunca deveriam invocar rotinas nas superiores. O upcall quebra essa hierarquia ao fazer o núcleo (camada inferior) chamar o espaço do usuário (camada superior).</p></div></div><p>A eficiência desse modelo reside na redução de transições desnecessárias entre os modos de operação. Se um thread precisa esperar por outro dentro do mesmo processo, o sistema de tempo de execução resolve a sincronização internamente, sem qualquer intervenção do núcleo. Caso ocorra uma interrupção de hardware que interesse ao processo, o núcleo suspende o thread atual e inicia o sistema de tempo de execução naquela CPU virtual, permitindo que a própria aplicação decida qual thread é prioritário no momento.</p><table><thead><tr><th style=text-align:left>Característica</th><th style=text-align:left>Threads de Usuário Puras</th><th style=text-align:left>Threads de Núcleo Puras</th><th style=text-align:left>Ativações pelo Escalonador</th></tr></thead><tbody><tr><td style=text-align:left><strong>Desempenho</strong></td><td style=text-align:left>Altíssimo (local)</td><td style=text-align:left>Lento (chamada de sistema)</td><td style=text-align:left>Alto (híbrido)</td></tr><tr><td style=text-align:left><strong>Bloqueio de E/S</strong></td><td style=text-align:left>Bloqueia o processo todo</td><td style=text-align:left>Bloqueia apenas o thread</td><td style=text-align:left>Bloqueia apenas o thread</td></tr><tr><td style=text-align:left><strong>Falta de Página</strong></td><td style=text-align:left>Para o processo todo</td><td style=text-align:left>Gerenciada pelo núcleo</td><td style=text-align:left>Gerenciada via Upcall</td></tr><tr><td style=text-align:left><strong>Complexidade</strong></td><td style=text-align:left>Baixa</td><td style=text-align:left>Média</td><td style=text-align:left>Alta (exige upcalls)</td></tr></tbody></table><p>Este mecanismo oferece o máximo de flexibilidade em sistemas multiprocessados, onde o número de CPUs virtuais pode ser ajustado conforme a carga de trabalho do processo. Apesar da complexidade de implementação, o ganho de desempenho em aplicações que realizam muitas operações de entrada e saída é considerável.</p><h3 id=threads-pop-up><span class=heading-text>Threads pop-up</span><span class=heading-arabic>4.2.8</span></h3><p>Em sistemas distribuídos, a eficiência no tratamento de mensagens e requisições de serviço é vital. A abordagem convencional utiliza um processo ou thread permanentemente bloqueado em uma chamada de sistema <code>receive</code>, aguardando a chegada de dados. No entanto, uma alternativa altamente eficiente para reduzir a latência de processamento é o uso de <strong>threads pop-up</strong>, onde a própria chegada de uma mensagem dispara a criação imediata de um novo fluxo de execução.</p><p>Diferente das threads tradicionais, uma thread pop-up não possui histórico prévio, como estados de registradores ou pilhas que precisem ser restaurados. Cada thread "nasce" limpa e idêntica às demais, o que permite que o sistema a instancie com velocidade máxima para processar a mensagem recém-chegada. O ciclo de criação é ilustrado a seguir:</p><p>A utilização desta técnica exige decisões arquiteturais estratégicas, especialmente sobre o contexto de execução da thread. A tabela abaixo compara as implicações de executar threads pop-up em diferentes espaços:</p><table><thead><tr><th style=text-align:left>Contexto de Execução</th><th style=text-align:left>Vantagens</th><th style=text-align:left>Riscos e Desvantagens</th></tr></thead><tbody><tr><td style=text-align:left><strong>Espaço do Núcleo (Kernel)</strong></td><td style=text-align:left>Acesso direto a tabelas do sistema e dispositivos de E/S; criação mais rápida.</td><td style=text-align:left>Um erro no código da thread (ex: laço infinito) pode comprometer todo o sistema ou causar perda de dados.</td></tr><tr><td style=text-align:left><strong>Espaço do Usuário</strong></td><td style=text-align:left>Maior segurança e isolamento; erros na thread não derrubam o núcleo.</td><td style=text-align:left>Ligeiramente mais lento devido à necessidade de troca de contexto e proteção de memória.</td></tr></tbody></table><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Ganho de Latência</span></div><div class=callout-content><p>O principal benefício da thread pop-up é o encurtamento do tempo entre a recepção física do pacote na rede e o início do seu processamento lógico, uma vez que não há necessidade de despertar e restaurar o contexto de uma thread pré-existente que estava "dormindo".</p></div></div><img src=static/fig_2_18_threads_popup.png width=95%><p>Embora poderosas, as threads pop-up demandam um planejamento rigoroso. Como elas operam frequentemente em ambientes de alta concorrência e podem ser executadas no núcleo, é fundamental garantir que o código de tratamento seja conciso e libere a CPU rapidamente para evitar gargalos no recebimento de novas mensagens.</p><h3 id=convertendo-código-de-um-thread-em-código-multithread><span class=heading-text>Convertendo código de um thread em código multithread</span><span class=heading-arabic>4.2.9</span></h3><p>A transição de programas concebidos para processos monothread para o modelo de múltiplas threads é uma tarefa consideravelmente complexa, pois envolve armadilhas que podem comprometer a integridade de dados compartilhados. O problema fundamental reside na coexistência de rotinas que utilizam recursos globais em um mesmo espaço de endereçamento. Um exemplo crítico ocorre com variáveis globais do sistema, como a <code>errno</code> do UNIX, utilizada para reportar erros de chamadas de sistema. Em um cenário multithread, se um thread executa uma operação que falha e, antes de ler o código de erro, ocorre um chaveamento para um segundo thread que também falha, o valor original de <code>errno</code> será sobrescrito, levando o primeiro thread a um comportamento incorreto ao retomar sua execução.</p><p>Para solucionar conflitos de variáveis globais, uma abordagem eficaz é a criação de variáveis globais privadas por thread, conhecidas como <em>Thread-Local Storage</em> (TLS). Isso estabelece um novo nível de escopo: variáveis visíveis para todas as funções de um thread específico, mas isoladas dos demais fluxos, conforme ilustrado na organização de pilhas e memórias globais abaixo:</p><img src=static/fig_2_20_globais_individuais.png width=50%><p>Além do isolamento de variáveis, a conversão enfrenta o desafio das bibliotecas não reentrantes. Muitas rotinas de biblioteca padrão, como o <code>malloc</code> para alocação de memória ou funções de buffer de rede, não foram projetadas para serem chamadas simultaneamente. Se um thread for interrompido enquanto o <code>malloc</code> está atualizando listas encadeadas de memória, deixando-as em um estado inconsistente, e um segundo thread tentar alocar memória, o programa poderá falhar devido ao uso de ponteiros inválidos. Consertar esses problemas exige a reescrita de bibliotecas inteiras para torná-las seguras para threads (<em>thread-safe</em>), ou a implementação de "proteções" (locks) que restringem o acesso às funções, embora esta última solução reduza significativamente o paralelismo potencial do sistema.</p><div class="callout callout-caution"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Gerenciamento de Sinais e Pilhas</span></div><div class=callout-content><p>Sinais e pilhas representam uma complicação adicional. Sinais específicos, como <code>alarm</code>, deveriam ser direcionados ao thread solicitante, mas o núcleo pode não ter ciência da existência das threads para realizar esse direcionamento. Da mesma forma, o crescimento automático da pilha, realizado pelo núcleo em processos tradicionais, torna-se problemático quando existem múltiplas pilhas no mesmo processo que o núcleo não reconhece individualmente.</p></div></div><p>Em suma, a implementação de threads em sistemas existentes requer alterações substanciais que vão além da simples criação de novos fluxos de execução. É necessário redefinir a semântica de chamadas de sistema e garantir que bibliotecas e tratadores de sinais operem de forma previsível no ambiente compartilhado. A compatibilidade com programas legados monothread deve ser mantida como um caso limite, assegurando que o sistema permaneça funcional e estável mesmo sob estas novas demandas de concorrência.</p><h2 id=questões><span class=heading-text>Questões</span><span class=heading-arabic>4.3</span></h2><p><strong>1.</strong> O texto introduz o conceito de "pseudoparalelismo" em contraste com o "verdadeiro paralelismo". Com base nessa distinção e na definição de processo, assinale a alternativa correta:</p><ul><li>A) O pseudoparalelismo ocorre apenas em sistemas multicore, onde cada núcleo executa um processo distinto simultaneamente.</li><li>B) Um processo é uma entidade passiva, análoga a uma receita de bolo, enquanto o programa é a entidade ativa, análoga ao cozinheiro.</li><li>C) O verdadeiro paralelismo refere-se à alternância rápida da CPU entre processos, criando a ilusão de que múltiplos programas rodam ao mesmo tempo.</li><li>D) O pseudoparalelismo é a ilusão de simultaneidade criada por uma única CPU que alterna entre processos em intervalos de milissegundos.</li></ul><p><strong>2.</strong> Considere o modelo probabilístico de utilização da CPU apresentado, onde a utilização é dada pela fórmula $U = 1 - p^n$. Suponha um sistema operacional que gerencie processos com diferentes características de entrada e saída (E/S). Realize os cálculos abaixo:</p><ul><li><strong>a)</strong> Se um processo gasta 50% ($p=0,5$) do seu tempo esperando por E/S, qual é a utilização da CPU se houver 4 processos ($n=4$) na memória?</li><li><strong>b)</strong> Se aumentarmos o grau de multiprogramação para 10 processos ($n=10$) com o mesmo tempo de espera de 50%, qual será a nova utilização da CPU? (Considere $0,5^{10} \approx 0,001$).</li><li><strong>c)</strong> Considere agora processos pesados de E/S que esperam 80% do tempo ($p=0,8$). Calcule a utilização da CPU com 5 processos simultâneos.</li><li><strong>d)</strong> Para os mesmos processos do item 'c' ($p=0,8$), quantos processos (n) são necessários, no mínimo, para garantir que a CPU fique ociosa menos de 10% do tempo? (Dica: Analise o gráfico da Figura 2.6 ou teste valores inteiros para $n$).</li><li><strong>e)</strong> Explique, com base nos resultados acima, por que adicionar memória RAM (permitindo maior grau de multiprogramação) traz retornos decrescentes de performance à medida que a utilização se aproxima de 100%.</li></ul><p><strong>3.</strong> Acerca do diagrama de estados de processos e as transições numeradas. Relacione a transição descrita na Coluna A com a causa técnica correta na Coluna B.</p><table><thead><tr><th style=text-align:left>Coluna A (Transição)</th><th style=text-align:left>Coluna B (Causa Técnica)</th></tr></thead><tbody><tr><td style=text-align:left>(1) Execução $\rightarrow$ Bloqueado</td><td style=text-align:left>( ) O escalonador decide que o processo atual usou tempo suficiente de CPU e deve ceder lugar.</td></tr><tr><td style=text-align:left>(2) Execução $\rightarrow$ Pronto</td><td style=text-align:left>( ) O evento externo aguardado se concretiza (ex: chegada de dados do disco), tornando o processo apto a rodar.</td></tr><tr><td style=text-align:left>(3) Pronto $\rightarrow$ Execução</td><td style=text-align:left>( ) O sistema operacional seleciona este processo da fila para ocupar a CPU.</td></tr><tr><td style=text-align:left>(4) Bloqueado $\rightarrow$ Pronto</td><td style=text-align:left>( ) O processo executa uma chamada de sistema (como <code>pause</code> ou leitura de <code>pipe</code> vazio) e não pode continuar imediatamente.</td></tr></tbody></table><p><strong>4.</strong> Sobre a implementação de threads e a distinção entre itens compartilhados e privados, classifique os elementos abaixo. Marque <strong>(P)</strong> para itens exclusivos de cada Thread e <strong>(C)</strong> para itens Compartilhados por todo o processo.</p><ul><li>( ) Espaço de endereçamento.</li><li>( ) Contador de Programa (PC).</li><li>( ) Arquivos abertos.</li><li>( ) Pilha de execução (Stack).</li><li>( ) Variáveis globais.</li><li>( ) Registradores da CPU.</li></ul><p><strong>5.</strong> A criação de processos difere significativamente entre os sistemas UNIX e Windows. Sobre essas diferenças hierárquicas e de implementação, é correto afirmar:</p><ul><li>A) No UNIX, a chamada <code>fork</code> cria um processo filho que compartilha o mesmo espaço de endereçamento do pai para escrita, sem necessidade de cópia (<em>copy-on-write</em>).</li><li>B) No Windows, existe uma hierarquia rígida onde o pai nunca perde o controle sobre o filho, assemelhando-se a uma árvore genealógica fixa.</li><li>C) No UNIX, todos os processos pertencem a uma árvore única enraizada no processo <em>init</em>, e um pai não pode deserdar seus filhos.</li><li>D) No Windows, a criação de processos é feita em dois passos (criar e carregar), enquanto no UNIX a função <code>CreateProcess</code> realiza tudo em uma única chamada.</li></ul><p><strong>6.</strong> O texto descreve a sequência exata de eventos de hardware e software necessária para lidar com uma interrupção e realizar a troca de processos. Ordene cronologicamente os passos abaixo, do momento da interrupção até a retomada da execução:</p><ul><li>( ) O escalonador escolhe o próximo processo a ser executado.</li><li>( ) O hardware empilha o contador de programa (PC) e a palavra de estado (PSW).</li><li>( ) Uma rotina em linguagem de montagem salva os registradores gerais na tabela de processos.</li><li>( ) O procedimento em C executa o serviço da interrupção (ex: leitura de dados).</li><li>( ) A rotina em linguagem de montagem carrega os registradores e o estado do novo processo escolhido.</li></ul><p><strong>7.</strong> Compare as implementações de threads no <strong>Espaço do Usuário</strong> versus <strong>Espaço do Núcleo</strong>. Assinale a alternativa que descreve corretamente uma vantagem ou desvantagem exclusiva do modelo citado:</p><ul><li>A) <strong>Espaço do Usuário:</strong> Vantagem de permitir que uma única chamada de sistema bloqueante (ex: leitura de teclado) paralise apenas a thread solicitante, e não o processo todo.</li><li>B) <strong>Espaço do Núcleo:</strong> Desvantagem de ter um alto custo de desempenho para criação e destruição de threads devido à necessidade de chamadas de sistema (traps).</li><li>C) <strong>Espaço do Usuário:</strong> Desvantagem de exigir traps para o núcleo a cada troca de contexto entre threads, tornando o chaveamento lento.</li><li>D) <strong>Espaço do Núcleo:</strong> Vantagem de permitir escalonamento customizado por aplicação, já que o núcleo não interfere na política de threads.</li></ul><p><strong>8.</strong> O mecanismo de "Ativações pelo Escalonador" tenta unir o melhor dos mundos (usuário e núcleo) utilizando <strong>Upcalls</strong>. Explique o que é um <em>Upcall</em>, qual regra de hierarquia de camadas ele viola segundo o texto, e como ele ajuda a resolver o problema de bloqueio em threads de usuário.</p><p><strong>9.</strong> Sobre as <strong>Threads Pop-up</strong> em sistemas distribuídos, marque Verdadeiro (V) ou Falso (F):</p><ul><li>( ) O principal objetivo das threads pop-up é reduzir a latência entre a chegada de uma mensagem e o início do seu processamento.</li><li>( ) Threads pop-up possuem um histórico de execução complexo que deve ser restaurado antes de processarem a mensagem.</li><li>( ) Elas podem ser executadas tanto no espaço do núcleo (para maior velocidade e acesso direto) quanto no espaço do usuário (para maior segurança).</li><li>( ) A criação de uma thread pop-up é mais lenta do que acordar uma thread bloqueada existente, devido à necessidade de alocar nova memória.</li></ul><p><strong>10.</strong> A conversão de código <em>monothread</em> para <em>multithread</em> introduz desafios como o tratamento de variáveis globais (ex: <code>errno</code>). O texto menciona uma solução chamada <strong>TLS (Thread-Local Storage)</strong>. O que essa técnica realiza?</p><ul><li>A) Torna todas as variáveis globais visíveis apenas para o processo pai.</li><li>B) Bloqueia o acesso a variáveis globais usando semáforos para evitar condições de corrida.</li><li>C) Cria variáveis que são globais para as funções dentro de um thread específico, mas privadas em relação aos outros threads.</li><li>D) Move todas as variáveis globais para a pilha do núcleo, protegendo-as contra escrita.</li></ul><h2 id=próximos-passos><span class=heading-text>Próximos passos</span><span class=heading-arabic>4.4</span></h2><p>Na próxima aula, <a href=5-interprocess-communication.html>Comunicação entre Processos</a>, aprofundaremos a discussão sobre como processos e threads interagem em um ambiente concorrente. O foco deixará de ser apenas a estrutura interna (como são criados ou escalonados) para abordar os perigos do compartilhamento de dados. Estudaremos as <strong>condições de corrida</strong>, onde a ordem de execução altera o resultado final, e as soluções clássicas para garantir a <strong>exclusão mútua</strong>, como semáforos, monitores e troca de mensagens, essenciais para evitar o caos em sistemas operacionais.</p></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Sistemas Operacionais`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>