<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Compiladores</title><link media="(prefers-color-scheme: light)" href=/aulas-faesa/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/aulas-faesa/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/aulas-faesa/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Compiladores</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#como-o-computador-funciona>3.1. Como o computador funciona</a></li><li class="toc-item level-3"><a href=#o-que-é-uma-máquina-de-estados>3.1.1. O que é uma Máquina de Estados</a></li><li class="toc-item level-2"><a href=#uma-cpu-didática>3.2. Uma CPU Didática</a></li><li class="toc-item level-3"><a href=#busca-da-instrução>3.2.1. Busca da Instrução</a></li><li class="toc-item level-3"><a href=#decodificação>3.2.2. Decodificação</a></li><li class="toc-item level-3"><a href=#execução>3.2.3. Execução</a></li><li class="toc-item level-3"><a href=#memória-e-escrita>3.2.4. Memória e Escrita</a></li><li class="toc-item level-2"><a href=#a-nossa-máquina-virtual-vm>3.3. A Nossa Máquina Virtual (VM)</a></li><li class="toc-item level-3"><a href=#adicionando-memória-à-vm>3.3.1. Adicionando Memória à VM</a></li><li class="toc-item level-4"><a href=#por-que-usar-uma-pilha>3.3.1.1. Por que usar uma Pilha?</a></li><li class="toc-item level-4"><a href=#o-fluxo-completo>3.3.1.2. O Fluxo Completo</a></li><li class="toc-item level-2"><a href=#questões>3.4. Questões</a></li><li class="toc-item level-2"><a href=#próximos-passos>3.5. Próximos passos</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=2-compiler-as-translator.html><i class=nav-icon data-lucide=chevron-left></i> Compilador como Tradutor</a><a class="sidebar-nav-link next" href=4-compiler-steps.html>Etapas do Processo de Compilação <i class=nav-icon data-lucide=chevron-right></i></a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>3</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>A CPU</span> <span class="title-ornament right">❧</span></h1><p class=article-date>03/01/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Compiladores</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-I>I - Introdução</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>A CPU</span></nav></header><div class=article-body><h2 id=como-o-computador-funciona><span class=heading-text>Como o computador funciona</span><span class=heading-arabic>3.1</span></h2><p>Antes de explorarmos o funcionamento de um compilador, é fundamental compreendermos a base sobre a qual ele opera: a <strong>unidade de processamento central (CPU)</strong>.</p><p>Para quem já cursou sistemas digitais ou arquitetura de computadores, este processo pode ser familiar. Contudo, para uma compreensão universal, utilizaremos uma abstração poderosa presente em diversas áreas da computação: a <strong>Máquina de Estados Finitos</strong>.</p><h3 id=o-que-é-uma-máquina-de-estados><span class=heading-text>O que é uma Máquina de Estados</span><span class=heading-arabic>3.1.1</span></h3><p>Uma <strong>máquina de estados (ou Finite State Machine - FSM)</strong> é um modelo matemático que descreve o comportamento de um sistema através de um conjunto limitado de estados e das transições entre eles. Em qualquer instante, o sistema ocupa exatamente um único estado.</p><p>A transição para um novo estado ocorre apenas quando um gatilho ou evento específico acontece, garantindo que o sistema reaja de forma organizada e previsível. Na prática, essa estrutura permite que o sistema saiba exatamente o que fazer em cada contexto, evitando comportamentos inesperados. Esse conceito controla desde dispositivos simples, como semáforos e elevadores, até lógicas complexas em software, como protocolos de rede e a inteligência artificial de jogos.</p><h2 id=uma-cpu-didática><span class=heading-text>Uma CPU Didática</span><span class=heading-arabic>3.2</span></h2><p>Para ilustrar esses conceitos, utilizaremos a arquitetura <strong>MIPS</strong>, um modelo de 32 bits amplamente adotado no ensino de computação por sua elegância e clareza. O MIPS opera com um <strong>pipeline de 5 etapas</strong>, que funciona como uma linha de montagem de fábrica.</p><p>Abaixo, observamos o diagrama do circuito lógico do processador MIPS e as divisões de seu pipeline:</p><img data-sketch=true src=static/mips_datapath.svg style=width:75%;margin:auto><h3 id=busca-da-instrução><span class=heading-text>Busca da Instrução</span><span class=heading-arabic>3.2.1</span></h3><p>Nesta etapa inicial, encontramos o <strong>Program Counter (PC)</strong>. O PC é um registrador especial que armazena o endereço da próxima instrução a ser executada. Quando um programa inicia, o PC geralmente começa em zero.</p><p>O valor do PC é enviado à memória de instruções (carregada na RAM) para buscar o código correspondente. Simultaneamente, o valor do PC passa por um somador que adiciona uma constante. Em arquiteturas de 32 bits como o MIPS, embora o menor dado endereçável seja o byte (8 bits), uma palavra de instrução completa (WORD) possui 32 bits (4 bytes). Por isso, somamos sempre <strong>4</strong> ao PC para que ele aponte para a próxima instrução na sequência ($4 \text{ bytes} \times 8 \text{ bits} = 32 \text{ bits}$).</p><h3 id=decodificação><span class=heading-text>Decodificação</span><span class=heading-arabic>3.2.2</span></h3><p>Aqui, a CPU interpreta o que a instrução buscada deve fazer. Cada processador possui um conjunto específico de instruções conhecido como <strong>ISA (Instruction Set Architecture)</strong>. Exemplos famosos incluem x86 (Intel/AMD), ARM e RISC-V.</p><p>No nível de código, utilizamos mnemônicos como <code>ADD $t0, $t1, $t2</code>. No entanto, para o hardware, isso é apenas uma sequência de bits (ex: <code>000000</code>). O papel deste estágio é:</p><ol><li><strong>Identificar a operação:</strong> Através de uma "tabela verdade" gigante no hardware, a unidade de controle ativa os caminhos corretos do circuito.</li><li><strong>Acessar Registradores:</strong> Identificar quais registradores contêm os dados necessários. O MIPS possui 32 registradores de uso geral. Como esse número é pequeno, o compilador deve ser inteligente ao decidir quais dados manter ali e quais enviar para a RAM.</li><li><strong>Extensão de Sinal:</strong> Se a instrução usar uma constante pequena, o processador expande esse valor para 32 bits para que a operação seja compatível.</li></ol><h3 id=execução><span class=heading-text>Execução</span><span class=heading-arabic>3.2.3</span></h3><p>A operação é efetivamente realizada na <strong>ALU (Arithmetic Logic Unit)</strong>. Além de somas e subtrações, a ALU é crucial para o controle de fluxo (como o comando <code>if</code>).</p><p>Nas CPUs, saltos condicionais (branches) geralmente dependem de uma comparação. Por exemplo, para executar <code>if (i == 10)</code>, a CPU subtrai 10 de <code>i</code>. Se o resultado for zero, uma <strong>flag zero</strong> é ativada. Essa flag avisa o processador que ele não deve seguir para a instrução <code>PC + 4</code>, mas sim carregar um novo endereço de memória no PC, desviando a execução para outra parte do código.</p><h3 id=memória-e-escrita><span class=heading-text>Memória e Escrita</span><span class=heading-arabic>3.2.4</span></h3><p>O quarto estágio acessa a memória RAM apenas se a instrução for de leitura (<code>LOAD</code>) ou escrita (<code>STORE</code>). No quinto estágio, o resultado de um cálculo (como a soma do estágio 3) é finalmente gravado de volta no banco de registradores para ser usado por instruções futuras.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner><strong>Nota sobre o Pipeline:</strong></span></div><div class=callout-content><p>Os blocos verdes no diagrama são registradores de estágio. Eles salvam os resultados intermediários para que, enquanto uma instrução está sendo executada, a próxima já possa começar sua execução de forma simultânea, aumentando drasticamente a performance global.</p></div></div><h2 id=a-nossa-máquina-virtual-vm><span class=heading-text>A Nossa Máquina Virtual (VM)</span><span class=heading-arabic>3.3</span></h2><p>Para facilitar o foco na construção do compilador, utilizaremos uma versão simplificada de CPU em nossa máquina virtual, similar à arquitetura da JVM (Java Virtual Machine).</p><img style="width:50%;height:auto;margin:0 auto" class=centered data-sketch=true src=static/cpu_diagram.svg><p>Diferente do MIPS, nossa VM focará no registrador <strong>SP (Stack Pointer)</strong>. Embora o PC continue existindo, a VM gerenciará grande parte da lógica de controle para nós.</p><h3 id=adicionando-memória-à-vm><span class=heading-text>Adicionando Memória à VM</span><span class=heading-arabic>3.3.1</span></h3><p>Para que nossa VM seja útil, precisamos entender como ela interage com a memória. Dividimos essa interação em duas seções principais:</p><p>&lt;img src="static/cpu_ram_diagram.svg" data-sketch="true" class="centered" style="margin: 0 auto; margin-bottom: 1rem"z></p><ol><li><strong>Memória Convencional (RAM):</strong> Memória efêmera onde guardamos dados que não cabem nos registradores ou estruturas grandes como arquivos. O acesso é feito via <code>LOAD</code> (carregar) e <code>STORE</code> (salvar), exigindo sempre um endereço específico.</li><li><strong>A Pilha (Stack):</strong> Esta é a seção mais importante para o nosso compilador. Ela funciona com as operações <code>PUSH</code> (empilhar) e <code>POP</code> (desempilhar).</li></ol><h4 id=por-que-usar-uma-pilha><span class=heading-text>Por que usar uma Pilha?</span><span class=heading-arabic>3.3.1.1</span></h4><p>Trabalhar com um número restrito de registradores exige que o compilador realize uma tarefa complexa chamada <strong>alocação de registradores</strong>. Ao utilizarmos uma <strong>Máquina de Pilha</strong>, simplificamos a geração de código, podemos apenas empilhar valores, realizar operações com o topo da pilha e desempilhar o resultado. Isso remove a necessidade de gerenciar qual dado vai para qual registrador, permitindo que foquemos na lógica de tradução da linguagem.</p><h4 id=o-fluxo-completo><span class=heading-text>O Fluxo Completo</span><span class=heading-arabic>3.3.1.2</span></h4><p>Abaixo, vemos como o código, a memória e a CPU se integram:</p><img class=centered data-sketch=true src=static/cpu_with_ram_and_program_diagram.svg><p>Neste modelo, o PC aponta para a instrução atual (ex: <code>ADD</code>). Após a execução, o PC é automaticamente incrementado, a menos que uma instrução de salto force o processador a "pular" para um endereço diferente. Essa alternância entre execução sequencial e saltos é o que permite a existência de loops, funções e toda a complexidade dos softwares modernos.</p><h2 id=questões><span class=heading-text>Questões</span><span class=heading-arabic>3.4</span></h2><ol><li><p>Qual é a função do registrador Program Counter, o PC, e por que em várias arquiteturas de 32 bits, como o MIPS, ele é incrementado em 4 bytes a cada instrução sequencial?<br><br></p></li><li><p>Explique a principal diferença de gerenciamento de dados entre uma arquitetura baseada em registradores, como o MIPS, e a arquitetura baseada em pilha que utilizaremos na nossa máquina virtual.<br><br></p></li><li><p>Em qual situação o registrador PC não segue o seu incremento automático sequencial e como isso se relaciona com a execução de desvios no código?</p></li></ol><h2 id=próximos-passos><span class=heading-text>Próximos passos</span><span class=heading-arabic>3.5</span></h2><p>No próximo capítulo, <a href=4-compiler-steps.html>Etapas do processo de compilação</a>, iremos analisar e compreender, em alto nível, as etapas do processo de compilação. Esse entendimento será fundamental para, em seguida, começarmos a estudar cada um dessas etapas em específico e, portanto, começarmos a escrevermos o código para o nosso compilador.</p></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/aulas-faesa/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Compiladores`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>