<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Compiladores</title><link media="(prefers-color-scheme: light)" href=/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Compiladores</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#introdução>5.1. Introdução</a></li><li class="toc-item level-2"><a href=#funções-do-analisador-léxico>5.2. Funções do Analisador Léxico</a></li><li class="toc-item level-2"><a href=#definições>5.3. Definições</a></li><li class="toc-item level-3"><a href=#lexema>5.3.1. Lexema</a></li><li class="toc-item level-3"><a href=#padrão-pattern>5.3.2. Padrão (Pattern)</a></li><li class="toc-item level-3"><a href=#token>5.3.3. Token</a></li><li class="toc-item level-2"><a href=#engenharia-de-entrada-buffering>5.4. Engenharia de Entrada: Buffering</a></li><li class="toc-item level-2"><a href=#tabela-de-símbolos>5.5. Tabela de Símbolos</a></li><li class="toc-item level-2"><a href=#expressões-regulares>5.6. Expressões Regulares</a></li><li class="toc-item level-2"><a href=#analisadores-manuais-vs-analisadores-automáticos>5.7. Analisadores Manuais vs Analisadores Automáticos</a></li><li class="toc-item level-2"><a href=#questões>5.8. Questões</a></li><li class="toc-item level-2"><a href=#próximos-passos>5.9. Próximos passos</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=4-compiler-steps.html><i class=nav-icon data-lucide=chevron-left></i> Etapas do Processo de Compilação</a><a class="sidebar-nav-link next" href=6-configuring-the-setup.html>Configurando o Setup <i class=nav-icon data-lucide=chevron-right></i></a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>5</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>Introdução à Análise Léxica</span> <span class="title-ornament right">❧</span></h1><p class=article-date>28/01/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Compiladores</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-II>II - Análise Léxica</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>Introdução à Análise Léxica</span></nav></header><div class=article-body><h2 id=introdução><span class=heading-text>Introdução</span><span class=heading-arabic>5.1</span></h2><p>A análise léxica trata da formação das estruturas básicas de uma comunicação, na linguagem normalmente se tratam de palavras, dessa forma, essa etapa estudaria como elas se formam e as regras que devem ser respeitadas para construirmos palavras válidas no português, tais como divisão silábica, acentuação e afins.</p><p>Nas linguagens de compilação, entretanto, essa etapa é um pouco diferente, felizmente, bem mais simples do que na língua portuguesa. Aqui estudaremos como o código e separado nos blocos que chamamos de tokens para que possamos criar as regras de interpretação na próxima etapa de análise (análise sintática).</p><p>Dessa forma, nesse capítulo aprenderemos como definir e diferenciar os conceitos de lexema, padrão e tokens, assim como compreender as principais técnicas para leitura dos caracteres do nosso código.</p><h2 id=funções-do-analisador-léxico><span class=heading-text>Funções do Analisador Léxico</span><span class=heading-arabic>5.2</span></h2><p>A analise léxica é a entrada do nosso compilador, dessa maneira, executa algumas tarefas simples mas que são essenciais para transformarmos aglomerados de caracteres escritos em um arquivo de texto qualquer em estruturas de dados computáveis. Notem que por convenção colocamos <code>.c</code>, <code>.cpp</code>, <code>.java</code> no arquivos de código, contudo, no fim são apenas texto como qualquer outro arquivo <code>.txt</code>. Portanto, nessa etapa estaremos focados em 4 etapas, sendo elas:</p><ul><li>Ler os caracteres do código-fonte.<ul><li>Remover espaços em branco, tabulações (<code>\tab</code>, tab) e comentários.</li></ul></li><li>Agrupar os caracteres em lexemas e classificá-los.<ul><li>Detectar erros e relacionar com a posição no programa.</li></ul></li><li>Gerar a lista de tokens (ou marcas).</li><li>Manipular a tabela de símbolos.</li></ul><p>Uma decisão arquitetural crítica na construção de compiladores é definir como o Scanner se comunica com a próxima fase, a Análise Sintática (ou <em>Parser</em>). Uma abordagem ingênua seria projetar o Scanner para ler todo o arquivo de uma vez e gerar uma lista gigante contendo todos os tokens do programa. Contudo, uma vez que um código com erro sintático na primeira linha só acusaria erro sintático após ler todos os caracteres nessa abordagem, a prática adotada foi a abordagem <strong>orientada à demanda</strong>.</p><p>Nesse modelo, o Analisador Sintático atua como o "maestro" da compilação. Quando ele precisa verificar a próxima regra gramatical, ele solicita ao Scanner apenas o próximo pedaço de informação através de uma operação geralmente chamada de <code>get_next_token</code>. O Scanner, então, lê o arquivo apenas o suficiente para montar um único token, entrega-o ao Parser e pausa sua execução esperando a próxima chamada da função.</p><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 623.50 225.61" data-sketch=true width=600 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 221.61)" class=graph id=graph0><title>Compiler</title><g class=node id=node1><title>Lex</title><ellipse cx=171.5 cy=-153.61 fill=none rx=65.11 ry=26.74 stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=middle x=171.5 y=-157.41>Analisador</text><text font-family=Times,serif font-size=14.00 text-anchor=middle x=171.5 y=-142.41>Léxico</text></g><g class=node id=node2><title>Sin</title><ellipse cx=438.5 cy=-153.61 fill=none rx=65.11 ry=26.74 stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=middle x=438.5 y=-157.41>Analisador</text><text font-family=Times,serif font-size=14.00 text-anchor=middle x=438.5 y=-142.41>Sintático</text></g><g class=edge id=edge6><title>Lex:ne->Sin:nw</title><path d="M195.5,-178.61C196.17,-179.28 195.69,-180 196.5,-180.48 211.77,-189.63 218.75,-180.57 236.55,-180.48 311.24,-180.08 353.32,-229.18 405.12,-185.42" fill=none stroke=#333333 /><polygon points="407.52,-187.96 412.5,-178.61 402.78,-182.82 407.52,-187.96" fill=#333333 stroke=#333333 /><text font-family=Times,serif font-size=14.00 text-anchor=middle x=304.5 y=-206.41>token</text></g><g class=node id=node3><title>Tab</title><ellipse cx=304.5 cy=-26.87 fill=none rx=60.21 ry=26.74 stroke=black /><text font-family=Times,serif font-size=14.00 text-anchor=middle x=304.5 y=-30.67>Tabela de</text><text font-family=Times,serif font-size=14.00 text-anchor=middle x=304.5 y=-15.67>Símbolos</text></g><g class=edge id=edge8><title>Lex:s->Tab:n</title><path d="M172.65,-116.8C184.89,-68.68 290.94,-111.77 303.32,-63.8" fill=none stroke=#333333 /><polygon points="169.17,-116.4 171.5,-126.74 176.13,-117.21 169.17,-116.4" fill=#333333 stroke=#333333 /><polygon points="306.81,-64.08 304.5,-53.74 299.86,-63.26 306.81,-64.08" fill=#333333 stroke=#333333 /></g><g class=edge id=edge7><title>Sin:sw->Lex:se</title><path d="M414.5,-128.61C413.83,-127.94 414.31,-127.22 413.5,-126.74 398.23,-117.59 391.25,-126.65 373.45,-126.74 298.76,-127.14 256.68,-78.04 204.88,-121.8" fill=none stroke=#333333 /><polygon points="202.48,-119.26 197.5,-128.61 207.22,-124.4 202.48,-119.26" fill=#333333 stroke=#333333 /><text font-family=Times,serif font-size=14.00 font-style=italic text-anchor=start x=245 y=-131.41>get_next_token()</text></g><g class=edge id=edge9><title>Sin:s->Tab:n</title><path d="M437.34,-116.74C425.01,-68.39 318.17,-112.06 305.69,-63.85" fill=none stroke=#333333 /><polygon points="433.87,-117.21 438.5,-126.74 440.83,-116.4 433.87,-117.21" fill=#333333 stroke=#333333 /><polygon points="309.14,-63.26 304.5,-53.74 302.19,-64.08 309.14,-63.26" fill=#333333 stroke=#333333 /></g><g class=node id=node5><title>Output</title><text font-family=Times,serif font-size=14.00 text-anchor=middle x=577.5 y=-157.41>Análisador</text><text font-family=Times,serif font-size=14.00 text-anchor=middle x=577.5 y=-142.41>Semântico</text></g><g class=edge id=edge5><title>Sin->Output</title><path d="M486.55,-171.84C502.15,-174.63 517.74,-174.38 533.33,-171.09" fill=none stroke=#333333 /><polygon points="534.2,-174.48 543.04,-168.64 532.49,-167.69 534.2,-174.48" fill=#333333 stroke=#333333 /></g><g class=node id=node4><title>Input</title><text font-family=Times,serif font-size=14.00 text-anchor=middle x=35.5 y=-157.41>Programa</text><text font-family=Times,serif font-size=14.00 text-anchor=middle x=35.5 y=-142.41>Fonte</text></g><g class=edge id=edge4><title>Input->Lex</title><path d="M71.09,-162.31C81.29,-163.91 91.49,-164.76 101.69,-164.85" fill=none stroke=#333333 /><polygon points="101.94,-168.35 111.88,-164.69 101.83,-161.35 101.94,-168.35" fill=#333333 stroke=#333333 /></g></g></svg></div></div><p>Essa estratégia é vital para a eficiência do sistema. Imagine que exista um erro de sintaxe logo na primeira linha de um arquivo de um milhão de linhas. Se o Scanner processasse todo o arquivo antes de qualquer análise, teríamos desperdiçado tempo computacional analisando 999.999 linhas inutilmente. Na abordagem sob demanda, o erro é detectado imediatamente na primeira solicitação e o processo é abortado, economizando recursos preciosos.</p><h2 id=definições><span class=heading-text>Definições</span><span class=heading-arabic>5.3</span></h2><p>Para construir um Scanner robusto, precisamos de precisão terminológica absoluta. Um erro muito comum é confundir o texto lido com a sua classificação abstrata. Para evitar isso, definimos três conceitos distintos:</p><h3 id=lexema><span class=heading-text>Lexema</span><span class=heading-arabic>5.3.1</span></h3><p>O lexema é o conteúdo propriamente dito. Ele se refere à sequência exata de caracteres encontrada no código-fonte. Por exemplo, ao digitar <code>while</code>, <code>contador</code> ou <code>3.14</code>, essas strings específicas são os lexemas. É o que está "escrito no papel".</p><hr><p><strong>Problema:</strong> Dado o código na linguagem C apresentado logo abaixo, defina os lexemas correspondentes:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>int x = 42;
</code></pre><p>Os lexemas são:</p><ul><li><strong>int</strong></li><li><strong>x</strong></li><li><strong>=</strong></li><li><strong>42</strong></li><li><strong>;</strong></li></ul><h3 id=padrão-pattern><span class=heading-text>Padrão (Pattern)</span><span class=heading-arabic>5.3.2</span></h3><p>O padrão é a regra de formação dos elementos. Ele descreve a forma genérica que um lexema deve ter para ser aceito em uma determinada categoria. Geralmente, utilizamos <strong>expressões regulares</strong> para definir essas regras. Por exemplo, o padrão para um identificador pode ser definido como "deve começar com uma letra, seguida de zero ou mais letras ou dígitos".</p><p>Ao final dessa aula iremos ver melhor como podemos montar e representar nossos lexemas com esses padrões, entretanto, já devem ter visto algo na disciplina de autômatos finitos.</p><h3 id=token><span class=heading-text>Token</span><span class=heading-arabic>5.3.3</span></h3><p>O token é o produto final empacotado. Trata-se de uma estrutura de dados, geralmente um par <code>&lt;tipo, valor></code>, que categoriza o lexema processado. Onde tipo é o tipo de token e o valor é o lexema associado. Vejamos alguns exemplos:</p><ul><li>Para uma variável com nome "x" teríamos o token <code>&lt;IDENT, "x"></code>, onde IDENT indica um token do tipo identificador e o literal (string constante) "x" indica o lexema (valor do token);</li><li>Para um literal de número, teríamos <code>&lt;NUM, 42></code>.</li></ul><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Nome dos tokens</span></div><div class=callout-content><p>Note que <code>IDENT</code> e <code>NUM</code> são nomes arbitrários escolhidos na hora de programar o compilador. Entretanto, sempre teremos algo semelhante para números, identificadores, operadores aritméticos, booleanos e afins.</p></div></div><p>Vejamos agora uma tabela com alguns exemplos das três definições lado a lado.</p><table><thead><tr><th><strong>Token</strong></th><th><strong>Padrão (Informal)</strong></th><th><strong>Exemplos de Lexemas</strong></th></tr></thead><tbody><tr><td>if</td><td>caracteres i, f</td><td>if</td></tr><tr><td>else</td><td>caracteres e, l, s, e</td><td>else</td></tr><tr><td>comparison</td><td><code>&lt;</code> ou <code>></code> ou <code>&lt;=</code> ou <code>>=</code> ou <code>==</code> ou <code>!=</code></td><td><code>&lt;</code>, <code>=</code>, <code>!=</code></td></tr><tr><td>id</td><td>letra seguida por letras e dígitos</td><td><code>pi</code>, <code>score</code>, <code>D2</code></td></tr><tr><td>number</td><td>qualquer constante numérica</td><td><code>3</code>, <code>0</code>, <code>6.02e23</code></td></tr><tr><td>literal</td><td>qualquer caractere diferente de <code>"</code>, cercado por <code>"</code>s</td><td><code>"core dumped"</code></td></tr></tbody></table><p>Alguns tokens comuns na maioria das linguagens são:</p><ul><li>Um token para cada palvra-chave.</li><li>Tokens para os operadores (individuais ou em classes).</li><li>Um token para todos os identificadores.</li><li>Tokens para classes de constantes (ex. números e literais).</li><li>Um token para cada símbolo de pontuação (parênteses, vírgula, ponto, ponto e vírgula, etc).</li></ul><h2 id=engenharia-de-entrada-buffering><span class=heading-text>Engenharia de Entrada: Buffering</span><span class=heading-arabic>5.4</span></h2><p>A função mais básica do Scanner é a leitura de caracteres. No entanto, ler o disco rígido (HDD ou SSD) byte a byte é uma operação proibitivamente lenta devido à latência do hardware. O sistema operacional é otimizado para entregar blocos grandes de dados (por exemplo, 4KB) de uma só vez. Para alinhar a velocidade extrema da CPU com a relative lentidão do disco, utilizamos técnicas de <strong>Buffering</strong>.</p><p>Entretanto, note que em algumas situações é necessário um <em><strong>look-a-head</strong></em> para ter certeza que o token terminou (exemplos da soma e do operador de >). Dessa forma é como a utilização de <strong>sentinelas</strong> ao final de cada buffer. Isso evita que o Scanner tenha que verificar a cada caractere se chegou ao fim do buffer.</p><p>Antes de vermos os problemas o buffering gera, vamos buscar entender como esse processo é feito em um formato de leitura mais simples, para a leitura de uma linha completa. Veja a imagem abaixo onde temos uma linha somando duas variáveis junto de dois sentinelas, um marcando o início do token e outro o final dele.</p><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 377.00 104.00" data-sketch=true width=425 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 100)" class=graph id=graph0><title>BufferScanner</title><g class=node id=node1><title>array</title><polygon points="4,-54 4,-96 369,-96 369,-54 4,-54" fill=white stroke=transparent /><polygon points="5.5,-55 5.5,-95 37.5,-95 37.5,-55 5.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=16.5 y=-72.2>s</text><polygon points="39.5,-55 39.5,-95 71.5,-95 71.5,-55 39.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=50.5 y=-72.2>o</text><polygon points="73.5,-55 73.5,-95 110.5,-95 110.5,-55 73.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=84.5 y=-72.2>m</text><polygon points="112.5,-55 112.5,-95 144.5,-95 144.5,-55 112.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=123.5 y=-72.2>a</text><polygon points="146.5,-55 146.5,-95 178.5,-95 178.5,-55 146.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=157.5 y=-72.2>=</text><polygon points="180.5,-55 180.5,-95 212.5,-95 212.5,-55 180.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=191.5 y=-72.2>a</text><polygon points="214.5,-55 214.5,-95 241.5,-95 241.5,-55 214.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 text-anchor=start x=225.5 y=-71.2></text><polygon points="243.5,-55 243.5,-95 275.5,-95 275.5,-55 243.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=254.5 y=-72.2>+</text><polygon points="277.5,-55 277.5,-95 304.5,-95 304.5,-55 277.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 text-anchor=start x=288.5 y=-71.2></text><polygon points="306.5,-55 306.5,-95 338.5,-95 338.5,-55 306.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=317.5 y=-72.2>b</text><polygon points="340.5,-55 340.5,-95 368.5,-95 368.5,-55 340.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=351.5 y=-72.2>;</text></g><g class=node id=node2><title>start</title><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=0 y=-6.2>Início</text></g><g class=edge id=edge1><title>start->array:0</title><path d="M21.5,-18.07C21.5,-25.31 21.5,-35.98 21.5,-43.81" fill=none stroke=#333333 stroke-width=3 /><polygon points="18,-44 21.5,-54 25,-44 18,-44" fill=#333333 stroke=#333333 stroke-width=3 /></g><g class=node id=node3><title>end</title><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=114 y=-6.2>Fim</text></g><g class=edge id=edge2><title>end->array:3</title><path d="M128.5,-18.07C128.5,-25.31 128.5,-35.98 128.5,-43.81" fill=none stroke=#333333 stroke-width=3 /><polygon points="125,-44 128.5,-54 132,-44 125,-44" fill=#333333 stroke=#333333 stroke-width=3 /></g></g></svg></div></div><p>Entretanto, em alguns cenários, uma linha pode ser pouco dado e ficar buscando no HD várias linhas o tempo todo não é eficiente, por esse motivo utilizamos o buffering. Entretanto, aqui temos o desafio que chamamos de <strong>Problema da Fronteira do Buffer</strong>. Imagine que carregamos um bloco de dados na memória e o lexema <code>while</code> está posicionado exatamente no final desse bloco, dividido entre o fim de uma leitura e o início da próxima. O Scanner lê <code>w</code>, <code>h</code>, <code>i</code> e o buffer acaba. Se carregarmos o próximo bloco imediatamente sobre o atual para ler o resto, perderemos o início da palavra que estava no bloco anterior.</p><p>Para resolver isso, utilizamos a técnica de <strong>Pares de Buffers</strong> (Buffer Pairs). Dividimos a área de memória disponível em duas metades lógicas. Carregamos a primeira metade e processamos. Quando o ponteiro de leitura atinge o final da primeira metade, carregamos a segunda metade <em>sem apagar a primeira</em>. Isso garante que um lexema que cruza a fronteira esteja sempre contíguo na memória lógica do Scanner.</p><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 293.50 104.00" data-sketch=true width=350 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 100)" class=graph id=graph0><title>SplitBuffers</title><g class=node id=node1><title>array1</title><polygon points="4,-54 4,-96 111,-96 111,-54 4,-54" fill=white stroke=transparent /><polygon points="5.5,-55 5.5,-95 37.5,-95 37.5,-55 5.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=16.5 y=-72.2>s</text><polygon points="39.5,-55 39.5,-95 71.5,-95 71.5,-55 39.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=50.5 y=-72.2>o</text><polygon points="73.5,-55 73.5,-95 110.5,-95 110.5,-55 73.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=84.5 y=-72.2>m</text></g><g class=node id=node2><title>array2</title><polygon points="183.5,-54 183.5,-96 285.5,-96 285.5,-54 183.5,-54" fill=white stroke=transparent /><polygon points="184.5,-55 184.5,-95 216.5,-95 216.5,-55 184.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=195.5 y=-72.2>a</text><polygon points="218.5,-55 218.5,-95 250.5,-95 250.5,-55 218.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=229.5 y=-72.2>=</text><polygon points="252.5,-55 252.5,-95 284.5,-95 284.5,-55 252.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=263.5 y=-72.2>a</text></g><g class=node id=node3><title>start</title><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=0 y=-6.2>início</text></g><g class=edge id=edge1><title>start->array1:0</title><path d="M21.5,-18.07C21.5,-25.31 21.5,-35.98 21.5,-43.81" fill=none stroke=#333333 stroke-width=3 /><polygon points="18,-44 21.5,-54 25,-44 18,-44" fill=#333333 stroke=#333333 stroke-width=3 /></g></g></svg></div></div><div class=no-break><div class=centered><svg class="svg-graph graphviz-img" viewbox="0.00 0.00 231.00 104.00" data-sketch=true width=275 xmlns=http://www.w3.org/2000/svg><g transform="scale(1 1) rotate(0) translate(4 100)" class=graph id=graph0><title>GluedBuffer</title><g class=node id=node1><title>array</title><polygon points="4.5,-54 4.5,-96 38.5,-96 38.5,-54 4.5,-54" fill=white stroke=transparent /><polygon points="5.5,-55 5.5,-95 37.5,-95 37.5,-55 5.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=16.5 y=-72.2>s</text><polygon points="38.5,-54 38.5,-96 72.5,-96 72.5,-54 38.5,-54" fill=white stroke=transparent stroke-width=2 /><polygon points="39.5,-55 39.5,-95 71.5,-95 71.5,-55 39.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=50.5 y=-72.2>o</text><polygon points="72.5,-54 72.5,-96 111.5,-96 111.5,-54 72.5,-54" fill=white stroke=transparent stroke-width=2 /><polygon points="73.5,-55 73.5,-95 110.5,-95 110.5,-55 73.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=84.5 y=-72.2>m</text><polygon points="111.5,-54 111.5,-96 121.5,-96 121.5,-54 111.5,-54" fill=red stroke=transparent stroke-width=2 /><polygon points="121.5,-54 121.5,-96 155.5,-96 155.5,-54 121.5,-54" fill=white stroke=transparent stroke-width=2 /><polygon points="122.5,-55 122.5,-95 154.5,-95 154.5,-55 122.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=133.5 y=-72.2>a</text><polygon points="155.5,-54 155.5,-96 189.5,-96 189.5,-54 155.5,-54" fill=white stroke=transparent stroke-width=2 /><polygon points="156.5,-55 156.5,-95 188.5,-95 188.5,-55 156.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=167.5 y=-72.2>=</text><polygon points="189.5,-54 189.5,-96 223.5,-96 223.5,-54 189.5,-54" fill=white stroke=transparent stroke-width=2 /><polygon points="190.5,-55 190.5,-95 222.5,-95 222.5,-55 190.5,-55" fill=none stroke=#333333 stroke-width=2 /><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=201.5 y=-72.2>a</text></g><g class=node id=node2><title>start</title><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=0 y=-6.2>início</text></g><g class=edge id=edge1><title>start->array:0</title><path d="M21.5,-18.07C21.5,-25.31 21.5,-35.98 21.5,-43.81" fill=none stroke=#333333 stroke-width=3 /><polygon points="18,-44 21.5,-54 25,-44 18,-44" fill=#333333 stroke=#333333 stroke-width=3 /></g><g class=node id=node3><title>end</title><text fill=#333333 font-family=Arial font-size=16.00 font-weight=bold text-anchor=start x=126 y=-6.2>fim</text></g><g class=edge id=edge2><title>end->array:3</title><path d="M138.5,-18.07C138.5,-25.31 138.5,-35.98 138.5,-43.81" fill=none stroke=#333333 stroke-width=3 /><polygon points="135,-44 138.5,-54 142,-44 135,-44" fill=#333333 stroke=#333333 stroke-width=3 /></g></g></svg></div></div><p>Note que essa abordagem ainda pode dar problemas caso o token seja muito grande e ocupe os dois buffers, o que aconteceria muito se utilizássemos um tamanho de três para cada buffer como no exemplo acima, entretanto, nos compiladores esses buffers são bem maiores (4 Kb), fazendo com que esses problemas quase não aconteçam.</p><hr><p><strong>Problema:</strong> Um Scanner utiliza um sistema de Buffer Duplo onde cada metade tem tamanho de 4 bytes. O código fonte a ser lido é: <code>int x = 10;</code>. Simule o estado dos buffers no momento em que o token <code>x</code> é processado.</p><p>O código fonte completo é: <code>i</code>, <code>n</code>, <code>t</code>, <code>  </code>, <code>x</code>, <code>  </code>, <code>=</code>, <code>  </code>, <code>1</code>, <code>0</code>, <code>;</code></p><ol><li><p>O sistema operacional preenche o <strong>Buffer A</strong> com os primeiros 4 bytes.</p> <ul><li>Buffer A: <code>['i', 'n', 't', ' ']</code></li><li>Buffer B: <code>[]</code> <br><br></li></ul></li><li><p>O Scanner lê <code>int</code>. Isso ocorre porque o próximo caractere é um espaço <code>   </code>, que separa o token. Token <code>&lt;INT></code> gerado.<br><br></p></li><li><p>O Scanner consome o espaço. O ponteiro agora está no final do Buffer A.<br><br></p></li><li><p>O Scanner atinge o limite. O sistema carrega os próximos 4 bytes no <strong>Buffer B</strong>.</p> <ul><li>Buffer A: <code>['i', 'n', 't', ' ']</code> (Mantido)</li><li>Buffer B: <code>['x', ' ', '=', ' ']</code><br><br></li></ul></li><li><p>O Scanner lê <code>x</code> no início do Buffer B. Ele verifica o próximo caractere <code>   </code> e conclui que <code>x</code> é um identificador.<br><br></p></li><li><p>O Scanner lê <code>=</code> no Buffer B até encontrar o próximo espaço, concluindo que é um operador de atribuição e não de igualdade.<br></p></li></ol><p>Esse processo irá se repetir começando novamente no buffer A agora, onde colocaremos o número <code>10</code> junto com o ponto e vírgula (<code>;</code>) totalizando três dos 4 bytes, de forma que, iremos gerar o token de literal numérico e o de final de linha.</p><h2 id=tabela-de-símbolos><span class=heading-text>Tabela de Símbolos</span><span class=heading-arabic>5.5</span></h2><p>A <strong>tabela de símbolos</strong> é uma das estruturas mais importantes de um compilador. Apesar dessa importância, ela não é complexa nem difícil de compreender. Seu funcionamento é semelhante ao de um <em><strong>dicionário</strong></em> presente em diversas linguagens de programação, cuja função é relacionar nome, chamados <strong>identificadores</strong>, a números.</p><p>Esses identificadores podem representar nomes de variáveis, funções ou outros elementos da linguagem. Importante notar que eles <strong>não são palavras reservadas</strong>. A tabela de símbolos mapeia esses nomes arbitrários para números inteiros, permitindo que o compilador utilize esses números como referências internas para manipular os identificadores. A utilidade prática desse mecanismo ficará mais clara posteriormente.</p><p>Entretanto, por hora, para facilitar a compreensão, realizaremos um processo de <strong>tokenização em alto nível</strong>, no qual serão gerados os tokens do código-fonte e as variáveis identificadas serão inseridas na tabela de símbolos correspondente.</p><hr><p><strong>Problema:</strong> Considere o código na linguagem C abaixo e preencha a tabela de símbolos e monte a lista de tokens gerados para o código.</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>int a = 10;
int b = 4;
float c = a / b;
printf("%f", c);
</code></pre><p>Durante o processo de análise léxica, o código-fonte é lido sequencialmente, da esquerda para a direita e de cima para baixo. Cada sequência válida de caracteres é reconhecida como um <strong>lexema</strong> e classificada em um <strong>token</strong>, que é inserido na lista de tokens gerados pelo analisador léxico. Esse processo ocorre para <strong>todas as ocorrências</strong>, inclusive quando um mesmo identificador aparece várias vezes no código.</p><p>Quando um lexema do tipo <strong>identificador</strong> é reconhecido, o analisador léxico consulta a <strong>tabela de símbolos</strong> para verificar se esse identificador já foi inserido anteriormente. Caso o identificador ainda não exista, ele é adicionado à tabela e recebe um identificador numérico único. Se o identificador já estiver presente, como ocorre com o identificador <code>a</code> na expressão <code>c = a / b</code>, um novo token é gerado e inserido na lista de tokens, porém <strong>nenhuma nova entrada é criada na tabela de símbolos</strong>. Assim, a tabela de símbolos mantém apenas uma entrada por identificador, enquanto a lista de tokens reflete todas as suas ocorrências no código.</p><pre class="line-numbers language-text" data-lang=TEXT><code class=language-text>&lt;KEYWORD, int>
&lt;ID, 0>
&lt;OP_ASSIGN, =>
&lt;NUM, 10>
&lt;DELIM, ;>

&lt;KEYWORD, int>
&lt;ID, 1>
&lt;OP_ASSIGN, =>
&lt;NUM, 4>
&lt;DELIM, ;>

&lt;KEYWORD, float>
&lt;ID, 2>
&lt;OP_ASSIGN, =>
&lt;ID, 0>
&lt;OP_ARIT, />
&lt;ID, 1>
&lt;DELIM, ;>

&lt;ID, 3>
&lt;DELIM, (>
&lt;LITERAL, "%f">
&lt;DELIM, ,>
&lt;ID, 2>
&lt;DELIM, )>
&lt;DELIM, ;>
</code></pre><p>A tabela de símbolos contém apenas identificadores e <strong>não permite duplicatas</strong>.</p><table><thead><tr><th style=text-align:center>ID</th><th style=text-align:center>Identificador</th></tr></thead><tbody><tr><td style=text-align:center>0</td><td style=text-align:center>a</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>b</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>c</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>printf</td></tr></tbody></table><p>Portanto, a lista de tokens registra todas as ocorrências dos lexemas reconhecidos no código, enquanto a tabela de símbolos armazena cada identificador apenas uma única vez. Identificadores reutilizados, como <code>a</code>, <code>b</code> e <code>c</code>, geram novos tokens sempre que aparecem no código, mas são apenas consultados (<em>lookup</em>) na tabela de símbolos, sem que novas entradas sejam criadas. Esse mecanismo garante eficiência e consistência na representação dos nomes durante as etapas posteriores do compilador.</p><div class="callout callout-tip"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .5 2.2 1.5 3.1.7.7 1.3 1.5 1.5 2.4"/><path d="M9 18h6"/><path d="M10 22h4"/></svg></span><span class=callout-title-inner>Tokens como representação</span></div><div class=callout-content><p>Notem que a lista de tokens são uma representação completa do nosso código até o momento, devemos ser capazes de com essa lista, junto da tabela de símbolos, estruturar novamente nosso código original. <strong>Mais para frente na disciplina iremos aprender à melhorar essa representação estrutural do código.</strong></p></div></div><h2 id=expressões-regulares><span class=heading-text>Expressões Regulares</span><span class=heading-arabic>5.6</span></h2><p>Como vimos, as linguagens de programação são <strong>Linguagens Formais</strong>. Para descrever, de forma precisa e sem ambiguidades, os padrões aceitos pelo <em>Scanner</em>, utilizamos a álgebra das <strong>Expressões Regulares</strong> (<em>Regex</em>). As expressões regulares operam sobre um <strong>Alfabeto</strong>, que é um conjunto finito de símbolos permitidos (como ASCII ou Unicode), para formar <strong>Cadeias</strong>, isto é, palavras ou sequências específicas de caracteres.</p><p>As operações fundamentais que permitem construir qualquer padrão léxico, mesmo os mais complexos, são apenas três:</p><ol><li><strong>União ( | ):</strong> Representa a escolha ou alternância. A expressão <code>a | b</code> significa “o caractere <code>a</code> OU o caractere <code>b</code>”.</li><li><strong>Concatenação ( ):</strong> Não possui símbolo explícito ou é representada apenas por um espaço. Indica sequência. A expressão <code>ab</code> significa “<code>a</code> seguido imediatamente por <code>b</code>”.</li><li><strong>Fechamento de Kleene (*):</strong> Representa repetição. A expressão <code>a*</code> significa “zero ou mais ocorrências de <code>a</code>”.</li></ol><p>A partir dessas primitivas, derivamos operadores de conveniência que são amplamente utilizados na construção de compiladores:</p><ul><li><strong>Fechamento Positivo (+):</strong> Equivale a <code>aa*</code> (uma ou mais ocorrências). É essencial para a definição de números, pois um número não pode ter zero dígitos.</li><li><strong>Opcionalidade (?):</strong> Indica zero ou uma ocorrência. É muito útil para representar sinais (<code>+</code> ou <code>-</code>) ou partes fracionárias de números.</li><li><strong>Classes de Caracteres ([ ]):</strong> Funcionam como uma abreviação para a união de vários caracteres. Por exemplo, <code>[abc] = a | b | c</code>. Também podem ser usadas para intervalos, como <code>[a-z] = a | b | c | ... | z</code>. É possível combinar múltiplos intervalos, como em <code>[a-zA-Z0-9]</code>, que representa todas as letras minúsculas, todas as letras maiúsculas e os 10 dígitos numéricos.</li><li><strong>Negação de Classes ([^ ]):</strong> Muitas vezes, é mais prático definirmos o que <em>não</em> queremos aceitar. Ao inserirmos o acento circunflexo (<code>^</code>) como o primeiro caractere dentro de colchetes, invertemos a lógica da classe. Por exemplo, <code>[^0-9]</code> reconhece qualquer caractere que não seja um dígito. Essa construção é vital para definirmos <em>strings</em>, onde precisamos ler "aspas, seguidas de qualquer coisa que <strong>não</strong> seja aspas, seguidas de aspas". A expressão ficaria: <code>"[^"]*"</code>.</li></ul><p>Além disso, existem algumas convenções importantes. Como expressões regulares são amplamente utilizadas em programação, adotaremos convenções comuns em códigos.</p><p>A primeira delas é o uso do caractere ponto (<code>.</code>) com o significado de “qualquer caractere”. Nesse contexto, ele representa qualquer símbolo, desde letras e números até caracteres especiais, como o menos (<code>-</code>) e a divisão (<code>/</code>). Caso seja desejado utilizar o ponto como um caractere literal, e não como esse curinga, devemos precedê-lo de um caractere de escape (<code>\</code>). Da mesma forma, se quisermos utilizar o próprio caractere de escape, ele também deve ser escapado (<code>\\</code>), como é comum em linguagens de programação.</p><p>Além disso, utilizaremos o símbolo $\epsilon$ para representar o vazio, ou seja, a ausência de caracteres. A utilidade desse símbolo será explorada mais adiante, especialmente nas aulas sobre gramática e análise sintática, mas já é importante introduzi-lo neste momento.</p><p>Por fim, o espaço em branco nas regras é ignorado. Portanto, caso seja necessário representar explicitamente um espaço, utilizamos aspas duplas. Da mesma forma, quando desejamos representar uma cadeia específica de caracteres, ela também deve ser colocada entre aspas duplas. Se for necessário utilizar aspas duplas como parte da cadeia, devemos empregar o caractere de escape. A seguir, veremos um exemplo de como escrever expressões regulares para representar diferentes elementos léxicos.</p><hr><p><strong>Problema:</strong> Considere os seguintes elementos léxicos de uma linguagem de programação simples:</p><ul><li>Identificadores</li><li>Números inteiros</li><li>Operadores de atribuição (<code>=</code>) e soma (<code>+</code>)</li></ul><ol><li>Defina uma <strong>expressão regular</strong> para cada um desses elementos.</li><li>Explique, em palavras, o que cada expressão regular representa.</li><li>Mostre exemplos de lexemas válidos reconhecidos por cada expressão.</li></ol><p>Para resolver esse problema, precisamos primeiro identificar claramente quais são as regras de formação de cada elemento léxico e, em seguida, traduzi-las para expressões regulares utilizando os operadores e convenções já apresentados.</p><p>Começamos pelos <strong>identificadores</strong>. Em muitas linguagens de programação, um identificador deve iniciar obrigatoriamente com uma letra e pode ser seguido por letras ou dígitos. Essa regra evita ambiguidades com números e facilita o reconhecimento léxico. Para representar essa estrutura, utilizamos uma classe de caracteres para letras, seguida de outra classe que permite letras ou dígitos repetidas vezes. Assim, a expressão regular para identificadores pode ser escrita como:</p><ul><li><strong>Identificador:</strong> <code>[a-zA-Z][a-zA-Z0-9]*</code></li></ul><p>Essa expressão indica que o primeiro caractere deve ser uma letra (minúscula ou maiúscula) e que ele pode ser seguido de zero ou mais letras ou dígitos. Exemplos de lexemas válidos reconhecidos por esse padrão são <code>x</code>, <code>contador</code>, <code>A1</code> e <code>var123</code>.</p><p>Em seguida, analisamos os <strong>números inteiros</strong>. Um número inteiro é formado por um ou mais dígitos consecutivos. Como um número não pode ser vazio, utilizamos o fechamento positivo para garantir pelo menos um dígito. A expressão regular correspondente é:</p><ul><li><strong>Número inteiro:</strong> <code>[0-9]+</code></li></ul><p>Essa expressão representa uma sequência de um ou mais dígitos numéricos. Exemplos de lexemas válidos são <code>0</code>, <code>7</code>, <code>42</code> e <code>123456</code>.</p><p>Por fim, temos os <strong>operadores</strong>, que neste caso são símbolos simples e individuais. Como eles não possuem variação interna, suas expressões regulares são diretas e correspondem exatamente ao caractere desejado:</p><ul><li><strong>Atribuição:</strong> <code>=</code></li><li><strong>Soma:</strong> <code>+</code></li></ul><p>Essas expressões reconhecem exclusivamente os lexemas <code>=</code> e <code>+</code>, respectivamente, sem permitir nenhuma outra variação.</p><p>Concluindo, ao definir expressões regulares para cada tipo de token, o analisador léxico consegue identificar corretamente os lexemas presentes no código-fonte, classificá-los em tokens adequados e fornecer essas informações às próximas etapas do compilador. Esse exercício ilustra como regras simples podem ser combinadas para formar a base da análise léxica de uma linguagem de programação.</p><h2 id=analisadores-manuais-vs-analisadores-automáticos><span class=heading-text>Analisadores Manuais vs Analisadores Automáticos</span><span class=heading-arabic>5.7</span></h2><p>Existem diversas ferramentas amplamente conhecidas para a criação de <em>scanners</em> (analisadores léxicos) baseados em <strong>expressões regulares</strong>. Na prática, o processo funciona da seguinte forma: inicialmente, descrevemos uma expressão regular para cada token válido da linguagem. Em seguida, essas expressões são transformadas em <strong>autômatos finitos não determinísticos (AFND)</strong> por meio do algoritmo de <strong>Thompson</strong>.</p><p>Posteriormente, aplica-se o algoritmo de <strong>subconjuntos (ou powerset)</strong> para converter o AFND em um <strong>autômato finito determinístico (AFD)</strong>. Após essa conversão, são utilizados <strong>algoritmos de minimização</strong> com o objetivo de reduzir o número de estados do autômato, tornando-o mais eficiente.</p><p>Ao final desse processo, obtemos um <strong>autômato finito determinístico minimizado</strong> que lê o código-fonte <strong>caractere por caractere</strong>, avançando entre estados. Sempre que o autômato alcança um <strong>estado final</strong>, ele reconhece um token correspondente. Após o reconhecimento, o autômato retorna ao estado inicial e o processo se repete até que todos os caracteres da entrada sejam consumidos.</p><p>A seguir, é mostrado um exemplo de <strong>autômato finito</strong> capaz de reconhecer os seguintes tokens da linguagem: chaves <code>{</code> e <code>}</code>, operador de igualdade <code>==</code>, operadores relacionais maior <code>></code>, menor <code>&lt;</code>, maior ou igual <code>>=</code>, menor ou igual <code>&lt;=</code>, operador de negação <code>!</code>, operador de diferença <code>!=</code> e operador de atribuição <code>=</code>.</p><p><img alt="Exemplo de autômato finito para reconhecer alguns operadores relacionais e chaves." src=static/exemplo_automato_finito_op_rel.png width=75%></p><p>Embora ferramentas baseadas em expressões regulares e geração automática de autômatos facilitem significativamente a construção de analisadores léxicos, <strong>compiladores modernos frequentemente utilizam scanners implementados manualmente</strong>. Apesar de exigirem mais trabalho e cuidado no desenvolvimento, esses scanners feitos à mão oferecem <strong>maior controle sobre o processo de análise léxica</strong>, permitindo otimizações específicas, tratamento mais preciso de erros, melhor integração com a tabela de símbolos e maior flexibilidade para lidar com particularidades da linguagem. Além disso, essa abordagem possibilita decisões mais refinadas sobre desempenho, consumo de memória e estratégias de recuperação de erros, fatores essenciais em compiladores reais e de larga escala.</p><p>Note que esses analisadores léxicos gerados com autômatos rapidamente crescem em número de estados dificultando muito a adição e refatoração do código final.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner></span></div><div class=callout-content><p>Iremos utilizar um <strong>scanner manual</strong>, não por ele ser mais complexo, mas justamente pelo contrário. Como trabalharemos com uma <strong>linguagem reduzida</strong>, essa abordagem torna-se mais simples do que o uso de ferramentas automáticas, além de nos permitir compreender claramente como um scanner é implementado. O fato de a linguagem ser mais restrita e com fins <strong>educativos</strong> reduz significativamente as dificuldades, tornando o processo mais didático e transparente.</p></div></div><h2 id=questões><span class=heading-text>Questões</span><span class=heading-arabic>5.8</span></h2><ol><li>Considere o trecho de código: <code>if (score >= 100) return;</code>.<br> (a) Identifique os <strong>lexemas</strong> presentes nesta linha.<br> (b) Classifique cada lexema em seu respectivo <strong>token</strong> (ex: Palavra-chave, Identificador, Operador, Delimitador, Numeral).<br> (c) Explique a diferença entre o lexema <code>score</code> e o padrão (pattern) que define um identificador.</li></ol><br><ol start=2><li>No texto, discutimos a abordagem <strong>orientada à demanda</strong> (<em>get_next_token</em>) versus a abordagem de processamento em lote (ler o arquivo todo de uma vez). Explique como a abordagem orientada à demanda economiza recursos computacionais no caso de um erro de sintaxe encontrado logo no início de um arquivo de código extenso.</li></ol><br><ol start=3><li>O uso de <em>buffers</em> de entrada é essencial para a eficiência de leitura do disco.<br> (a) Descreva o "Problema da Fronteira do Buffer" e como a técnica de <strong>Pares de Buffers</strong> soluciona essa questão.<br> (b) Qual é a função dos caracteres <strong>sentinelas</strong> inseridos ao final de cada bloco de buffer?</li></ol><br><ol start=4><li>Descreva, em português, quais tipos de cadeias de caracteres são aceitas pelas seguintes expressões regulares:<br> (a) <code>a(a|b)*a</code><br> (b) <code>(0|1)*111(0|1)*</code><br> (c) <code>[A-Z][a-z]*</code></li></ol><br><ol start=5><li>Escreva uma expressão regular para reconhecer identificadores que devem obrigatoriamente começar com um sublinhado <code>_</code>, seguido por pelo menos uma letra maiúscula, podendo terminar com qualquer combinação de letras ou dígitos.<br> <em>Exemplos válidos:</em> <code>_A</code>, <code>_Var1</code>, <code>_X99</code>.<br> <em>Exemplos inválidos:</em> <code>var1</code>, <code>_1var</code>, <code>_a</code>.</li></ol><br><ol start=6><li>Utilizando as definições de <code>dígito</code> como <code>[0-9]</code>, escreva uma expressão regular que reconheça números de ponto flutuante (reais). A expressão deve cobrir os seguintes casos:<ul><li>Obrigatório ter pelo menos um dígito antes do ponto.</li><li>Obrigatório ter o ponto decimal <code>.</code></li><li>Obrigatório ter pelo menos um dígito após o ponto.</li><li>O número pode ser opcionalmente precedido por um sinal de <code>+</code> ou <code>-</code>.</li><li><em>Dica:</em> Lembre-se de escapar o ponto decimal se necessário.</li></ul></li></ol><br><ol start=7><li>Escreva uma expressão regular para reconhecer números literais no formato hexadecimal típicos da linguagem C.<ul><li>Regra: Deve começar com <code>0x</code>.</li><li>Seguido por um ou mais caracteres que podem ser dígitos (<code>0-9</code>) ou letras de <code>a</code> a <code>f</code> (maiúsculas ou minúsculas).</li></ul></li></ol><br><ol start=8><li>O texto menciona que, embora ferramentas automáticas baseadas em autômatos finitos (como Lex/Flex) sejam poderosas, compiladores modernos de produção frequentemente optam por scanners manuais. Cite duas vantagens de se implementar um scanner manualmente em vez de utilizar geradores automáticos.</li></ol><br><ol start=9><li><p>Escreva as expressões regulares que representam os seguintes padrões léxicos:</p> <ul><li>(a) Regex para reconhecer números binários. Sequências de um ou mais dígitos <code>0</code> ou <code>1</code>.</li><li>(b) Regex para nomes de <strong>arquivos de cabeçalho/fonte em C</strong>. Os nomes de arquivos que consistem em uma ou mais letras e terminam obrigatoriamente com a extensão <code>.c</code> ou <code>.h</code> (ex: <code>main.c</code>, <code>lib.h</code>).</li><li>(c) Expressão que comece com a letra <code>T</code>, seguida de qualquer quantidade de letras ou dígitos, mas <strong>não</strong> pode terminar com um dígito (ex: <code>Tvar</code>, <code>T10x</code>, mas não <code>T10</code>).</li><li>(d) Expressão para comentários em linha que começam com <code>//</code> e são seguidos por qualquer sequência de caracteres (assuma que o caractere de nova linha encerra o padrão).</li><li>(e) Uma expressão única que reconheça apenas as strings <code>&&</code> (AND), <code>||</code> (OR) ou <code>!</code> (NOT). <em><strong>Note que precisará escapar o ou | do OR e o do regex.</strong></em></li></ul></li></ol><h2 id=próximos-passos><span class=heading-text>Próximos passos</span><span class=heading-arabic>5.9</span></h2><p>No próximo capítulo, <a href=6-configuring-the-setup.html>Lab - Configurando o Setup</a>, sairemos da teoria para a prática. Daremos início à construção da base do código do nosso compilador utilizando a linguagem C. Definiremos a estrutura do projeto e organizaremos os arquivos de cabeçalho do nosso código.</p></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Compiladores`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>