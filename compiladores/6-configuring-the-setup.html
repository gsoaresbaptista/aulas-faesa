<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Compiladores</title><link media="(prefers-color-scheme: light)" href=/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Compiladores</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#introdução>6.1. Introdução</a></li><li class="toc-item level-2"><a href=#máquina-virtual>6.2. Máquina Virtual</a></li><li class="toc-item level-2"><a href=#estruturando-o-projeto>6.3. Estruturando o Projeto</a></li><li class="toc-item level-3"><a href=#o-espelhamento-de-cabeçalhos>6.3.1. O Espelhamento de Cabeçalhos</a></li><li class="toc-item level-3"><a href=#criando-os-arquivos-de-implementação>6.3.2. Criando os Arquivos de Implementação</a></li><li class="toc-item level-2"><a href=#cmake>6.4. CMake</a></li><li class="toc-item level-3"><a href=#modularização-e-bibliotecas>6.4.1. Modularização e Bibliotecas</a></li><li class="toc-item level-3"><a href=#o-binário-e-o-ponto-de-entrada>6.4.2. O Binário e o Ponto de Entrada</a></li><li class="toc-item level-3"><a href=#como-executar>6.4.3. Como Executar</a></li><li class="toc-item level-2"><a href=#próximos-passos>6.5. Próximos Passos</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=5-introduction-to-lexical-analysis.html><i class=nav-icon data-lucide=chevron-left></i> Introdução à Análise Léxica</a><a class="sidebar-nav-link next" href=7-lexical-analysis-code-i.html>Lab - Analisador Léxico I <i class=nav-icon data-lucide=chevron-right></i></a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>6</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>Configurando o Setup</span> <span class="title-ornament right">❧</span></h1><p class=article-date>28/01/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Compiladores</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-II>II - Análise Léxica</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>Configurando o Setup</span></nav></header><div class=article-body><h2 id=introdução><span class=heading-text>Introdução</span><span class=heading-arabic>6.1</span></h2><p>Para construirmos um compilador, precisamos primeiro estabelecer uma base sólida e confiável. Escolhemos a linguagem C para essa jornada por ser frequentemente considerada a "língua mãe" da infraestrutura de sistemas. Ela nos oferece o controle de baixo nível necessário para manipular bytes, acessar a memória diretamente e gerenciar arquivos, tudo isso sem perder a elegância e a organização de uma linguagem estruturada.</p><p>Se você sente que precisa reforçar seus conhecimentos ou deseja aprender a linguagem do zero antes de avançarmos, recomendamos fortemente que consulte o material da disciplina <a href=./../topicos-de-programacao-ii/contents.html>TEP II</a>. Uma revisão cuidadosa sobre ponteiros e alocação dinâmica de memória será especialmente útil, visto que lidaremos constantemente com estruturas de dados complexas para representar o código fonte em memória.</p><p>Nesta etapa inicial, nosso foco será construir o alicerce do projeto. Antes de escrevermos a primeira linha do analisador léxico, que é o componente responsável por ler o texto e identificar os tokens, precisamos configurar nosso ambiente de programação e definir como esse código será compilado, organizado e executado.</p><h2 id=máquina-virtual><span class=heading-text>Máquina Virtual</span><span class=heading-arabic>6.2</span></h2><p>No Ambiente Virtual de Aprendizagem (AVA) da disciplina, você deve baixar o arquivo da máquina virtual Linux fornecido. Caso esteja utilizando os computadores do laboratório da Faesa, verifique se já existe um arquivo ou máquina virtual identificada como <code>Alpine - Faesa</code>.</p><p><img alt="Arquivo da máquina virtual Alpine Faesa" src=static/alpine_faesa.png width=90%></p><p>É importante que você note que trabalharemos com o conceito de duas máquinas virtuais distintas ao longo da disciplina. A primeira é a máquina virtual de desenvolvimento que estamos configurando agora, que é o sistema operacional onde você escreverá e compilará seu código. A segunda será a máquina virtual alvo, que desenvolveremos como parte do projeto para executar o código compilado pela nossa linguagem. Essa segunda máquina funcionará de maneira análoga à JVM (Java Virtual Machine), processando a linguagem intermediária que geraremos.</p><p>Ao abrir o <strong>Oracle VirtualBox Manager</strong>, você deve importar o arquivo fornecido. Vá em <strong>File</strong> $\rightarrow$ <strong>Import Appliance</strong> e, clicando no ícone de pasta com uma seta verde, selecione o arquivo <code>Alpine - Faesa.ova</code>. Clique em <strong>Finish</strong> para concluir a importação. Com isso, uma nova máquina deverá aparecer no menu lateral. Dê dois cliques sobre ela para iniciá-la.</p><p>A máquina inicializará em uma tela preta de terminal. Não se assuste com essa interface minimalista, pois isso foi feito propositalmente para manter o arquivo leve e compacto, permitindo que você o baixe e utilize em casa sem grandes dificuldades. A tela inicial deve se parecer com a imagem abaixo:</p><p><img alt="Tela de login do Alpine Linux" src=static/vm_example.png width=90%></p><p>Normalmente, a janela abre com um tamanho reduzido que pode esconder a última linha de entrada. Para corrigir isso, vá em <strong>View</strong> na barra superior e altere para <strong>Scaled Mode</strong>. Agora você deve ser capaz de visualizar o prompt <code>alpine login:</code>, que aguarda o seu nome de usuário. Digite <code>root</code> e pressione Enter. Em seguida, o sistema pedirá a senha. Digite <code>123</code> e pressione Enter novamente. Note que, <strong>por medidas de segurança, os caracteres da senha não aparecem na tela enquanto você digita</strong>, mas o sistema está capturando sua entrada. Após esse processo, você verá que o login foi realizado com sucesso.</p><p>Apesar de ser possível escrever código diretamente nesse terminal, essa não é a forma mais produtiva de trabalhar. Por isso, configuraremos o Visual Studio Code para utilizar o ambiente da máquina virtual remotamente, permitindo que você escreva o código em uma interface gráfica moderna e confortável. No terminal da máquina virtual, digite o comando <code>ip a</code> e pressione Enter. Você verá informações de rede semelhantes às da imagem a seguir.</p><p><img alt="Comando ip a mostrando o endereço de rede" src=static/vm_ipa_command.png width=90%></p><p>Observe o endereço IP destacado na saída do comando e anote-o. Agora, abra o Visual Studio Code e instale a extensão chamada <strong>Remote - SSH</strong>, desenvolvida pela Microsoft, caso ela ainda não esteja instalada. Após a instalação, um ícone de monitor com duas setas deve aparecer na barra lateral esquerda do VS Code, conforme mostrado abaixo:</p><p><img alt="Ícone Remote SSH no VS Code" src=static/vscode_remote_icon.png></p><p>Ao colocar o mouse sobre o título <strong>SSH</strong> na barra lateral, aparecerão ícones de engrenagem e de adição (+). Clique no ícone de adição (+) e uma caixa de texto surgirá no topo da janela. Digite <code>root@IP</code>, substituindo <code>IP</code> pelo número que você anotou do terminal (por exemplo, <code>root@192.168.100.231</code>), e pressione Enter.</p><p><img alt="Adicionando conexão SSH no VS Code" src=static/vscode_add_vm.png width=90%></p><p>Caso apareça um menu pedindo para selecionar um arquivo de configuração SSH, selecione a primeira opção sugerida. Após isso, o endereço da máquina adicionada aparecerá na lista abaixo do título SSH. Passe o mouse sobre esse item e clique na seta que surge para conectar. O VS Code solicitará a senha; digite <code>123</code> (a mesma usada para o login). Se um menu aparecer pedindo para confirmar o "fingerprint" da conexão, selecione "Linux" se perguntado sobre o sistema operacional e depois escolha "Continue" ou digite "yes".</p><p>Pronto! Se você observar o canto inferior esquerdo do VS Code e vir o número IP da conexão, significa que você está dentro da máquina virtual. Agora você pode usar o editor para criar pastas e programar diretamente no ambiente Linux. Clique em <strong>Open Folder</strong> na barra lateral e pressione Enter, certificando-se de que o caminho no campo de entrada seja apenas <code>/root/</code>.</p><p>Agora você pode criar sua própria pasta de trabalho, por exemplo, com o nome <code>compilador</code>. Caso queira salvar seu progresso ao final da aula, você poderá baixar essa pasta inteira clicando com o botão direito sobre ela e selecionando <strong>Download...</strong>.</p><p><img alt="Opção de download de arquivos no VS Code" src=static/vscode_download.png width=90%></p><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Sempre baixe os arquivos!</span></div><div class=callout-content><p>Lembre-se de que os arquivos podem ser perdidos se os computadores do laboratório forem reiniciados ou formatados. Caso não esteja utilizando seu computador pessoal, crie o hábito de sempre baixar a pasta do projeto ao final da aula e salvá-la em um local seguro, como um pendrive ou na nuvem.</p></div></div><h2 id=estruturando-o-projeto><span class=heading-text>Estruturando o Projeto</span><span class=heading-arabic>6.3</span></h2><p>Antes de configurarmos o sistema de compilação, é essencial organizarmos a estrutura de diretórios e arquivos do nosso projeto. Um compilador é um software complexo e, sem uma organização rigorosa, o código pode se tornar incontrolável rapidamente.</p><p>Dentro da pasta <code>compilador</code> que você acabou de criar, crie a seguinte estrutura de subpastas:</p><ol><li>Uma pasta chamada <code>src</code> (source), onde ficará todo o código fonte <code>.c</code>.</li><li>Dentro de <code>src</code>, crie uma subpasta chamada <code>compiler</code>.</li><li>Na raiz do projeto (ao lado de <code>src</code>), crie uma pasta chamada <code>include</code>, onde ficarão os arquivos de cabeçalho <code>.h</code>.</li></ol><h3 id=o-espelhamento-de-cabeçalhos><span class=heading-text>O Espelhamento de Cabeçalhos</span><span class=heading-arabic>6.3.1</span></h3><p>A linguagem C possui uma característica arquitetural distinta, a separação clara entre as definições (interfaces) e as implementações (código lógico). Enquanto os arquivos <code>.c</code> contêm a lógica de como as funções operam, os arquivos <code>.h</code> (headers) servem como contratos, informando ao restante do programa quais funções estão disponíveis e como utilizá-las.</p><p>Para manter nosso projeto organizado e profissional, adotaremos a prática de <strong>espelhamento de diretórios</strong>. Isso significa que a estrutura interna da pasta <code>include</code> deve ser idêntica à estrutura da pasta <code>src</code>. Dessa forma, para cada arquivo de implementação <code>src/compiler/lexer.c</code>, existirá um arquivo de definição correspondente em <code>include/compiler/lexer.h</code>. Isso facilita imensamente a navegação pelo projeto conforme ele cresce.</p><p>Vamos aplicar essa estrutura agora:</p><ol><li>Dentro de <code>include</code>, crie também uma subpasta chamada <code>compiler</code>.</li><li>Dentro de <code>include/compiler/</code>, crie os arquivos vazios <code>token.h</code> e <code>lexer.h</code>.</li></ol><h3 id=criando-os-arquivos-de-implementação><span class=heading-text>Criando os Arquivos de Implementação</span><span class=heading-arabic>6.3.2</span></h3><p>Com os cabeçalhos definidos na estrutura, vamos criar os arquivos de implementação vazios para que o CMake possa mapear o projeto completo:</p><ul><li>Dentro de <code>src/compiler/</code>, crie os arquivos <code>token.c</code> e <code>lexer.c</code>.</li><li>Dentro de <code>src/</code>, crie o arquivo <code>main.c</code>.</li></ul><p>Ao final deste processo, sua árvore de arquivos deve estar organizada exatamente como mostrada abaixo:</p><pre class="line-numbers language-text" data-lang=TEXT><code class=language-text>compilador/
├── include/
│   └── compiler/
│       ├── lexer.h
│       └── token.h
├── src/
│   ├── compiler/
│   │   ├── lexer.c
│   │   └── token.c
│   └── main.c
└── (aqui ficará o CMakeLists.txt)
</code></pre><p>Com esses arquivos criados, garantimos que o sistema de build conseguirá encontrar tanto as definições (<code>.h</code>) quanto as implementações (<code>.c</code>), permitindo uma compilação modular e organizada.</p><h2 id=cmake><span class=heading-text>CMake</span><span class=heading-arabic>6.4</span></h2><p>Muitas vezes, ao iniciar um projeto simples em C, recorremos ao comando manual do compilador (<code>gcc main.c -o compiler</code>) ou a arquivos <code>Makefile</code> artesanais. Entretanto, conforme o nosso compilador cresce, gerenciar dezenas de arquivos fonte, cabeçalhos, dependências e bibliotecas torna-se uma tarefa hercúlea e propensa a erros humanos.</p><p>O <strong>CMake</strong> surge não como um compilador, mas como um gerador de sistemas de compilação. Ele atua como um maestro que lê um arquivo de configuração de alto nível (<code>CMakeLists.txt</code>) e decide a melhor forma de compilar seu projeto no sistema atual, seja criando um Makefile no Linux ou um projeto do Visual Studio no Windows. Isso nos permite focar na lógica do compilador, enquanto o CMake cuida da burocracia técnica da construção do binário.</p><p>Na raiz do seu projeto (fora das pastas <code>src</code> e <code>include</code>), crie um arquivo chamado <code>CMakeLists.txt</code> e insira o conteúdo abaixo. Observe a estrutura lógica que reflete a organização que acabamos de criar. O objetivo é manter a modularidade: o analisador léxico e o gerenciador de tokens ficarão encapsulados em uma biblioteca separada, enquanto o arquivo principal apenas coordena a execução.</p><pre class="line-numbers language-cmake" data-lang=CMAKE><code class=language-cmake>cmake_minimum_required(VERSION 3.20)
project(compiler C)

set(CMAKE_C_STANDARD 17)
set(CMAKE_C_STANDARD_REQUIRED ON)

add_library(compiler_lib
    src/compiler/token.c
    src/compiler/lexer.c
)

target_include_directories(compiler_lib
    PUBLIC
        ${PROJECT_SOURCE_DIR}/include
)

target_compile_options(compiler_lib PRIVATE
    -Wall -Wextra -Wpedantic
)

add_executable(compiler
    src/main.c
)

target_link_libraries(compiler PRIVATE compiler_lib)
</code></pre><p>Vamos agora entender, de forma breve, o que cada bloco de comandos significa para que você tenha autonomia para alterar esse arquivo conforme o projeto evoluir.</p><h3 id=modularização-e-bibliotecas><span class=heading-text>Modularização e Bibliotecas</span><span class=heading-arabic>6.4.1</span></h3><p>A parte crucial para a arquitetura do nosso software está na definição da biblioteca <code>compiler_lib</code>. Ao utilizarmos o comando <code>add_library</code>, estamos dizendo ao CMake para agrupar os arquivos <code>src/compiler/token.c</code> e <code>src/compiler/lexer.c</code> em uma unidade lógica reutilizável.</p><p>Essa separação é vital por dois motivos. Primeiro, ela isola a complexidade: o analisador léxico (lexer) e a definição de tokens são componentes fundamentais que serão usados por várias partes do sistema, como o futuro analisador sintático. Segundo, ao transformar esses módulos em uma biblioteca, facilitamos a criação de testes unitários específicos para eles, sem precisar rodar o programa inteiro. O comando <code>target_include_directories</code> complementa essa configuração, informando ao compilador que qualquer arquivo que utilize essa biblioteca pode buscar seus cabeçalhos na pasta <code>include</code>, mantendo nosso código limpo e organizado.</p><h3 id=o-binário-e-o-ponto-de-entrada><span class=heading-text>O Binário e o Ponto de Entrada</span><span class=heading-arabic>6.4.2</span></h3><p>Por fim, definimos o produto final do nosso projeto através do comando <code>add_executable(compiler src/main.c)</code>. Este comando instrui o CMake a gerar um arquivo executável chamado <code>compiler</code> utilizando o código presente em <code>src/main.c</code>.</p><p>O arquivo <code>main.c</code> será o ponto de entrada da nossa aplicação. É nele que reside a função <code>main</code>, responsável por receber os argumentos da linha de comando (como o nome do arquivo fonte que queremos compilar), inicializar os componentes do compilador e orquestrar o processo de leitura e análise.</p><p>Para garantir que o executável tenha acesso às funções do analisador léxico que definimos anteriormente, utilizamos o comando:</p><pre class="line-numbers language-cmake" data-lang=CMAKE><code class=language-cmake>target_link_libraries(compiler PRIVATE compiler_lib)
</code></pre><p>Essa linha realiza a "linkagem" final, conectando o executável <code>compiler</code> à nossa biblioteca de ferramentas <code>compiler_lib</code>. A partir desse momento, o CMake entende que o executável depende da biblioteca; se você alterar qualquer linha de código no lexer, o sistema saberá automaticamente que precisa recompilar a biblioteca e atualizar o executável final.</p><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Entre na pasta correta!</span></div><div class=callout-content><p>Antes de prosseguir, entre na pasta criada. Vá em "File" -> "Open Folder" e digite o caminho para a pasta criada, no caso desse tutorial <code>/root/compilador/</code>.</p></div></div><p>Até o momento sua pasta <code>compilador</code> deve estar semelhante à imagem abaixo:</p><p><img alt="Estrutura da pasta completa." src=static/vscode_compiler_files.png width=90%></p><h3 id=como-executar><span class=heading-text>Como Executar</span><span class=heading-arabic>6.4.3</span></h3><p>Com o arquivo <code>CMakeLists.txt</code> configurado e a estrutura de pastas criada, o fluxo de trabalho para construir o projeto será sempre dividido em dois passos simples no seu terminal:</p><ol><li><p><strong>Configuração</strong>: Digite <code>cmake -B build</code> e pressione Enter. Esse comando lê o seu <code>CMakeLists.txt</code> e cria uma nova pasta chamada <code>build</code>, contendo todas as instruções de compilação (Makefiles) necessárias.</p></li><li><p><strong>Construção</strong>: Digite <code>cmake --build build</code> e pressione Enter. Esse comando executa a compilação de fato, lendo as instruções da pasta <code>build</code> e gerando o arquivo executável <code>compiler</code>.</p></li></ol><p>Essa separação é extremamente benéfica pois mantém a raiz do seu projeto limpa. Todos os arquivos temporários, objetos de compilação e artefatos gerados ficam isolados dentro da pasta <code>build</code>, que pode ser apagada e recriada a qualquer momento sem risco de perder seu código fonte.</p><p>Para começarmos com o código do compilador propriamente dito, teste o comando do <code>cmake</code> antes. Entretanto, se não definirmos a função de entrada <code>main</code> o processo de compilação dará erro. Portanto, no arquivo <code>main.c</code> cole o seguinte código:</p><pre class="line-numbers language-c" data-lang=C><code class=language-c>#include &lt;stdio.h>

int main() {
    printf("Hello World!\n");
    return 0;
}
</code></pre><p>Após isso, no VS Code, utilize o atalho <code>CTRL + J</code> para abrir o terminal, aqui você poderá utilizar o terminal do linux da sua máquina virtual. Rode os dois comandos do <code>cmake</code> fornecidos acima. Você deve obter algo como na imagem:</p><p><img alt="Demonstração de uma mensagem de sucesso de build." src=static/vscode_build_success.png width=90%></p><p>Note que dentro da pasta build existe um arquivo chamado <code>compiler</code>, ele é o nosso binário final (o resto dos arquivos são apenas auxiliares no processo de build). Para executá-lo, escreva no terminal <code>./build/compiler</code> e veja na saída padrão a mensagem que digitamos no <code>printf</code>. Sempre que fizer uma alteração, lembre de compilar novamente seu código e executar o binário para testar.</p><h2 id=próximos-passos><span class=heading-text>Próximos Passos</span><span class=heading-arabic>6.5</span></h2><p>Agora que temos nossa estrutura de construção pronta, o CMake configurado e o ambiente virtual operante, estamos prontos para mergulhar na primeira etapa real do desenvolvimento. No próximo capítulo, <a href=7-lexical-analysis-code-i.html>Lab - Analisador Léxico I</a>, estudaremos a teoria e a prática de como transformar um fluxo bruto de caracteres em unidades de significado que o computador consiga entender.</p></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Compiladores`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>