<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Redes</title><link media="(prefers-color-scheme: light)" href=/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Redes</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#comunicação-de-dados>3.1. Comunicação de dados</a></li><li class="toc-item level-2"><a href=#redes-e-topologias>3.2. Redes e topologias</a></li><li class="toc-item level-2"><a href=#hierarquias-de-protocolos-e-estruturação-de-software-de-rede>3.3. Hierarquias de Protocolos e Estruturação de Software de Rede</a></li><li class="toc-item level-3"><a href=#questões-de-projeto-relacionadas-às-camadas>3.3.1. Questões de projeto relacionadas às camadas</a></li><li class="toc-item level-3"><a href=#serviços-orientados-e-não-orientados-a-conexões>3.3.2. Serviços orientados e não orientados a conexões</a></li><li class="toc-item level-3"><a href=#primitivas-de-serviço>3.3.3. Primitivas de serviço</a></li><li class="toc-item level-3"><a href=#relacionamento-entre-serviços-e-protocolos>3.3.4. Relacionamento entre serviços e protocolos</a></li><li class="toc-item level-2"><a href=#modelos-de-referência>3.4. Modelos de Referência</a></li><li class="toc-item level-3"><a href=#o-modelo-de-referência-osi>3.4.1. O modelo de referência OSI</a></li><li class="toc-item level-4"><a href=#camada-física>3.4.1.1. Camada Física</a></li><li class="toc-item level-4"><a href=#camada-de-enlace-de-dados>3.4.1.2. Camada de Enlace de Dados</a></li><li class="toc-item level-4"><a href=#camada-de-rede>3.4.1.3. Camada de Rede</a></li><li class="toc-item level-4"><a href=#camada-de-transporte>3.4.1.4. Camada de Transporte</a></li><li class="toc-item level-4"><a href=#camada-de-sessão>3.4.1.5. Camada de Sessão</a></li><li class="toc-item level-4"><a href=#camada-de-apresentação>3.4.1.6. Camada de Apresentação</a></li><li class="toc-item level-4"><a href=#camada-de-aplicação>3.4.1.7. Camada de Aplicação</a></li><li class="toc-item level-3"><a href=#o-modelo-de-referência-tcpip>3.4.2. O modelo de referência TCP/IP</a></li><li class="toc-item level-2"><a href=#comparação-entre-osi-e-tcpip>3.5. Comparação entre OSI e TCP/IP</a></li><li class="toc-item level-2"><a href=#questões>3.6. Questões</a></li><li class="toc-item level-2"><a href=#próximos-passos>3.7. Próximos passos</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=2-introduction-and-classification.html><i class=nav-icon data-lucide=chevron-left></i> Introdução, Classificação de Redes e Hardware</a><a class="sidebar-nav-link next" href=4-physical-layer-and-wireless.html>Camada Física, Meios de Transmissão e Sem Fio <i class=nav-icon data-lucide=chevron-right></i></a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>3</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>Topologias de Rede e Modelos de Referência</span> <span class="title-ornament right">❧</span></h1><p class=article-date>03/02/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Redes</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-I>I - Introdução</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>Topologias de Rede e Modelos de Referência</span></nav></header><div class=article-body><h2 id=comunicação-de-dados><span class=heading-text>Comunicação de dados</span><span class=heading-arabic>3.1</span></h2><p>A comunicação é, em sua essência, o ato de compartilhar informações. Esse processo pode ocorrer localmente, face a face, ou remotamente, abrangendo distâncias consideráveis. O termo telecomunicação deriva justamente dessa necessidade de superar a distância (<em>tele</em>, do grego), englobando tecnologias como telefonia, telegrafia e televisão. Nesse contexto, definimos <strong>dados</strong> como informações apresentadas em qualquer formato acordado entre as partes criadoras e usuárias.</p><p>A <strong>comunicação de dados</strong> consiste na troca dessas informações entre dois dispositivos através de um meio de transmissão, como um cabo metálico. Para que esse processo ocorra, é necessário um sistema composto pela união de hardware (equipamentos físicos) e software (programas). A eficácia desse sistema depende de quatro características fundamentais:</p><ol><li><strong>Entrega:</strong> O sistema deve entregar os dados ao destino correto e exclusivamente ao dispositivo ou usuário pretendido.</li><li><strong>Precisão:</strong> Os dados devem chegar intactos, pois informações alteradas e não corrigidas são inúteis.</li><li><strong>Sincronização:</strong> A entrega deve ocorrer no momento certo. Para áudio e vídeo, isso significa transmissão em tempo real, sem atrasos significativos.</li><li><strong>Jitter:</strong> Refere-se à variação no tempo de chegada dos pacotes. Um atraso desigual na entrega de pacotes de vídeo, por exemplo, resulta em uma reprodução de qualidade irregular.</li></ol><p>Um sistema de comunicação de dados estrutura-se sobre cinco componentes essenciais, cuja interação harmoniosa viabiliza a troca de informações.</p><img src=static/fig1_1_componentes_comunicacao.png width=75%><table><thead><tr><th style=text-align:left>Componente</th><th style=text-align:left>Função</th><th style=text-align:left>Exemplos</th></tr></thead><tbody><tr><td style=text-align:left><strong>1. Mensagem</strong></td><td style=text-align:left>A informação a ser transmitida.</td><td style=text-align:left>Texto, números, imagens, áudio e vídeo.</td></tr><tr><td style=text-align:left><strong>2. Emissor</strong></td><td style=text-align:left>O dispositivo que envia os dados.</td><td style=text-align:left>Computador, câmera, telefone.</td></tr><tr><td style=text-align:left><strong>3. Receptor</strong></td><td style=text-align:left>O dispositivo que recebe os dados.</td><td style=text-align:left>Monitor, servidor, rádio.</td></tr><tr><td style=text-align:left><strong>4. Meio</strong></td><td style=text-align:left>O caminho físico por onde a mensagem viaja.</td><td style=text-align:left>Par trançado, fibra óptica, ondas de rádio.</td></tr><tr><td style=text-align:left><strong>5. Protocolo</strong></td><td style=text-align:left>Conjunto de regras que governa a comunicação.</td><td style=text-align:left>Acordos de software (a "língua" comum entre os dispositivos).</td></tr></tbody></table><p>As informações modernas trafegam em diversos formatos. O <strong>texto</strong> é representado por padrões de bits, sendo o sistema <strong>Unicode</strong> (32 bits) o padrão predominante atual, englobando o antigo ASCII. <strong>Números</strong> são convertidos diretamente para binário para facilitar cálculos matemáticos. <strong>Imagens</strong> são formadas por matrizes de pixels, utilizando métodos como <strong>RGB</strong> (Red, Green, Blue) para compor cores. Já <strong>áudio</strong> e <strong>vídeo</strong> possuem natureza contínua e requerem digitalização.</p><p>A interação entre dois dispositivos é classificada pela direção e simultaneidade do fluxo de dados. Existem três modos de transmissão: <strong>Simplex</strong>, <strong>Half-Duplex</strong> e <strong>Full-Duplex</strong>.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Analogias de Fluxo</span></div><div class=callout-content><ul><li><strong>Simplex (Unidirecional):</strong> Como uma rua de mão única. Apenas um dispositivo transmite, o outro apenas recebe (Ex: Teclado para CPU, Monitor tradicional).</li><li><strong>Half-Duplex (Bidirecional Alternado):</strong> Como uma estrada com obras onde passa um carro de cada vez. Ambos transmitem, mas nunca ao mesmo tempo (Ex: Walkie-talkies, Rádios CB).</li><li><strong>Full-Duplex (Bidirecional Simultâneo):</strong> Como uma rodovia de pista dupla. O tráfego flui nos dois sentidos simultaneamente (Ex: Rede telefônica).</li></ul></div></div><p>Aqui, é fundamental fazermos uma distinção crucial para evitar confusões com os conceitos de endereçamento vistos anteriormente (Unicast, Multicast e Broadcast). Enquanto os termos acima (Simplex, Half/Full-Duplex) referem-se à <strong>mecânica da estrada</strong> (se a mão é única ou dupla), os termos da aula passada referem-se a <strong>para quem você está dirigindo</strong>.</p><div class="callout callout-important"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Comparativo: Direção de Fluxo vs. Tipo de Endereçamento</span></div><div class=callout-content><p>Muitos alunos confundem a <em>direção dos dados</em> com a <em>quantidade de destinos</em>. Veja a diferença:</p><table><thead><tr><th style=text-align:left>Conceito</th><th style=text-align:left>Pergunta Principal</th><th style=text-align:left>Exemplos</th></tr></thead><tbody><tr><td style=text-align:left><strong>Fluxo (Simplex, Half, Full)</strong></td><td style=text-align:left><em>"Quem fala e quando?"</em></td><td style=text-align:left><strong>Simplex:</strong> Só eu falo, sempre.<br><strong>Half-Duplex:</strong> Eu falo, depois você fala.<br><strong>Full-Duplex:</strong> Falamos juntos.</td></tr><tr><td style=text-align:left><strong>Endereçamento (Unicast, Multicast, Broadcast)</strong></td><td style=text-align:left><em>"Para quantos eu falo?"</em></td><td style=text-align:left><strong>Unicast:</strong> Falo para uma pessoa específica.<br><strong>Multicast:</strong> Falo para um grupo interessado.<br><strong>Broadcast:</strong> Grito para todos na sala.</td></tr></tbody></table><p><strong>Exemplo Combinado:</strong> Uma transmissão de TV aberta é <strong>Simplex</strong> (apenas a emissora envia sinal para sua casa) e <strong>Broadcast</strong> (o sinal é enviado para todas as antenas da cidade). Já uma conversa telefônica é <strong>Full-Duplex</strong> (ambos falam ao mesmo tempo) e <strong>Unicast</strong> (você fala com apenas uma pessoa).</p></div></div><p>Para deixar ainda mais claro, a imagem abaixo fornece uma comparação dos três sentidos de transmissão.</p><img src=static/fig1_2_fluxo_de_dados.png width=75%><h2 id=redes-e-topologias><span class=heading-text>Redes e topologias</span><span class=heading-arabic>3.2</span></h2><p>Uma rede é definida fundamentalmente como um conjunto de dispositivos, habitualmente conhecidos como nós, conectados por links de comunicação. Um nó pode ser um computador, uma impressora ou qualquer outro dispositivo capaz de enviar e receber dados. Atualmente, a maioria das arquiteturas utiliza o <strong>processamento distribuído</strong>, estratégia na qual uma tarefa é dividida entre vários computadores independentes (como estações de trabalho), em vez de ser concentrada em uma única máquina de grande porte.</p><p>Para que uma rede seja considerada efetiva, ela deve atender a critérios rigorosos de desempenho, confiabilidade e segurança, cujos detalhes e métricas são apresentados na tabela a seguir:</p><table><thead><tr><th style=text-align:left>Critério</th><th style=text-align:left>Definição e Métricas</th><th style=text-align:left>Fatores de Influência</th></tr></thead><tbody><tr><td style=text-align:left><strong>Desempenho</strong></td><td style=text-align:left>Medido pelo <strong>tempo de trânsito</strong> (tempo de viagem da mensagem) e <strong>tempo de resposta</strong> (intervalo entre solicitação e resposta). Avalia-se também a <strong>vazão</strong> (<em>throughput</em>) e o <strong>atraso</strong> (<em>delay</em>).</td><td style=text-align:left>Número de usuários, meio de transmissão, capacidade do hardware e eficiência do software.</td></tr><tr><td style=text-align:left><strong>Confiabilidade</strong></td><td style=text-align:left>Medida pela frequência de falhas, tempo de recuperação do link e robustez do sistema em caso de catástrofes.</td><td style=text-align:left>Qualidade dos componentes e redundância.</td></tr><tr><td style=text-align:left><strong>Segurança</strong></td><td style=text-align:left>Proteção contra acesso não autorizado, danos aos dados e políticas de recuperação.</td><td style=text-align:left>Procedimentos contra violações e perda de dados.</td></tr></tbody></table><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Relação Vazão vs. Atraso</span></div><div class=callout-content><p>É importante notar que vazão e atraso são frequentemente contraditórios. Tentar aumentar a vazão enviando mais dados para a rede pode causar congestionamento, o que, consequentemente, aumenta o atraso.</p></div></div><p>Antes de discutirmos as formas das redes, precisamos definir seus atributos físicos. Uma rede consiste em dois ou mais dispositivos conectados por links. Existem dois tipos fundamentais de conexão:</p><ul><li><strong>Ponto a Ponto:</strong> Um link dedicado conecta exclusivamente dois dispositivos (ex: controle remoto da TV, links de micro-ondas).</li><li><strong>Multiponto:</strong> Vários dispositivos compartilham o mesmo link espacialmente ou temporalmente.</li></ul><img src=static/fig1_3_tipos_conexao.png width=75%><p>A maneira como esses links e dispositivos são organizados fisicamente define a <strong>Topologia da Rede</strong>. A seguir, detalhamos as quatro topologias básicas e suas variantes híbridas, cada uma com sua representação visual.</p><p><strong>Topologia em Malha (Mesh)</strong> Nesta configuração, cada dispositivo possui um link ponto a ponto dedicado com cada um dos demais dispositivos. Isso oferece robustez extrema (se um link falhar, os outros continuam) e privacidade, mas exige um volume massivo de cabeamento. Para dimensionar uma malha totalmente conectada com $n$ nós, utilizamos fórmulas específicas para calcular portas e cabos:</p><div class="callout callout-important"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Cálculo de Malha</span></div><div class=callout-content><p>Para $n$ dispositivos:</p><ol><li><strong>Número de Portas (I/O) por dispositivo:</strong> $n - 1$</li><li><strong>Número Total de Links Físicos:</strong> $$Links = \frac{n(n - 1)}{2}$$</li></ol><p><em>Exemplo:</em> Em uma rede com 5 computadores, seriam necessários 10 cabos ($5 \times 4 / 2$).</p></div></div><img src=static/fig1_5_topologia_malha.png width=50%><p><strong>Topologia em Estrela (Star)</strong> Neste modelo, cada dispositivo tem um link dedicado apenas com um controlador central, geralmente denominado <strong>hub</strong>. Não há tráfego direto entre os dispositivos; o controlador atua como uma central telefônica retransmitindo os dados. É mais barata e fácil de instalar que a malha, e a falha de um link afeta apenas um dispositivo. Contudo, possui um ponto único de falha: se o hub parar, toda a rede para.</p><img src=static/fig1_6_topologia_estrela.png width=50%><p><strong>Topologia em Barramento (Bus)</strong> Esta é uma topologia multiponto onde um único cabo longo atua como <strong>backbone</strong>, interligando todos os dispositivos. Os nós conectam-se através de cabos transceptores e conectores (como o transceptor-vampiro). Embora use menos cabos e seja fácil de instalar, apresenta desafios de manutenção: o sinal degrada com a distância, a reconfiguração é difícil e uma ruptura no cabo principal derruba toda a rede, gerando reflexão de sinais e ruído.</p><img src=static/fig1_7_topologia_barramento.png width=80%><p><strong>Topologia em Anel (Ring)</strong> Cada dispositivo conecta-se ponto a ponto exclusivamente com seus dois vizinhos imediatos. O sinal percorre o anel em um sentido único, sendo regenerado pelo repetidor de cada dispositivo até o destino. É fácil de instalar e o isolamento de falhas é simplificado (um alarme pode indicar onde o sinal parou). Porém, em um anel simples, uma falha em qualquer estação ou link pode derrubar a rede, problema que pode ser mitigado com anéis duplos.</p><img src=static/fig1_8_topologia_anel.png width=85%><p><strong>Topologia Híbrida</strong> Na prática, muitas redes combinam características das topologias anteriores. Um exemplo comum é ter uma topologia principal (backbone) em estrela ou anel, conectando sub-redes que operam em barramento, maximizando a eficiência e escalabilidade do sistema.</p><img src=static/fig1_9_topologia_hibrida.png width=75%><h2 id=hierarquias-de-protocolos-e-estruturação-de-software-de-rede><span class=heading-text>Hierarquias de Protocolos e Estruturação de Software de Rede</span><span class=heading-arabic>3.3</span></h2><p>O design de redes evoluiu significativamente desde os primórdios, onde o foco era puramente o hardware. Atualmente, o software de rede é altamente estruturado e essencial para o funcionamento do sistema. A metodologia padrão para lidar com a complexidade inerente às redes é a organização em <strong>camadas</strong> (ou níveis), empilhadas umas sobre as outras.</p><p>A ideia central é que cada camada funcione como uma <strong>máquina virtual</strong>, oferecendo serviços específicos à camada superior e ocultando os detalhes complexos de implementação. Esse conceito é análogo ao encapsulamento ou abstração de dados na programação orientada a objetos: o usuário consome um serviço sem precisar saber como ele é internamente construído.</p><p>A comunicação entre máquinas segue uma lógica de pares (<em>peers</em>). Quando a camada $n$ de uma máquina dialoga com a camada $n$ de outra, elas utilizam um conjunto de regras e convenções denominado <strong>protocolo</strong>.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Definição de Protocolo</span></div><div class=callout-content><p>Um protocolo é um acordo formal entre as partes comunicantes que define como a interação ocorrerá. Sem ele, a comunicação é inviável, assim como duas pessoas tentando conversar sem um idioma comum ou normas sociais de etiqueta.</p></div></div><p>A figura abaixo ilustra uma rede genérica de cinco camadas, destacando a diferença entre o fluxo real de dados e a comunicação virtual:</p><img src=static/fig1_11_camadas_protocolos_interfaces.png width=70%><p>Neste diagrama, observamos três conceitos fundamentais:</p><ol><li><strong>Comunicação Virtual (Linhas pontilhadas):</strong> Ocorre horizontalmente entre pares da mesma camada (ex: Camada 5 com Camada 5), utilizando o protocolo daquela camada.</li><li><strong>Comunicação Física (Linhas contínuas):</strong> Ocorre verticalmente. Os dados descem de uma camada para a inferior até o meio físico, e no destino sobem camada por camada.</li><li><strong>Interface:</strong> O ponto de contato entre camadas adjacentes (ex: Interface 4/5). Define quais operações a camada inferior oferece à superior. Interfaces bem definidas permitem, por exemplo, trocar uma tecnologia de transmissão (como substituir linhas telefônicas por satélite) sem afetar as aplicações superiores.</li></ol><p>O conjunto completo de camadas e seus protocolos forma a <strong>Arquitetura de Rede</strong>. Já a lista de protocolos específicos utilizados em um sistema (um por camada) é chamada de <strong>Pilha de Protocolos</strong>.</p><p>Para visualizar esse processo, considere a analogia dos Filósofos:</p><img src=static/fig1_12_filosofo_tradutor.png width=75%><p>Neste exemplo:</p><ul><li><strong>Camada 3 (Filósofos):</strong> Desejam comunicar uma ideia ("Gosto de coelhos"). Falam idiomas diferentes.</li><li><strong>Camada 2 (Tradutores):</strong> Convertem a mensagem para um idioma comum acordado (Holandês). Este é o <em>protocolo</em> da camada 2.</li><li><strong>Camada 1 (Secretárias):</strong> Transmitem a mensagem fisicamente (por Fax). Este é o serviço da camada 1.</li></ul><p>Tecnicamente, o processo envolve o <strong>encapsulamento</strong>. À medida que a mensagem desce pela pilha, cada camada adiciona seu próprio cabeçalho (e as vezes um trailer) com informações de controle (como endereços ou números de sequência).</p><img src=static/fig1_13_fluxo_informacao.png width=75%><p>Conforme mostrado na figura acima:</p><ol><li>A <strong>Camada 5</strong> produz a mensagem $M$.</li><li>A <strong>Camada 4</strong> adiciona um cabeçalho $H4$.</li><li>A <strong>Camada 3</strong> pode precisar fragmentar a mensagem (se ela for muito grande) em pacotes menores ($M1$ e $M2$), adicionando cabeçalhos $H3$ a cada fragmento.</li><li>A <strong>Camada 2</strong> adiciona cabeçalho $H2$ e um trailer $T2$ para transmissão física.</li></ol><p>No destino, o processo é reverso (desencapsulamento): à medida que os dados sobem, cada camada remove e processa o cabeçalho correspondente, entregando apenas o conteúdo limpo à camada superior. Essa abstração permite dividir o projeto titânico de uma rede completa em problemas menores e gerenciáveis de design de camadas individuais.</p><h3 id=questões-de-projeto-relacionadas-às-camadas><span class=heading-text>Questões de projeto relacionadas às camadas</span><span class=heading-arabic>3.3.1</span></h3><p>Ao projetar redes de computadores, existem desafios universais que transcendem camadas específicas, exigindo soluções arquiteturais robustas. O primeiro desses desafios é a <strong>Confiabilidade</strong>, que consiste na arte de construir uma rede que opere corretamente mesmo sendo composta por componentes falíveis. Durante o tráfego de um pacote, bits podem ser corrompidos ou invertidos devido a ruídos elétricos, interferências sem fio ou bugs de software.</p><p>Para mitigar esses problemas, utilizam-se mecanismos de detecção e correção de erros. A detecção utiliza códigos para identificar falhas na informação recebida, solicitando a retransmissão dos dados, enquanto a correção de erros emprega códigos mais poderosos capazes de recuperar a mensagem original a partir dos bits incorretos, ambos baseados na adição de redundância aos dados.</p><p>Ainda no âmbito da confiabilidade, destaca-se o <strong>Roteamento</strong>, que é a capacidade da rede de encontrar caminhos funcionais automaticamente. Em uma rede vasta, enlaces podem falhar; se uma rota através da Alemanha estiver inoperante, o sistema deve ser capaz de redirecionar pacotes de Londres para Roma via Paris, por exemplo, sem intervenção manual.</p><p>O segundo pilar do projeto é a <strong>Evolução da Rede</strong>. O crescimento contínuo exige mecanismos de escalabilidade e organização. Para identificar os bilhões de transmissores e receptores, são essenciais sistemas de <strong>endereçamento</strong> (nas camadas altas) e <strong>nomeação</strong> (nas camadas baixas). Além disso, como diferentes tecnologias possuem limitações distintas (como o tamanho máximo de mensagem ou a ordem de entrega), surge a necessidade da <strong>Interligação de Redes</strong>, que harmoniza essas diferenças através da fragmentação e remontagem de mensagens. Projetos que mantêm o desempenho enquanto a rede cresce são considerados escaláveis, evitando colapsos análogos a engarrafamentos em metrópoles mal planejadas.</p><p>Uma terceira questão crucial é a <strong>Alocação de Recursos</strong>. As redes devem gerenciar seus recursos subjacentes, como a largura de banda, para que um host não prejudique o desempenho dos outros. Em vez de reservar uma fração fixa da capacidade para cada usuário (o que seria ineficiente), utiliza-se frequentemente a <strong>multiplexação estatística</strong>, compartilhando a banda dinamicamente com base na demanda momentânea.</p><p>Dentro da alocação de recursos, dois conceitos frequentemente confundidos, mas distintos, devem ser observados:</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Controle de Fluxo vs. Controle de Congestionamento</span></div><div class=callout-content><ul><li><strong>Controle de Fluxo:</strong> Mecanismo de <em>feedback</em> que impede um transmissor rápido de sobrecarregar um receptor lento (foco no ponto a ponto).</li><li><strong>Controle de Congestionamento:</strong> Estratégia global para evitar que a demanda excessiva de muitos computadores sobrecarregue a infraestrutura da rede (foco na saúde da rede).</li></ul></div></div><p>Além da velocidade, certas aplicações exigem pontualidade. A <strong>Qualidade de Serviço (QoS)</strong> é o conjunto de mecanismos que reconcilia demandas concorrentes, garantindo, por exemplo, entrega em tempo real para transmissões de vídeo enquanto mantém a vazão para transferências de arquivos.</p><p>Por fim, a <strong>Segurança</strong> permeia todas as camadas, defendendo a rede contra ameaças diversas. Todas as estratégias modernas de segurança baseiam-se em criptografia para garantir três pilares fundamentais, descritos na tabela a seguir:</p><table><thead><tr><th style=text-align:left>Pilar de Segurança</th><th style=text-align:left>Objetivo</th><th style=text-align:left>Exemplo de Aplicação</th></tr></thead><tbody><tr><td style=text-align:left><strong>Confidencialidade</strong></td><td style=text-align:left>Impedir a bisbilhotagem (snooping).</td><td style=text-align:left>Garantir que apenas o destinatário leia a mensagem.</td></tr><tr><td style=text-align:left><strong>Autenticação</strong></td><td style=text-align:left>Verificar a identidade das partes.</td><td style=text-align:left>Confirmar se um site bancário é legítimo ou se a chamada vem do seu telefone.</td></tr><tr><td style=text-align:left><strong>Integridade</strong></td><td style=text-align:left>Impedir alterações clandestinas.</td><td style=text-align:left>Evitar que uma transação de "US$ 10" seja alterada para "US$ 1.000" no caminho.</td></tr></tbody></table><h3 id=serviços-orientados-e-não-orientados-a-conexões><span class=heading-text>Serviços orientados e não orientados a conexões</span><span class=heading-arabic>3.3.2</span></h3><p>As camadas de uma arquitetura de rede oferecem dois tipos fundamentais de serviços às camadas superiores: <strong>serviços orientados a conexões</strong> e <strong>serviços não orientados a conexões</strong>. A distinção entre eles molda a forma como os dados trafegam e como a confiabilidade é gerenciada.</p><p>O <strong>serviço orientado a conexões</strong> inspira-se no funcionamento do sistema telefônico clássico. O processo ocorre em três etapas distintas: primeiro estabelece-se a conexão, depois utiliza-se o canal para transmitir os dados e, finalmente, libera-se a conexão. A característica essencial é que a conexão funciona como um tubo (ou circuito), onde os bits entram por uma extremidade e saem pela outra, geralmente preservando a ordem de envio. Durante o estabelecimento da conexão, pode haver uma negociação de parâmetros entre transmissor, receptor e sub-rede, definindo o tamanho máximo das mensagens e a qualidade de serviço exigida.</p><p>Em contraste, o <strong>serviço não orientado a conexões</strong> baseia-se na analogia do sistema postal. Cada mensagem (ou pacote, no contexto da camada de rede) carrega o endereço completo de destino e é roteada pelos nós intermediários de forma independente.</p><p>O processamento desses pacotes pelos nós intermediários pode ocorrer de duas formas principais:</p><ol><li><strong>Store-and-forward:</strong> O nó espera receber a mensagem completa antes de enviá-la ao próximo.</li><li><strong>Cut-through:</strong> A retransmissão inicia-se antes mesmo de a mensagem ser totalmente recebida, reduzindo a latência.</li></ol><p>A tabela a seguir resume as diferenças cruciais entre os dois modelos:</p><table><thead><tr><th style=text-align:left>Característica</th><th style=text-align:left>Orientado a Conexões</th><th style=text-align:left>Não Orientado a Conexões</th></tr></thead><tbody><tr><td style=text-align:left><strong>Analogia</strong></td><td style=text-align:left>Sistema Telefônico</td><td style=text-align:left>Sistema Postal (Cartas)</td></tr><tr><td style=text-align:left><strong>Fluxo</strong></td><td style=text-align:left>Estabelecimento $\to$ Transferência $\to$ Liberação</td><td style=text-align:left>Envio direto e independente</td></tr><tr><td style=text-align:left><strong>Ordem dos Dados</strong></td><td style=text-align:left>Geralmente preservada</td><td style=text-align:left>Não garantida (podem chegar fora de ordem)</td></tr><tr><td style=text-align:left><strong>Caminho</strong></td><td style=text-align:left>Fixo (Circuito/Tubo)</td><td style=text-align:left>Dinâmico (cada pacote pode seguir uma rota)</td></tr></tbody></table><p>Além da conexão, os serviços são caracterizados pela sua <strong>confiabilidade</strong>. Um serviço confiável garante que nenhum dado seja perdido, geralmente através de confirmações de recebimento (ACKs) enviadas pelo receptor. Embora vital para transferências de arquivos (onde cada bit importa), esse processo introduz atrasos (overhead) que podem ser inaceitáveis para aplicações em tempo real, como voz sobre IP (VoIP) ou videoconferências. Nesses casos, os usuários preferem eventuais falhas momentâneas no áudio ou vídeo a sofrerem com atrasos constantes causados pela correção de erros.</p><p>Dentro do modelo orientado a conexões, existem variações importantes na forma como os dados são tratados:</p><ul><li><strong>Sequências de Mensagens:</strong> Os limites são preservados. Se duas mensagens de 1.024 bytes são enviadas, elas chegam como duas entidades distintas (útil para envio de páginas de texto, por exemplo).</li><li><strong>Fluxos de Bytes:</strong> A conexão é um fluxo contínuo sem limites definidos. O receptor recebe os dados conforme chegam, sem saber se foram enviados em blocos separados (útil para streaming de filmes, onde o que importa é o fluxo contínuo).</li></ul><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Por que usar comunicação não confiável?</span></div><div class=callout-content><p>Pode parecer contraintuitivo preferir um serviço "não confiável". No entanto, ele é essencial por dois motivos:</p><ol><li><strong>Disponibilidade Tecnológica:</strong> Camadas inferiores, como a Ethernet, são inerentemente não confiáveis (sujeitas a ruídos). A confiabilidade é construída nas camadas superiores.</li><li><strong>Performance:</strong> O <em>overhead</em> das confirmações torna o serviço lento para aplicações multimídia em tempo real.</li></ol></div></div><p>O serviço não orientado a conexões também possui suas variações, adaptadas a diferentes necessidades. O <strong>serviço de datagramas</strong> (análogo ao telegrama) não oferece garantias de entrega e é a forma dominante na maioria das redes, sendo ideal para tráfego massivo ou envios únicos onde a configuração de conexão seria custosa (como no caso de spammers). Já o <strong>serviço de datagramas confirmados</strong> adiciona confiabilidade ao envio de mensagens curtas (como SMS), funcionando como uma carta registrada. Por fim, o modelo de <strong>solicitação/resposta</strong> é a base da arquitetura cliente-servidor, onde uma pergunta gera uma resposta imediata.</p><p>A figura abaixo resume os principais tipos de serviços discutidos:</p><img src=static/fig1_14_tipos_servicos.png width=75%><h3 id=primitivas-de-serviço><span class=heading-text>Primitivas de serviço</span><span class=heading-arabic>3.3.3</span></h3><p>A especificação formal de um serviço de rede ocorre através de um conjunto de <strong>primitivas</strong> (operações) que permitem aos processos do usuário acessar esse serviço. Essas primitivas instruem o sistema a executar uma ação específica ou relatam uma ação realizada por uma entidade par. Frequentemente, quando a pilha de protocolos reside no sistema operacional, essas primitivas atuam como chamadas de sistema, gerando uma armadilha para o kernel que assume o controle para o envio dos pacotes.</p><p>A natureza do serviço (orientado ou não a conexões) determina o conjunto de primitivas disponíveis. Inspirado na interface de <em>sockets</em> de Berkeley, a tabela abaixo apresenta um conjunto simplificado de primitivas essenciais para implementar um fluxo de bytes confiável em um ambiente cliente-servidor:</p><table><thead><tr><th style=text-align:left>Primitiva</th><th style=text-align:left>Significado e Ação</th></tr></thead><tbody><tr><td style=text-align:left><strong>LISTEN</strong></td><td style=text-align:left>O processo bloqueia e aguarda por uma conexão de entrada (servidor).</td></tr><tr><td style=text-align:left><strong>CONNECT</strong></td><td style=text-align:left>Solicita o estabelecimento de uma conexão com um par que está à espera (cliente).</td></tr><tr><td style=text-align:left><strong>ACCEPT</strong></td><td style=text-align:left>Aceita uma conexão de entrada solicitada por um par.</td></tr><tr><td style=text-align:left><strong>RECEIVE</strong></td><td style=text-align:left>O processo bloqueia e aguarda a chegada de uma mensagem.</td></tr><tr><td style=text-align:left><strong>SEND</strong></td><td style=text-align:left>Envia uma mensagem para o par conectado.</td></tr><tr><td style=text-align:left><strong>DISCONNECT</strong></td><td style=text-align:left>Solicita o encerramento da conexão.</td></tr></tbody></table><p>Para ilustrar a aplicação dessas primitivas, analisaremos um protocolo simples utilizando datagramas confirmados. O processo inicia-se com o servidor executando <code>LISTEN</code>, indicando sua disponibilidade para aceitar conexões. Esta é geralmente uma chamada de bloqueio: o servidor fica suspenso até que uma solicitação surja. Em seguida, o cliente executa <code>CONNECT</code>, especificando o endereço do servidor. O sistema operacional então envia um pacote de solicitação, conforme ilustrado no passo (1) da figura abaixo:</p><img src=static/fig1_15_interacao_cliente_servidor.png width=90%><p>Ao receber a solicitação, o sistema operacional do servidor desbloqueia o processo ouvinte, que pode então executar <code>ACCEPT</code>. Isso envia uma confirmação de volta ao cliente (passo 2). Neste ponto, a conexão está estabelecida, criando um cenário análogo a uma chamada telefônica: o gerente (servidor) espera o telefone tocar (<code>LISTEN</code>), o cliente disca (<code>CONNECT</code>) e o gerente atende (<code>ACCEPT</code>).</p><p>Com a conexão ativa, a troca de dados ocorre. O servidor executa <code>RECEIVE</code> para aguardar solicitações. O cliente utiliza <code>SEND</code> para transmitir sua requisição (passo 3) e imediatamente executa <code>RECEIVE</code> para aguardar a resposta. O servidor processa a requisição e envia a réplica via <code>SEND</code> (passo 4). Finalmente, para encerrar a sessão, utiliza-se a primitiva <code>DISCONNECT</code>. O cliente inicia o desligamento (passo 5) e o servidor confirma (passo 6), liberando a conexão em ambas as pontas.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Por que tanta complexidade?</span></div><div class=callout-content><p>Alguém poderia questionar por que utilizar um protocolo de 6 pacotes (como mostrado acima) em vez de um modelo simples de 2 pacotes (solicitação e resposta), típico de serviços não orientados a conexão.</p><p>A resposta reside na <strong>confiabilidade do mundo real</strong>. Em um cenário ideal, dois pacotes bastariam. Contudo, em redes reais sujeitas a erros, perda de pacotes e transmissão de arquivos grandes (que exigem fragmentação), é crucial garantir que:</p><ul><li>Todos os fragmentos chegaram.</li><li>A ordem dos pacotes foi preservada.</li><li>Não houve duplicação de pacotes antigos.</li></ul><p>Por isso, embora introduza <em>overhead</em>, o serviço orientado a conexões fornece a estabilidade necessária para a maioria das aplicações complexas.</p></div></div><h3 id=relacionamento-entre-serviços-e-protocolos><span class=heading-text>Relacionamento entre serviços e protocolos</span><span class=heading-arabic>3.3.4</span></h3><p>Serviços e protocolos são conceitos distintos, e essa diferenciação é tão fundamental para a arquitetura de redes que merece destaque especial. Essencialmente, um <strong>serviço</strong> é um conjunto de primitivas (operações) que uma camada oferece à camada imediatamente superior. Ele define <em>o que</em> a camada está preparada para executar em nome de seus usuários, mas não revela absolutamente nada sobre <em>como</em> essas operações são implementadas. Trata-se de uma relação vertical entre duas camadas adjacentes: a inferior atua como fornecedora e a superior, como usuária.</p><p>Em contrapartida, um <strong>protocolo</strong> é o conjunto de regras que governa o formato e o significado dos pacotes ou mensagens trocados entre entidades pares (situadas na mesma camada, mas em máquinas diferentes). As entidades utilizam protocolos para implementar as definições de serviço. Um ponto crucial é a independência: as entidades têm liberdade para alterar seus protocolos, desde que não modifiquem o serviço visível para os usuários acima.</p><p>A figura a seguir ilustra essa relação geométrica, onde os serviços ocorrem nas interfaces verticais e os protocolos nas interações horizontais:</p><img src=static/fig1_16_servico_protocolo.png width=60%><p>Para consolidar o entendimento, a tabela abaixo resume as principais diferenças entre os dois conceitos:</p><table><thead><tr><th style=text-align:left>Característica</th><th style=text-align:left>Serviço</th><th style=text-align:left>Protocolo</th></tr></thead><tbody><tr><td style=text-align:left><strong>Definição</strong></td><td style=text-align:left>Conjunto de operações (primitivas) oferecidas à camada superior.</td><td style=text-align:left>Conjunto de regras para troca de dados entre entidades pares.</td></tr><tr><td style=text-align:left><strong>Direção</strong></td><td style=text-align:left>Vertical (Interface entre camadas adjacentes).</td><td style=text-align:left>Horizontal (Comunicação entre máquinas diferentes).</td></tr><tr><td style=text-align:left><strong>Foco</strong></td><td style=text-align:left>Define <strong>o que</strong> a camada faz.</td><td style=text-align:left>Define <strong>como</strong> a camada implementa a comunicação.</td></tr><tr><td style=text-align:left><strong>Visibilidade</strong></td><td style=text-align:left>Visível para o usuário da camada (camada superior).</td><td style=text-align:left>Oculto do usuário (detalhe interno de implementação).</td></tr></tbody></table><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Analogia com Programação Orientada a Objetos</span></div><div class=callout-content><p>Podemos comparar um <strong>serviço</strong> a um Tipo Abstrato de Dados (TAD) ou à interface de um objeto: ele define os métodos públicos disponíveis, mas não expõe o código interno. Já o <strong>protocolo</strong> equivale à implementação interna desses métodos, ou seja, o código que faz o objeto funcionar, mas que permanece invisível para quem o utiliza.</p></div></div><p>Historicamente, muitos protocolos antigos falhavam em fazer essa distinção. Nesses sistemas, uma primitiva de serviço frequentemente exigia que o usuário fornecesse um pacote totalmente montado, expondo detalhes internos. Isso significava que qualquer mudança no protocolo impactava imediatamente os usuários. Atualmente, os projetistas de redes consideram essa mistura de conceitos um erro grave de design, priorizando o encapsulamento e a separação clara entre a interface (serviço) e a implementação (protocolo).</p><h2 id=modelos-de-referência><span class=heading-text>Modelos de Referência</span><span class=heading-arabic>3.4</span></h2><h3 id=o-modelo-de-referência-osi><span class=heading-text>O modelo de referência OSI</span><span class=heading-arabic>3.4.1</span></h3><p>Para concretizar a compreensão das redes em camadas, analisaremos o <strong>Modelo de Referência OSI</strong> (Open Systems Interconnection). Baseado em propostas da ISO (<em>International Standards Organization</em>), este modelo foi concebido como um passo fundamental rumo à padronização internacional. Seu nome, "Interconexão de Sistemas Abertos", refere-se à capacidade de conectar sistemas que estão abertos à comunicação com outros, independentemente de suas arquiteturas internas proprietárias.</p><p>Embora o modelo OSI em si não seja uma arquitetura de rede operacional (ele não especifica os protocolos exatos de cada camada, apenas suas funções), ele permanece como uma ferramenta teórica vital. Seus princípios de design estabelecem que:</p><ol><li>Cada camada deve representar um grau de abstração necessário.</li><li>Cada camada deve ter uma função bem definida e padronizável.</li><li>Os limites devem minimizar o fluxo de informações através das interfaces.</li></ol><p>A estrutura é composta por <strong>sete camadas</strong>, organizadas da seguinte forma:</p><img src=static/fig1_17_modelo_osi.png width=75%><p>Abaixo, detalhamos a função de cada camada, partindo da base física até o nível do usuário.</p><h4 id=camada-física><span class=heading-text>Camada Física</span><span class=heading-arabic>3.4.1.1</span></h4><p>A base do modelo lida com a transmissão bruta de bits por um canal de comunicação.</p><ul><li><strong>Função:</strong> Garantir que um bit '1' enviado chegue como '1' e não '0'.</li><li><strong>Questões de Projeto:</strong> Definição de sinais elétricos (voltagem para 0 e 1), duração do bit (nanossegundos), modo de transmissão (simplex/duplex) e especificações mecânicas de conectores e pinos.</li></ul><h4 id=camada-de-enlace-de-dados><span class=heading-text>Camada de Enlace de Dados</span><span class=heading-arabic>3.4.1.2</span></h4><p>Responsável por transformar um canal de transmissão bruto em uma linha livre de erros para a camada superior.</p><ul><li><strong>Mecanismo:</strong> Fragmenta os dados de entrada em <strong>quadros</strong> (<em>frames</em>) e gerencia confirmações (ACKs) de recebimento.</li><li><strong>Controle de Fluxo:</strong> Impede que um transmissor rápido afogue um receptor lento.</li><li><strong>Subcamada MAC:</strong> Em redes de <em>broadcast</em>, a subcamada de Controle de Acesso ao Meio gerencia quem tem o direito de transmitir no canal compartilhado.</li></ul><h4 id=camada-de-rede><span class=heading-text>Camada de Rede</span><span class=heading-arabic>3.4.1.3</span></h4><p>Controla a operação da sub-rede, focando no caminho que os dados percorrem.</p><ul><li><strong>Roteamento:</strong> Determina a rota da origem ao destino (estática ou dinâmica).</li><li><strong>Controle de Congestionamento:</strong> Gerencia gargalos de tráfego.</li><li><strong>Interconexão:</strong> Resolve problemas de heterogeneidade (endereçamentos ou tamanhos de pacotes diferentes) ao conectar redes distintas.</li><li><strong>Unidade de Dados:</strong> Pacote.</li></ul><h4 id=camada-de-transporte><span class=heading-text>Camada de Transporte</span><span class=heading-arabic>3.4.1.4</span></h4><p>A primeira camada de <strong>ponta a ponta</strong> (fim a fim), isolando as camadas superiores dos detalhes de hardware.</p><ul><li><strong>Função:</strong> Aceita dados da camada de sessão, divide-os se necessário e garante a entrega correta no destino.</li><li><strong>Independência:</strong> Diferente das camadas inferiores (1-3) que operam entre vizinhos imediatos (roteador a roteador), a camada 4 estabelece uma conversa lógica direta entre o programa de origem e o de destino.</li><li><strong>Tipos de Serviço:</strong> Pode oferecer canais livres de erro, entrega desordenada ou broadcasting, dependendo da necessidade.</li></ul><h4 id=camada-de-sessão><span class=heading-text>Camada de Sessão</span><span class=heading-arabic>3.4.1.5</span></h4><p>Gerencia o estabelecimento e manutenção de sessões de comunicação entre usuários de máquinas diferentes.</p><ul><li><strong>Serviços:</strong> Controle de diálogo (quem fala quando), gerenciamento de <em>tokens</em> (para operações críticas) e <strong>sincronização</strong> (pontos de checagem para retomar transferências longas em caso de falha).</li></ul><h4 id=camada-de-apresentação><span class=heading-text>Camada de Apresentação</span><span class=heading-arabic>3.4.1.6</span></h4><p>Foca na sintaxe e semântica das informações, não apenas na movimentação de bits.</p><ul><li><strong>Função:</strong> Atua como um tradutor universal. Resolve diferenças de representação de dados (ex: codificação de caracteres ASCII vs. EBCDIC, inteiros <em>big-endian</em> vs. <em>little-endian</em>) para que sistemas heterogêneos possam se entender. Criptografia e compressão também ocorrem aqui.</li></ul><h4 id=camada-de-aplicação><span class=heading-text>Camada de Aplicação</span><span class=heading-arabic>3.4.1.7</span></h4><p>Contém os protocolos utilizados diretamente pelos usuários finais.</p><ul><li><strong>Exemplos:</strong><ul><li><strong>HTTP:</strong> Base da World Wide Web.</li><li><strong>FTP:</strong> Transferência de arquivos.</li><li><strong>SMTP:</strong> Correio eletrônico.</li></ul></li></ul><h3 id=o-modelo-de-referência-tcpip><span class=heading-text>O modelo de referência TCP/IP</span><span class=heading-arabic>3.4.2</span></h3><p>Após analisarmos o modelo OSI, voltamo-nos agora para a arquitetura que fundamentou a "avó" de todas as redes de computadores de longa distância: a <strong>ARPANET</strong>, e sua sucessora direta, a Internet mundial. A ARPANET foi uma rede de pesquisa patrocinada pelo Departamento de Defesa dos Estados Unidos (DoD) que conectou centenas de universidades e repartições públicas. A necessidade de interligar essas linhas telefônicas dedicadas com novas redes de rádio e satélite forçou a criação de uma arquitetura de referência robusta e flexível, capaz de unificar sistemas díspares.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Filosofia de Design e Contexto Histórico</span></div><div class=callout-content><p>O desenvolvimento do TCP/IP foi influenciado pela Guerra Fria. O DoD necessitava de uma rede capaz de sobreviver à perda de hardware ou linhas de transmissão (por exemplo, em um ataque militar) sem interromper as conversações existentes. Se a origem e o destino estivessem funcionais, a conexão deveria permanecer intacta.</p></div></div><p>Essa necessidade de robustez e flexibilidade (suportando desde transferência de arquivos até voz em tempo real) levou à escolha de uma rede de comutação de pacotes não orientada a conexões. A estrutura resultante, conhecida como Modelo TCP/IP, possui quatro camadas distintas, comparadas ao modelo OSI na figura abaixo:</p><img src=static/fig1_18_modelo_tcp_ip.png width=60%><p><strong>A Camada de Enlace.</strong> Situada na base do modelo, esta camada descreve o que os enlaces de transmissão (como linhas seriais e Ethernet) devem fazer para cumprir os requisitos da rede. Não é uma camada no sentido estrito, mas sim uma interface crítica entre os hosts e os meios físicos de transmissão.</p><p><strong>A Camada Internet (Camada de Rede).</strong> Esta camada é o "coração" que mantém toda a arquitetura unida. Sua função primordial é permitir que hosts injetem pacotes em qualquer rede e garantir que eles trafeguem independentemente até o destino, possivelmente passando por redes diferentes.</p><p>O funcionamento desta camada é análogo ao sistema de correio convencional: você deposita cartas (pacotes) em uma caixa, e elas atravessam diversos centros de triagem internacionais até o destino. O usuário não precisa conhecer as regras internas de cada centro. A camada Internet define um formato de pacote oficial e utiliza dois protocolos principais:</p><ul><li><strong>IP (Internet Protocol):</strong> Responsável pelo endereçamento e entrega.</li><li><strong>ICMP (Internet Control Message Protocol):</strong> Protocolo auxiliar para mensagens de controle e erro.</li></ul><p><strong>A Camada de Transporte.</strong> Localizada acima da camada Internet, permite que as entidades pares nos hosts de origem e destino mantenham uma conversação. Aqui, definem-se dois protocolos de ponta a ponta com características opostas, essenciais para diferentes tipos de aplicação:</p><table><thead><tr><th style=text-align:left>Característica</th><th style=text-align:left>TCP (Transmission Control Protocol)</th><th style=text-align:left>UDP (User Datagram Protocol)</th></tr></thead><tbody><tr><td style=text-align:left><strong>Tipo de Conexão</strong></td><td style=text-align:left>Orientado a conexões.</td><td style=text-align:left>Não orientado a conexões (sem conexão).</td></tr><tr><td style=text-align:left><strong>Confiabilidade</strong></td><td style=text-align:left>Alta. Garante entrega sem erros e ordenada.</td><td style=text-align:left>Baixa (Não confiável). Não garante entrega ou ordem.</td></tr><tr><td style=text-align:left><strong>Controle</strong></td><td style=text-align:left>Realiza controle de fluxo (evita sobrecarga do receptor).</td><td style=text-align:left>Sem controle de fluxo ou sequenciamento.</td></tr><tr><td style=text-align:left><strong>Uso Ideal</strong></td><td style=text-align:left>Transferência de arquivos, e-mail, navegação Web.</td><td style=text-align:left>Consultas rápidas (cliente-servidor), voz e vídeo em tempo real (onde a velocidade supera a precisão).</td></tr></tbody></table><p>A relação hierárquica entre esses protocolos e a camada IP pode ser visualizada a seguir:</p><p><strong>A Camada de Aplicação.</strong> O modelo TCP/IP não possui camadas de sessão ou apresentação, pois a experiência demonstrou que essas funções eram raramente necessárias; quando precisas, são implementadas pela própria aplicação. Esta camada contém todos os protocolos de nível mais alto, incluindo:</p><ul><li><strong>TELNET:</strong> Protocolo de terminal virtual.</li><li><strong>FTP:</strong> Transferência de arquivos.</li><li><strong>SMTP:</strong> Correio eletrônico.</li><li><strong>DNS (Domain Name Service):</strong> Mapeia nomes de hosts (ex: www.google.com) para endereços IP.</li><li><strong>HTTP:</strong> Busca de páginas na World Wide Web.</li><li><strong>RTP:</strong> Entrega de mídia em tempo real.</li></ul><h2 id=comparação-entre-osi-e-tcpip><span class=heading-text>Comparação entre OSI e TCP/IP</span><span class=heading-arabic>3.5</span></h2><p>Embora possuam origens distintas, os modelos de referência OSI e TCP/IP compartilham fundamentos essenciais. Ambos baseiam-se no conceito de uma pilha de protocolos independentes e apresentam funcionalidades de camadas muito similares. Em ambos os modelos, as camadas inferiores até a de transporte formam o <strong>provedor de transporte</strong>, oferecendo um serviço de ponta a ponta independente da rede, enquanto as camadas superiores focam nas aplicações que utilizam esse serviço. Apesar dessas semelhanças, as divergências conceituais e estruturais são profundas.</p><p>Provavelmente a maior contribuição do modelo OSI foi tornar explícita a distinção entre três conceitos que, no TCP/IP original, não eram claramente separados. Essa distinção é vital para a arquitetura de software moderna e pode ser detalhada da seguinte forma:</p><table><thead><tr><th style=text-align:left>Conceito</th><th style=text-align:left>Definição e Função</th></tr></thead><tbody><tr><td style=text-align:left><strong>Serviços</strong></td><td style=text-align:left>Define a semântica da camada, ou seja, <strong>o que</strong> a camada faz e quais operações oferece à camada superior, sem revelar como funcionam.</td></tr><tr><td style=text-align:left><strong>Interfaces</strong></td><td style=text-align:left>Define <strong>como</strong> os processos superiores acessam os serviços, especificando parâmetros e resultados esperados, mantendo o funcionamento interno oculto.</td></tr><tr><td style=text-align:left><strong>Protocolos</strong></td><td style=text-align:left>Refere-se à implementação interna e <strong>como</strong> o trabalho é realizado. A camada pode alterar seus protocolos livremente, desde que mantenha o serviço e a interface inalterados.</td></tr></tbody></table><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Analogia com Programação Orientada a Objetos (POO)</span></div><div class=callout-content><p>Esses conceitos do OSI adaptam-se perfeitamente à POO:</p><ul><li><strong>Serviço</strong> = Conjunto de métodos públicos de um objeto (o que ele faz).</li><li><strong>Interface</strong> = Assinatura dos métodos (parâmetros e retornos).</li><li><strong>Protocolo</strong> = Código interno do método (implementação invisível externamente).</li></ul><p>O modelo TCP/IP, por ter sido criado com foco prático, possui protocolos menos encapsulados, dificultando alterações transparentes em comparação ao rigor do OSI.</p></div></div><p>A forma como cada modelo foi concebido influenciou diretamente sua adoção e generalidade. A tabela abaixo contrasta as abordagens de desenvolvimento:</p><table><thead><tr><th style=text-align:left>Característica</th><th style=text-align:left>Modelo OSI</th><th style=text-align:left>Modelo TCP/IP</th></tr></thead><tbody><tr><td style=text-align:left><strong>Cronologia</strong></td><td style=text-align:left>Modelo criado <strong>antes</strong> dos protocolos.</td><td style=text-align:left>Protocolos criados <strong>antes</strong> do modelo.</td></tr><tr><td style=text-align:left><strong>Vantagem</strong></td><td style=text-align:left>Genérico e não enviesado por uma tecnologia específica.</td><td style=text-align:left>Ajuste perfeito aos protocolos existentes, funcionando bem na prática.</td></tr><tr><td style=text-align:left><strong>Desvantagem</strong></td><td style=text-align:left>Projetistas tinham pouca experiência prática; exigiu adaptações (subcamadas) posteriores para funcionar na realidade.</td><td style=text-align:left>O modelo não se adapta bem a outras pilhas de protocolos que não sejam TCP/IP.</td></tr><tr><td style=text-align:left><strong>Foco Inicial</strong></td><td style=text-align:left>Redes controladas pelo governo e interconexão teórica.</td><td style=text-align:left>Interconexão de redes heterogêneas na prática.</td></tr></tbody></table><p>Além da diferença óbvia no número de camadas (sete no OSI contra quatro no TCP/IP), existe uma distinção crucial na filosofia de suporte a conexões. O modelo TCP/IP, focado na robustez e flexibilidade da Internet, prioriza a liberdade de escolha na camada de transporte, enquanto o OSI impõe restrições diferentes.</p><p>A matriz abaixo resume o suporte a serviços orientados e não orientados a conexão em cada modelo:</p><table><thead><tr><th style=text-align:left>Camada</th><th style=text-align:left>Abordagem do Modelo OSI</th><th style=text-align:left>Abordagem do Modelo TCP/IP</th></tr></thead><tbody><tr><td style=text-align:left><strong>Camada de Rede</strong></td><td style=text-align:left>Suporta ambos (Orientado e Não Orientado a Conexão).</td><td style=text-align:left>Suporta <strong>apenas</strong> Não Orientado a Conexão (foco no IP).</td></tr><tr><td style=text-align:left><strong>Camada de Transporte</strong></td><td style=text-align:left>Suporta <strong>apenas</strong> Orientado a Conexão.</td><td style=text-align:left>Suporta <strong>ambos</strong> (TCP orientado e UDP não orientado), oferecendo escolha ao usuário.</td></tr></tbody></table><p>Essa flexibilidade do TCP/IP na camada de transporte (permitindo protocolos simples de solicitação/resposta via UDP) provou-se essencial para aplicações modernas, contrastando com a rigidez do modelo OSI nessa camada específica.</p><h2 id=questões><span class=heading-text>Questões</span><span class=heading-arabic>3.6</span></h2><p><strong>1.</strong> Muitos iniciantes confundem a direção do fluxo de dados com o método de endereçamento. Considere um sistema de <strong>Rádio FM</strong> tradicional (onde a torre transmite e o rádio do carro recebe) e um sistema de <strong>Walkie-Talkie</strong> (onde você aperta um botão para falar e solta para ouvir).</p><ul><li><strong>a)</strong> Classifique ambos quanto à direção do fluxo (Simplex, Half-Duplex ou Full-Duplex).</li><li><strong>b)</strong> Classifique a torre de Rádio FM quanto ao endereçamento (Unicast, Multicast ou Broadcast).</li><li><strong>c)</strong> Explique por que uma conversa telefônica é considerada <em>Full-Duplex</em> e <em>Unicast</em> ao mesmo tempo.</li></ul><p><strong>2.</strong> Você foi contratado para projetar a rede de um pequeno escritório com 6 computadores. O cliente está indeciso entre uma topologia em <strong>Malha (Mesh)</strong> e uma em <strong>Estrela</strong>. Para ajudá-lo a decidir baseando-se no custo de cabeamento, calcule:</p><ul><li><strong>a)</strong> Quantos cabos físicos (links) são necessários para conectar os 6 computadores em uma topologia em Malha completa? (Use a fórmula $n(n-1)/2$).</li><li><strong>b)</strong> Quantos cabos são necessários para conectar os mesmos 6 computadores em uma topologia em Estrela (assumindo 1 hub central)?</li><li><strong>c)</strong> Qual a diferença absoluta no número de cabos entre as duas opções?</li></ul><p><strong>3.</strong> Uma empresa decide conectar 10 computadores em uma configuração de segurança máxima usando uma topologia em <strong>Malha (Mesh)</strong> completa, para garantir que a falha de um cabo nunca isole dois computadores.</p><ul><li><strong>a)</strong> Quantas portas de I/O (Input/Output) cada computador individual precisará ter instaladas para suportar essa configuração?</li><li><strong>b)</strong> Quantos links físicos (cabos) existirão no total nessa rede?</li><li><strong>c)</strong> Se a empresa adicionar apenas mais um computador (totalizando 11), quantos <strong>novos</strong> cabos precisarão ser instalados para manter a malha completa?</li></ul><p><strong>4.</strong> Analise uma rede montada em topologia de <strong>Barramento (Bus)</strong> contendo 15 estações de trabalho conectadas a um único cabo backbone.</p><ul><li><strong>a)</strong> Quantos <strong>terminadores</strong> são necessários fisicamente para que essa rede funcione corretamente, evitando a reflexão do sinal?</li><li><strong>b)</strong> Se o cabo backbone for rompido exatamente entre a 7ª e a 8ª estação, quantas estações continuarão aptas a se comunicar com todas as outras da rede? Justifique.</li></ul><p><strong>5.</strong> Considere uma rede em <strong>Anel</strong> unidirecional com 20 estações.</p><ul><li><strong>a)</strong> Quantas conexões físicas (links) existem no total para fechar o anel?</li><li><strong>b)</strong> Em termos de robustez, o que acontece com a rede se a estação número 5 sofrer uma falha de energia e desligar (considerando que ela atua como repetidora)?</li><li><strong>c)</strong> Como a topologia em <strong>Estrela</strong> isola esse tipo de falha de estação melhor que o Anel simples?</li></ul><p><strong>6.</strong> Considere o diagrama de fluxo de informação onde os dados descem as camadas. Suponha que um arquivo de 1.000 bytes precise ser enviado. O modelo de rede possui 5 camadas. Cada camada adiciona um cabeçalho ($H$) de 20 bytes ao processar a mensagem, e a camada de enlace (Camada 2) adiciona também um trailer ($T$) de 20 bytes.</p><ul><li><strong>a)</strong> Qual será o tamanho total do quadro transmitido fisicamente pelo meio?</li><li><strong>b)</strong> Qual é a porcentagem de <em>overhead</em> (informação de controle inútil para o usuário final) nessa transmissão?</li></ul><p><strong>7.</strong> Na analogia dos Filósofos-Tradutores-Secretárias apresentada no texto: Suponha que a camada 1 (Secretárias) decida parar de usar o Fax e comece a usar E-mail para enviar as mensagens.</p><ul><li><strong>a)</strong> Isso exige que a camada 2 (Tradutores) mude o idioma que eles usam (o protocolo)?</li><li><strong>b)</strong> Isso exige que a camada 3 (Filósofos) mudem a mensagem ("Gosto de coelhos")?</li><li><strong>c)</strong> Use essa analogia para explicar o conceito de <strong>independência de camadas</strong>.</li></ul><p><strong>8.</strong> O texto compara serviços orientados a conexão com o sistema telefônico e serviços não orientados com o sistema postal.</p><ul><li><strong>a)</strong> Cite duas aplicações modernas onde um serviço <strong>não confiável</strong> (sem confirmação de recebimento) e não orientado a conexão (UDP) é preferível a um serviço confiável. Justifique com base no conceito de atraso/tempo real.</li><li><strong>b)</strong> Por que o estabelecimento de conexão é necessário para garantir a entrega ordenada de pacotes?</li></ul><p><strong>9.</strong> O Modelo OSI introduziu uma distinção clara entre Serviço e Protocolo. Utilizando a analogia de <strong>Programação Orientada a Objetos</strong> apresentada no texto:</p><ul><li><strong>a)</strong> O que corresponde ao "Serviço"?</li><li><strong>b)</strong> O que corresponde ao "Protocolo"?</li><li><strong>c)</strong> Se um engenheiro alterar o algoritmo de criptografia interno de uma camada, ele alterou o serviço ou o protocolo?</li></ul><p><strong>10.</strong> Compare a <strong>Camada de Transporte</strong> nos modelos OSI e TCP/IP:</p><ul><li><strong>a)</strong> O modelo OSI permite que a camada de transporte use protocolos não orientados a conexão?</li><li><strong>b)</strong> O modelo TCP/IP permite que a camada de transporte use protocolos orientados a conexão?</li><li><strong>c)</strong> Qual dos dois modelos provou-se mais flexível para as aplicações modernas e por quê?</li></ul><p><strong>11.</strong> Em uma interação Cliente-Servidor confiável, seis pacotes são trocados para enviar uma única requisição e receber uma resposta (estabelecer, enviar, receber, desconectar). Se a conexão fosse "Não Orientada a Conexão" (Datagrama), quantos pacotes seriam trocados minimamente? Explique por que o modelo orientado a conexão, apesar de gerar mais tráfego, é usado para transferências bancárias.</p><p><strong>12.</strong> Identifique qual pilar de segurança (Confidencialidade, Autenticação ou Integridade) foi violado nos cenários a seguir:</p><ul><li><strong>a)</strong> Um atacante intercepta um pacote com valor de $10,00 e altera para $1.000,00.</li><li><strong>b)</strong> Um usuário acessa um site falso que imita seu banco para roubar senhas.</li><li><strong>c)</strong> Um espião industrial lê e-mails confidenciais sem alterá-los.</li></ul><p><strong>13.</strong> O texto define "Jitter" como uma das características fundamentais para a eficácia de um sistema de comunicação. Explique por que uma variação alta de <strong>Jitter</strong> é catastrófica para uma transmissão de TV via internet (IPTV), mas quase imperceptível para o download de um arquivo PDF.</p><p><strong>14.</strong> Na Camada de Rede (Modelo OSI ou Internet no TCP/IP), existem as funções de endereçamento e roteamento. Qual é a diferença técnica entre <strong>endereçar</strong> um pacote e <strong>rotear</strong> um pacote? Use a analogia do sistema de correios para explicar.</p><h2 id=próximos-passos><span class=heading-text>Próximos passos</span><span class=heading-arabic>3.7</span></h2><p>No próximo capítulo, <a href=4-physical-layer-and-wireless.html>Camada Física, Meios de Transmissão e Sem Fio</a>, mergulharemos na base da pilha de protocolos para compreender os princípios físicos da comunicação de dados, desde a modulação de sinais até as propriedades dos meios guiados (cobre, fibra) e não guiados (rádio). Esse entendimento será a base necessária para analisarmos, na sequência, como a Camada de Enlace transforma essa transmissão bruta de bits em um fluxo de dados confiável e organizado.</p></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Redes`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>