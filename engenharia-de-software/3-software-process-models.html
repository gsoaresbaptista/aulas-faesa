<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Engenharia de Software</title><link media="(prefers-color-scheme: light)" href=/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Engenharia de Software</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#introdução>3.1. Introdução</a></li><li class="toc-item level-2"><a href=#modelos-de-processo-de-software>3.2. Modelos de Processo de Software</a></li><li class="toc-item level-3"><a href=#o-modelo-em-cascata-waterfall>3.2.1. O Modelo em Cascata (Waterfall)</a></li><li class="toc-item level-3"><a href=#desenvolvimento-incremental>3.2.2. Desenvolvimento Incremental</a></li><li class="toc-item level-3"><a href=#engenharia-de-software-orientada-a-reúso>3.2.3. Engenharia de Software Orientada a Reúso</a></li><li class="toc-item level-2"><a href=#atividades-do-processo>3.3. Atividades do Processo</a></li><li class="toc-item level-3"><a href=#especificação-de-software>3.3.1. Especificação de Software</a></li><li class="toc-item level-3"><a href=#projeto-e-implementação-de-software>3.3.2. Projeto e Implementação de Software</a></li><li class="toc-item level-3"><a href=#validação-de-software>3.3.3. Validação de Software</a></li><li class="toc-item level-3"><a href=#evolução-de-software>3.3.4. Evolução de Software</a></li><li class="toc-item level-2"><a href=#lidando-com-mudanças>3.4. Lidando com Mudanças</a></li><li class="toc-item level-3"><a href=#prototipação>3.4.1. Prototipação</a></li><li class="toc-item level-3"><a href=#entrega-incremental>3.4.2. Entrega Incremental</a></li><li class="toc-item level-3"><a href=#o-modelo-espiral-de-boehm>3.4.3. O Modelo Espiral de Boehm</a></li><li class="toc-item level-2"><a href=#rational-unified-process-rup>3.5. Rational Unified Process (RUP)</a></li><li class="toc-item level-2"><a href=#questões>3.6. Questões</a></li><li class="toc-item level-2"><a href=#próximos-passos>3.7. Próximos Passos</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=2-introduction-to-software-engineering.html><i class=nav-icon data-lucide=chevron-left></i> Introdução à Engenharia de Software</a><a class="sidebar-nav-link next" href=4-agile-development.html>Desenvolvimento Ágil: Scrum e XP <i class=nav-icon data-lucide=chevron-right></i></a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>3</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>Modelos de Processos de Software</span> <span class="title-ornament right">❧</span></h1><p class=article-date>02/01/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Engenharia de Software</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-I>I - Processos de Software</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>Modelos de Processos de Software</span></nav></header><div class=article-body><h2 id=introdução><span class=heading-text>Introdução</span><span class=heading-arabic>3.1</span></h2><p>Neste capítulo, vamos mergulhar no conceito fundamental de <strong>processo de software</strong>. Se você já tentou desenvolver um programa complexo sem um plano claro, provavelmente percebeu que a codificação, por si só, é apenas a ponta do iceberg. Para que um software seja robusto, gerenciável, economicamente viável e atenda às reais necessidades do cliente, precisamos de muito mais do que apenas linhas de código: precisamos de um processo estruturado.</p><p>Podemos definir um processo de software como um conjunto coerente de atividades necessárias para transformar uma necessidade abstrata em um produto de software funcional. Pense nele como o roteiro mestre que guia a sua equipe desde a ideia inicial até a entrega final e a manutenção contínua do sistema. Embora existam milhares de processos diferentes na indústria (adaptados para empresas gigantescas, agências governamentais ou startups ágeis), todos eles compartilham quatro atividades fundamentais que formam a espinha dorsal da engenharia de software:</p><ol><li><strong>Especificação de software:</strong> O momento onde definimos rigorosamente o que o sistema deve fazer e, tão importante quanto, quais são suas restrições de operação e desenvolvimento.</li><li><strong>Projeto e implementação:</strong> A fase criativa e técnica onde o sistema é arquitetado, organizado em módulos e efetivamente construído.</li><li><strong>Validação de software:</strong> A etapa crítica onde garantimos que o software faz o que o cliente pediu (validação) e que foi construído corretamente (verificação).</li><li><strong>Evolução de software:</strong> A realidade inevitável de que o software precisa mudar ao longo do tempo para acompanhar as novas demandas do mercado e do mundo real.</li></ol><p>É importante ressaltar que, na prática, essas quatro atividades não são tarefas simples ou isoladas. Elas são processos complexos em si mesmas, compostas por diversas <strong>subatividades</strong> (como validação de requisitos, projeto de arquitetura e testes unitários). Além disso, elas coexistem com <strong>atividades de apoio</strong> essenciais, como a documentação do sistema e o gerenciamento de configuração de software.</p><p>Para descrever um processo de software de forma completa, não basta listar <em>o que</em> é feito (as atividades). Precisamos entender a estrutura ao redor delas. Assim, uma descrição robusta de processo geralmente inclui:</p><ul><li><strong>Produtos (Artefatos):</strong> São os resultados tangíveis de uma atividade. Por exemplo, o resultado da atividade de projeto de arquitetura pode ser um modelo visual da arquitetura de software.</li><li><strong>Papéis:</strong> Definem <em>quem</em> faz o quê, refletindo as responsabilidades das pessoas envolvidas (ex: gerente de projeto, gerente de configuração, programador).</li><li><strong>Pré e pós-condições:</strong> São declarações que precisam ser verdadeiras antes e depois de uma atividade.<ul><li><em>Exemplo:</em> Antes de iniciar o projeto de arquitetura, uma <strong>pré-condição</strong> pode ser que "todos os requisitos foram aprovados pelo cliente". Após a conclusão, uma <strong>pós-condição</strong> seria que "os modelos UML da arquitetura foram revisados".</li></ul></li></ul><p>Ao longo desta leitura, você verá que, embora esses componentes sejam universais, a forma como os organizamos e encadeamos pode variar drasticamente. Alguns processos são <strong>dirigidos a planos</strong> (onde todas as atividades, produtos e pré-condições são planejados e documentados com antecedência), enquanto outros são <strong>ágeis</strong> (onde o planejamento é incremental, iterativo e adaptativo). É crucial que você entenda que não existe um "jeito certo" universal, mas existe o jeito mais adequado para o contexto específico do seu projeto e da sua equipe.</p><h2 id=modelos-de-processo-de-software><span class=heading-text>Modelos de Processo de Software</span><span class=heading-arabic>3.2</span></h2><p>Um modelo de processo de software é, essencialmente, uma representação simplificada ou uma abstração de um processo real. Pense neles como <em>frameworks</em> conceituais que você pode estender e adaptar para criar o processo específico de trabalho da sua organização. Vamos analisar três paradigmas gerais que influenciam a maioria dos métodos modernos de desenvolvimento.</p><p>É crucial entender que <strong>esses modelos não são mutuamente exclusivos</strong>. Na prática, eles são frequentemente usados em conjunto, especialmente no desenvolvimento de <strong>sistemas de grande porte</strong>, onde faz sentido combinar as melhores características do modelo em cascata (previsibilidade) e dos modelos de desenvolvimento incremental (flexibilidade).</p><p>Por exemplo, considere a arquitetura e os subsistemas:</p><ul><li><strong>Arquitetura e Requisitos Estáveis:</strong> Você precisa de informações sólidas sobre os requisitos essenciais para projetar uma arquitetura de software que suporte o sistema. Essa base não pode ser desenvolvida de forma puramente incremental; aqui, uma abordagem mais rígida (como o modelo em cascata) é necessária para partes bem compreendidas.</li><li><strong>Interfaces e Incertezas:</strong> Por outro lado, subsistemas difíceis de especificar antecipadamente, como a interface com o usuário (onde o feedback visual é vital), devem sempre ser desenvolvidos através de uma abordagem incremental.</li></ul><p>Com essa flexibilidade em mente, sabendo que subsistemas diferentes podem exigir abordagens diferentes, vamos analisar três paradigmas gerais que influenciam a maioria dos métodos modernos de desenvolvimento.</p><h3 id=o-modelo-em-cascata-waterfall><span class=heading-text>O Modelo em Cascata (Waterfall)</span><span class=heading-arabic>3.2.1</span></h3><p>O primeiro modelo de processo de desenvolvimento de software a ser publicado foi derivado da engenharia de sistemas (ROYCE, 1970) e é conhecido como modelo em cascata ou ciclo de vida de software. Ele é um exemplo clássico de um processo dirigido a planos, onde se deve planejar e programar todas as atividades antes de iniciá-las. A principal característica desse modelo é o encadeamento sequencial das fases, onde cada estágio alimenta o próximo, conforme ilustrado na figura abaixo:</p><p><img src=static/waterfall_model.png width=75%></p><p>Os principais estágios deste modelo refletem diretamente as atividades fundamentais do desenvolvimento:</p><ol><li><strong>Análise e definição de requisitos:</strong> Os serviços, restrições e metas são estabelecidos com os usuários e definidos como uma especificação detalhada.</li><li><strong>Projeto de sistema e software:</strong> Aloca-se os requisitos para hardware e software, definindo a arquitetura e descrevendo as abstrações fundamentais do sistema.</li><li><strong>Implementação e teste unitário:</strong> O projeto é desenvolvido em unidades de programa, verificando se cada uma atende à sua especificação.</li><li><strong>Integração e teste de sistema:</strong> As unidades são integradas e testadas como um sistema completo para assegurar o cumprimento dos requisitos antes da entrega.</li><li><strong>Operação e manutenção:</strong> Fase geralmente mais longa, onde o sistema é usado, erros são corrigidos e novos requisitos são implementados.</li></ol><p>Embora o modelo sugira que um estágio só comece após a aprovação documental do anterior, na prática, essas fases se sobrepõem e trocam informações constantemente. No entanto, devido aos custos de alterar documentos e iterar, é comum "congelar" especificações prematuramente para avançar, o que pode levar a sistemas que não atendem bem ao usuário se os requisitos mudarem. Por sua inflexibilidade, o modelo em cascata é mais adequado para projetos onde os requisitos são bem compreendidos e estáveis, sendo ainda muito utilizado por facilitar o monitoramento gerencial através da documentação produzida em cada fase.</p><p>Uma variação importante deste modelo é o desenvolvimento formal de sistemas, onde se cria um modelo matemático da especificação que é refinado em código executável através de transformações que preservam a consistência. Essa abordagem, vista em métodos como o método B, é ideal para sistemas críticos de segurança e proteção, pois permite demonstrar matematicamente que o programa corresponde à especificação. Contudo, devido à necessidade de conhecimentos especializados e alto custo, ela geralmente não oferece um bom custo-benefício para a maioria dos sistemas que não possuem requisitos críticos de segurança.</p><h3 id=desenvolvimento-incremental><span class=heading-text>Desenvolvimento Incremental</span><span class=heading-arabic>3.2.2</span></h3><p>O desenvolvimento incremental baseia-se na ideia de criar uma implementação inicial, expô-la aos comentários dos usuários e evoluí-la através de várias versões até que um sistema adequado seja finalizado. Diferente do modelo em cascata, aqui as atividades de especificação, desenvolvimento e validação são intercaladas e ocorrem simultaneamente, permitindo um rápido feedback entre elas, conforme ilustrado na figura abaixo:</p><p><img src=static/incremental_model.png width=75%></p><p>Essa abordagem é fundamental para as metodologias ágeis e reflete a maneira natural como os seres humanos resolvem problemas: avançando passo a passo e corrigindo o curso conforme necessário, em vez de planejar uma solução completa antecipadamente. Isso a torna superior ao modelo em cascata para sistemas de negócios e e-commerce. Ao priorizar as funcionalidades mais importantes ou urgentes nos primeiros incrementos, o cliente pode avaliar o sistema cedo; caso haja problemas, apenas o incremento atual precisa ser alterado, tornando as mudanças durante o desenvolvimento mais baratas e fáceis do que as correções tardias de um processo linear.</p><p>Em comparação ao modelo em cascata, o desenvolvimento incremental oferece três grandes vantagens: reduz o custo de acomodar mudanças nos requisitos (menos retrabalho de documentação), facilita o feedback do cliente (que pode avaliar software funcionando em vez de documentos abstratos) e permite a entrega rápida de software útil, gerando valor antes mesmo da conclusão total. Essa abordagem pode ser gerenciada de forma dirigida a planos (com incrementos definidos previamente) ou de forma ágil (onde os incrementos futuros dependem do progresso e das prioridades do cliente), sendo esta última a mais comum atualmente para sistemas aplicativos.</p><p>No entanto, do ponto de vista gerencial, o modelo apresenta desafios. O processo é menos visível, pois não é economicamente viável produzir documentação detalhada para cada versão rápida, dificultando a mensuração do progresso. Além disso, a estrutura do sistema tende a degradar com as constantes adições, exigindo investimento contínuo em refatoração para evitar que futuras mudanças se tornem onerosas. Esses problemas são críticos em sistemas grandes e complexos (sistemas de vida longa), onde uma arquitetura estável deve ser planejada antecipadamente para coordenar múltiplas equipes, e não desenvolvida incrementalmente. Por fim, é importante notar que desenvolvimento incremental é diferente de entrega incremental: você pode desenvolver em etapas para obter feedback sem necessariamente implantar cada versão no ambiente operacional do cliente, o que evita a interrupção frequente dos processos de negócios normais.</p><h3 id=engenharia-de-software-orientada-a-reúso><span class=heading-text>Engenharia de Software Orientada a Reúso</span><span class=heading-arabic>3.2.3</span></h3><p>Na maioria dos projetos, o reúso de código acontece de maneira informal, mas atualmente, processos formalizados com foco no reúso tornaram-se amplamente utilizados. Essas abordagens dependem de uma base de componentes existentes (que podem variar desde Web services e coleções de objetos para frameworks como .NET ou J2EE, até sistemas completos do tipo COTS) e de um framework de integração. Um modelo geral desse processo é apresentado na Figura 2.3 abaixo, onde, diferentemente dos modelos tradicionais, os estágios intermediários são adaptados para capitalizar sobre o que já existe:</p><p><img src=static/orientado_a_reuso_model.png width=75%></p><p>Apesar das etapas iniciais serem bem parecidas com os métodos anteriores, o processo segue quatro etapas distintas após a especificação inicial do sistema:</p><ol><li><strong>Análise de componentes:</strong> Busca-se componentes que atendam à especificação, muitas vezes encontrando correspondências parciais.</li><li><strong>Modificação de requisitos:</strong> Os requisitos são alterados para se adequarem aos componentes disponíveis, podendo reiniciar a busca se necessário.</li><li><strong>Projeto do sistema com reúso:</strong> O framework é projetado ou escolhido considerando os componentes selecionados, criando novos softwares apenas se não houver opção de reúso.</li><li><strong>Desenvolvimento e integração:</strong> Integra-se os componentes (incluindo sistemas COTS) e desenvolve-se o código faltante.</li></ol><p>A principal vantagem dessa abordagem é a redução de custos, riscos e do tempo de entrega, uma vez que há menos software a ser desenvolvido do zero. No entanto, isso traz desvantagens inerentes: inevitavelmente ocorrem compromissos nos requisitos, o que pode resultar em um sistema que não atende perfeitamente às necessidades reais do usuário, além da perda de controle sobre a evolução do sistema, já que as atualizações dos componentes reutilizados ficam a cargo de terceiros e não da organização que os utiliza.</p><h2 id=atividades-do-processo><span class=heading-text>Atividades do Processo</span><span class=heading-arabic>3.3</span></h2><p>Agora que entendemos os "formatos" (os modelos), precisamos olhar mais de perto para o "conteúdo": as atividades técnicas reais que ocorrem dentro desses processos, independentemente do modelo escolhido.</p><h3 id=especificação-de-software><span class=heading-text>Especificação de Software</span><span class=heading-arabic>3.3.1</span></h3><p>A especificação de software, ou engenharia de requisitos, é o processo crítico de compreender e definir os serviços que o sistema deve prestar e as restrições sob as quais deve operar. Como erros nesta fase geram problemas inevitáveis no projeto e implementação, o objetivo é produzir um documento de requisitos acordado que satisfaça os stakeholders. Esses requisitos são apresentados em dois níveis de detalhe: declarações de alto nível para usuários finais e clientes, e especificações detalhadas para os desenvolvedores do sistema. O fluxo desse processo é ilustrado na figura abaixo:</p><p><img src=static/requisitos_eng_processos.png width=80%></p><p>O processo engloba quatro atividades principais: o <strong>estudo de viabilidade</strong>, uma análise rápida e econômica para decidir se o projeto é tecnicamente possível e financeiramente rentável; a <strong>elicitação e análise</strong>, que deriva os requisitos através de observação, discussões e modelos de sistema; a <strong>especificação</strong>, que traduz a análise em um documento formal contendo requisitos de usuário (abstratos) e de sistema (detalhados); e a <strong>validação</strong>, que checa a completude, consistência e realismo dos requisitos para corrigir erros. Embora apresentadas sequencialmente, na prática essas atividades são intercaladas e contínuas, especialmente em métodos ágeis, onde os requisitos são desenvolvidos incrementalmente com a participação ativa do usuário na equipe.</p><h3 id=projeto-e-implementação-de-software><span class=heading-text>Projeto e Implementação de Software</span><span class=heading-arabic>3.3.2</span></h3><p>O estágio de implementação é o processo de conversão de uma especificação em um sistema executável, envolvendo atividades de projeto e programação que, em abordagens incrementais, também refinam a própria especificação. O projeto de software descreve a estrutura, dados, interfaces e algoritmos do sistema, desenvolvendo-se de forma iterativa à medida que detalhes e formalidade são adicionados. Conforme ilustrado na figura abaixo, esse processo depende de entradas essenciais como informações da plataforma (sistema operacional, banco de dados), especificações de requisitos e descrições de dados. Embora o modelo sugira um fluxo sequencial, na realidade as atividades são intercaladas, com feedback constante entre os estágios.</p><p><img src=static/projeto_e_implementaca_2_5.png width=80%></p><p>Para sistemas de informação, o processo de projeto geralmente engloba quatro atividades fundamentais: (1) <strong>Projeto de arquitetura</strong>, que define a estrutura global e os relacionamentos entre os principais subsistemas; (2) <strong>Projeto de interface</strong>, que estabelece especificações inequívocas permitindo que componentes sejam desenvolvidos independentemente sem conhecimento de suas implementações internas; (3) <strong>Projeto de componente</strong>, que detalha o funcionamento específico de cada parte, podendo variar de declarações simples a modelos detalhados para geração automática; e (4) <strong>Projeto de banco de dados</strong>, que estrutura a representação dos dados do sistema.</p><p>As saídas desse processo variam drasticamente conforme a metodologia: sistemas críticos exigem documentação detalhada, abordagens dirigidas a modelos (MDD) focam em diagramas capazes de gerar código, e métodos ágeis muitas vezes consideram o próprio código como a documentação de projeto. A programação em si é uma atividade pessoal sem um processo universal, onde cada desenvolvedor adota sua própria estratégia (como focar primeiro nos dados ou nas funcionalidades mais difíceis). Durante essa fase, os programadores realizam testes para revelar falhas e executam o <em>debugging</em>, o processo de localizar e corrigir esses defeitos através da formulação e teste de hipóteses sobre o comportamento do software.</p><h3 id=validação-de-software><span class=heading-text>Validação de Software</span><span class=heading-arabic>3.3.3</span></h3><p>A validação de software, ou genericamente verificação e validação (V&V), tem o objetivo de demonstrar que o software atende tanto às suas especificações técnicas (verificação) quanto às necessidades reais do cliente (validação). Embora inclua processos de inspeção e revisão em várias fases, a principal técnica utilizada é o teste de programa, que consome a maior parte dos custos desta etapa. Como sistemas complexos não devem ser testados como uma unidade monolítica, o processo é dividido em estágios iterativos onde defeitos são descobertos, corrigidos e retestados, conforme ilustrado abaixo:</p><img src=static/fig2_6_estagios_testes.png width=75%><p>Os estágios fundamentais do processo de teste são:</p><ol><li><strong>Testes de desenvolvimento:</strong> Realizados pelos próprios desenvolvedores de forma independente em cada componente (funções ou classes), frequentemente utilizando ferramentas de automação como JUnit.</li><li><strong>Testes de sistema:</strong> Os componentes são integrados para formar o sistema completo (ou subsistemas em projetos maiores). O foco aqui é encontrar erros de interface, interações inesperadas e validar requisitos funcionais e não funcionais.</li><li><strong>Testes de aceitação:</strong> O estágio final antes do uso operacional, onde o sistema é testado com dados reais fornecidos pelo cliente, e não dados simulados. Isso pode revelar erros na definição dos requisitos e problemas de desempenho que não apareceram nos testes anteriores.</li></ol><p>A execução desses testes varia conforme a metodologia. Em abordagens incrementais e ágeis (como XP), os testes são intercalados com o desenvolvimento, muitas vezes escritos antes mesmo do código, garantindo feedback rápido. Já em processos dirigidos a planos, comuns em sistemas críticos, os testes são guiados por planos pré-formulados que ligam as fases de especificação e projeto às fases de teste correspondentes. Esse relacionamento é frequentemente representado pelo "Modelo V":</p><img src=static/fig2_7_modelo_v.png width=90%><p>Por fim, a validação de entrega assume formas diferentes dependendo do destino do software. Para sistemas sob encomenda, realiza-se o <strong>teste alfa</strong>, que continua até que desenvolvedor e cliente concordem que os requisitos foram atendidos. Para produtos de mercado, utiliza-se o <strong>teste beta</strong>, onde o software é liberado para um grupo de usuários potenciais que relatam problemas e bugs não antecipados em uso real, permitindo ajustes antes da venda geral.</p><h3 id=evolução-de-software><span class=heading-text>Evolução de Software</span><span class=heading-arabic>3.3.4</span></h3><p>A flexibilidade inerente ao software é o principal motivo de sua incorporação em sistemas grandes e complexos. Ao contrário do hardware, onde alterações de projeto se tornam proibitivamente caras após a decisão de fabricação, o software permite mudanças a qualquer momento durante ou após o desenvolvimento. Mesmo modificações significativas no código são consideravelmente mais baratas do que as correspondentes alterações físicas no hardware. Historicamente, estabeleceu-se uma distinção entre o "desenvolvimento" (visto como uma atividade criativa de concepção inicial) e a "manutenção" (vista como uma tarefa maçante de correção). No entanto, essa visão é enganosa, pois os custos de manutenção frequentemente superam os custos de criação original.</p><p>Atualmente, a separação rígida entre desenvolvimento e manutenção tornou-se irrelevante, uma vez que poucos sistemas são construídos inteiramente do zero. É mais realista e eficaz encarar a engenharia de software como um processo evolutivo contínuo, onde a linha entre criar e manter deixa de existir. O software deve ser visualizado como um organismo vivo que é constantemente alterado durante todo o seu ciclo de vida para responder às mudanças de requisitos e novas necessidades do cliente, conforme ilustrado na figura abaixo:</p><img src=static/fig2_8_processo_evolutivo.png width=90%><h2 id=lidando-com-mudanças><span class=heading-text>Lidando com Mudanças</span><span class=heading-arabic>3.4</span></h2><p>A mudança é uma realidade inevitável em grandes projetos de software, impulsionada por alterações nos requisitos, pressões de negócio e novas tecnologias. Independentemente do modelo de processo adotado, é essencial que ele acomode essas modificações, pois a mudança gera "retrabalho", a necessidade de refazer análises, projetos e testes, o que inevitavelmente eleva os custos de desenvolvimento. Para mitigar esses custos, existem duas abordagens principais: a <strong>prevenção de mudanças</strong>, que busca antecipar alterações (por exemplo, através de protótipos que refinam requisitos antes de gastos elevados), e a <strong>tolerância a mudanças</strong>, que projeta o processo para acomodar alterações a baixo custo, permitindo, por exemplo, que modificações sejam aplicadas em incrementos ainda não desenvolvidos.</p><p>Duas técnicas específicas instrumentalizam essas abordagens. A <strong>prototipação de sistema</strong> foca na prevenção, desenvolvendo rapidamente uma versão para validar necessidades e decisões de projeto, permitindo que usuários refinem requisitos antes da entrega final e reduzindo propostas de alteração tardias. Já a <strong>entrega incremental</strong> suporta tanto a prevenção quanto a tolerância: ao entregar partes do sistema para experimentação, evita-se o compromisso prematuro com requisitos totais e permite-se que mudanças sejam incorporadas em incrementos futuros com baixo impacto financeiro. Vale mencionar também a refatoração, que melhora a estrutura do código para suportar mudanças contínuas (tema aprofundado em métodos ágeis).</p><h3 id=prototipação><span class=heading-text>Prototipação</span><span class=heading-arabic>3.4.1</span></h3><p>Aqui está o texto reescrito:</p><p>Um protótipo é uma versão inicial de um sistema utilizada para demonstrar conceitos, experimentar opções de projeto e descobrir mais sobre o problema antes da construção final. O desenvolvimento rápido e iterativo dessa versão é essencial para controlar custos e permitir que os stakeholders validem os requisitos no início do processo. Na engenharia de requisitos, o protótipo auxilia na elicitação e validação, revelando erros e omissões que descrições textuais não conseguem captar, especialmente quando funcionalidades interagem. No projeto de sistema, ele é vital para verificar a viabilidade técnica (como desempenho de banco de dados) e, fundamentalmente, para o design de interfaces de usuário, onde diagramas estáticos são insuficientes para expressar a dinâmica de uso.</p><p>O processo de desenvolvimento de protótipos deve ter objetivos explícitos desde o início, seja validar requisitos ou testar uma interface, para garantir que gerentes e usuários compreendam seu propósito. Para reduzir custos e acelerar a entrega, é comum relaxar requisitos não funcionais, como desempenho, robustez e tratamento de erros, focando apenas no que é necessário para a avaliação. O fluxo desse processo é ilustrado abaixo:</p><img src=static/fig2_9_processo_prototipo.png width=90%><p>A fase final envolve a avaliação, onde usuários são treinados para testar o sistema. Contudo, há riscos: o comportamento do usuário no protótipo pode diferir do uso real devido a problemas de desempenho da versão de teste. Um perigo ainda maior ocorre quando gerentes pressionam para transformar um protótipo descartável (frequentemente sem documentação, com estrutura degradada e qualidade relaxada) no sistema final. Para evitar esses custos e riscos de código, pode-se recorrer a protótipos de baixa fidelidade, como maquetes em papel ou a técnica "Mágico de Oz", que simulam a interação sem a necessidade de software executável.</p><h3 id=entrega-incremental><span class=heading-text>Entrega Incremental</span><span class=heading-arabic>3.4.2</span></h3><p>A entrega incremental é uma abordagem onde incrementos desenvolvidos são entregues e implantados para uso real em um ambiente operacional, diferindo da simples prototipação. O processo começa com os clientes identificando e priorizando os serviços desejados; os de maior prioridade são detalhados e desenvolvidos primeiro. Uma vez iniciado o desenvolvimento de um incremento, seus requisitos são congelados, embora a análise para incrementos futuros continue. Conforme cada parte é concluída, ela é integrada e entregue, permitindo que o cliente utilize as funcionalidades mais críticas imediatamente e forneça feedback baseado na experiência real para guiar as próximas fases. O fluxo desse processo é ilustrado abaixo:</p><img src=static/fig2_10_entrega_incremental.png width=90%><p>Essa estratégia oferece vantagens significativas: ao contrário de protótipos descartáveis, o cliente ganha experiência com o sistema real sem necessidade de reaprendizado posterior, e o valor do negócio é entregue cedo. Além disso, como os incrementos de alta prioridade são os primeiros a serem entregues e permanecem em uso enquanto o resto é construído, eles recebem a maior carga de testes, reduzindo drasticamente a probabilidade de falhas nas partes mais importantes do sistema.</p><p>Entretanto, a entrega incremental apresenta desafios estruturais e gerenciais. Tecnicamente, é difícil identificar recursos básicos comuns (infraestrutura) necessários para todos os módulos quando não se tem uma especificação detalhada de todo o sistema no início. Operacionalmente, é difícil substituir sistemas legados, pois usuários relutam em trocar um sistema completo antigo por um novo ainda incompleto. Contratualmente, o modelo gera conflitos com departamentos de compras de grandes organizações e governos, que exigem especificações completas antes de assinar contratos, algo inexistente nessa abordagem até a fase final. Por essas razões, a entrega incremental não é ideal para sistemas muito grandes com equipes distribuídas, sistemas embutidos dependentes de hardware simultâneo ou sistemas críticos de segurança que exigem análise completa prévia; para estes, o uso de prototipagem iterativa prévia para definir requisitos fixos ainda é a melhor solução.</p><h3 id=o-modelo-espiral-de-boehm><span class=heading-text>O Modelo Espiral de Boehm</span><span class=heading-arabic>3.4.3</span></h3><p>Proposto por Boehm (1988), o modelo em espiral é um framework de processo de software dirigido a riscos, onde o fluxo é representado não como uma sequência linear, mas como uma espiral em que cada volta corresponde a uma fase distinta do processo, partindo da viabilidade até o projeto detalhado. Diferentemente de outros modelos, este combina estratégias de prevenção e tolerância a mudanças ao assumir que as modificações são geralmente resultados de riscos de projeto, incorporando assim atividades explícitas de gerenciamento para mitigá-los. A estrutura desse modelo é ilustrada abaixo:</p><img src=static/fig2_11_modelo_espiral.png width=90%><p>Cada ciclo da espiral é dividido em quatro setores fundamentais:</p><ul><li>(1) <strong>Definição de objetivos</strong>, onde metas específicas, restrições e um plano de gerenciamento são elaborados juntamente com a identificação dos riscos;</li><li>(2) <strong>Avaliação e redução de riscos</strong>, fase analítica onde medidas como a criação de protótipos são tomadas para mitigar incertezas (como requisitos inadequados);</li><li>(3) <strong>Desenvolvimento e validação</strong>, onde o modelo de desenvolvimento é escolhido dinamicamente com base no risco dominante, por exemplo, usando métodos formais se o risco for segurança, ou o modelo em cascata se o risco for integração; e</li><li>(4) <strong>Planejamento</strong>, onde o projeto é revisado e decide-se se deve avançar para a próxima volta da espiral.</li></ul><p>A grande inovação deste modelo é o reconhecimento explícito de que "risco" (algo que pode dar errado, como prazos, custos ou falhas técnicas) deve guiar o processo, resolvendo incertezas através de coleta de informações e simulação antes da construção efetiva.</p><h2 id=rational-unified-process-rup><span class=heading-text>Rational Unified Process (RUP)</span><span class=heading-arabic>3.5</span></h2><p>O Rational Unified Process (RUP) é um modelo de processo moderno e híbrido, derivado da UML, que combina elementos de modelos genéricos, boas práticas de especificação e suporte à prototipação e entrega incremental. Diferente dos modelos convencionais que apresentam uma visão única, o RUP é estruturado em três perspectivas: uma <strong>dinâmica</strong> (fases ao longo do tempo), uma <strong>estática</strong> (atividades ou <em>workflows</em>) e uma <strong>prática</strong> (melhores práticas recomendadas).</p><p>Sob a perspectiva dinâmica, o RUP divide o ciclo de vida em quatro fases distintas, que são orientadas aos objetivos de negócio e não apenas a tarefas técnicas. A iteração é suportada tanto dentro de cada fase quanto no ciclo completo (da transição de volta à concepção). As fases são:</p><ol><li><strong>Concepção:</strong> O foco é estabelecer o <em>business case</em>, identificar interações externas e avaliar se o projeto é viável e contribui para o negócio; caso contrário, é cancelado aqui.</li><li><strong>Elaboração:</strong> Busca-se compreender o problema, estabelecer a arquitetura base, planejar o projeto e identificar/mitigar os maiores riscos. O resultado é um modelo de requisitos e arquitetura sólidos.</li><li><strong>Construção:</strong> Envolve o projeto detalhado, programação e testes. As partes são desenvolvidas em paralelo e integradas, resultando em um software funcional e documentado.</li><li><strong>Transição:</strong> A fase final transfere o sistema para o ambiente real do usuário. Diferente de outros modelos que ignoram essa etapa cara e complexa, o RUP a torna explícita para garantir o funcionamento operacional.</li></ol><img src=static/fig2_12_fases_rup.png width=90%><p>A grande inovação do RUP reside na separação entre essas fases e os <em>workflows</em> (perspectiva estática). Enquanto as fases são temporais, os <em>workflows</em> são atividades técnicas (como Modelagem de Negócios, Requisitos, Análise, Implementação, Teste e Implantação, além dos processos de apoio como Gerência de Configuração e Projeto) que ocorrem durante todo o projeto. Isso significa que não existe uma "fase de requisitos" isolada; o <em>workflow</em> de requisitos acontece em todas as fases, apenas com maior intensidade no início e menor no fim.</p><p>Por fim, a perspectiva prática do RUP prescreve seis boas práticas fundamentais para a engenharia de software moderna:</p><ol><li><strong>Desenvolver software iterativamente:</strong> Planejar incrementos baseados nas prioridades do cliente e riscos.</li><li><strong>Gerenciar requisitos:</strong> Documentar explicitamente e controlar as mudanças e seus impactos.</li><li><strong>Usar arquiteturas baseadas em componentes:</strong> Estruturar o sistema em módulos reutilizáveis.</li><li><strong>Modelar visualmente (UML):</strong> Utilizar diagramas gráficos para representar as visões estáticas e dinâmicas.</li><li><strong>Verificar a qualidade:</strong> Garantir conformidade com padrões organizacionais continuamente.</li><li><strong>Controlar mudanças:</strong> Utilizar sistemas de gerenciamento de configuração para lidar com a evolução do software.</li></ol><h2 id=questões><span class=heading-text>Questões</span><span class=heading-arabic>3.6</span></h2><p><strong>1.</strong> Justificando sua resposta com base no tipo de sistema a ser desenvolvido, sugira o modelo genérico de processo de software mais adequado para ser usado como base para a gerência do desenvolvimento dos sistemas a seguir:</p><ul><li>Um sistema para controlar o antibloqueio de frenagem de um carro.</li><li>Um sistema de realidade virtual para dar apoio à manutenção de software.</li><li>Um sistema de contabilidade para uma universidade, que substitua um sistema já existente.</li><li>Um sistema interativo de planejamento de viagens que ajude os usuários a planejar viagens com menor impacto ambiental.</li></ul><p><strong>2.</strong> Explique por que o desenvolvimento incremental é o método mais eficaz para o desenvolvimento de sistemas de software de negócios. Por que esse modelo é menos adequado para a engenharia de sistemas de tempo real?</p><p><strong>3.</strong> Considere o modelo de processo baseado em reúso. Explique por que, nesse processo, é essencial ter duas atividades distintas de engenharia de requisitos.</p><p><strong>4.</strong> Sugira por que é importante, no processo de engenharia de requisitos, fazer uma distinção entre desenvolvimento dos requisitos do usuário e desenvolvimento de requisitos de sistema.</p><p><strong>5.</strong> Descreva as principais atividades do processo de projeto de software e as saídas dessas atividades. Usando um diagrama (ou descrição visual), mostre as possíveis relações entre as saídas dessas atividades.</p><p><strong>6.</strong> Explique por que, em sistemas complexos, as mudanças são inevitáveis. Exemplifique as atividades de processo de software que ajudam a prever as mudanças e fazer com que o software seja desenvolvido mais tolerante a mudanças (nesta resposta, desconsidere a prototipação e a entrega incremental).</p><p><strong>7.</strong> Explique por que os sistemas desenvolvidos como protótipos normalmente não devem ser usados como sistemas de produção.</p><p><strong>8.</strong> Explique por que o modelo em espiral de Boehm é um modelo adaptável, que apoia tanto as atividades de prevenção de mudanças quanto as de tolerância a mudanças. Na prática, esse modelo não tem sido amplamente usado. Sugira as possíveis razões para isso.</p><p><strong>9.</strong> Quais são as vantagens de proporcionar visões estáticas e dinâmicas do processo de software, assim como no Rational Unified Process (RUP)?</p><p><strong>10.</strong> Historicamente, a introdução de tecnologia provocou mudanças profundas no mercado de trabalho e, pelo menos temporariamente, deixou muitas pessoas desempregadas. Discuta se a introdução da automação extensiva em processos pode vir a ter as mesmas consequências para os engenheiros de software. Se sua resposta for não, justifique. Se você acha que sim, que vai reduzir as oportunidades de emprego, é ética a resistência passiva ou ativa, pelos engenheiros afetados, à introdução dessa tecnologia?</p><h2 id=próximos-passos><span class=heading-text>Próximos Passos</span><span class=heading-arabic>3.7</span></h2><p>No próximo tópico, mergulharemos no <a href=4-agile-development.html>Desenvolvimento Ágil: Scrum e XP</a>. Veremos como a necessidade de lidar com a rápida mudança nos requisitos de negócios impulsionou o surgimento de métodos que rompem com a rigidez dos modelos tradicionais. Exploraremos em detalhes o funcionamento de metodologias como <strong>Scrum</strong> e <strong>Extreme Programming (XP)</strong>, entendendo como elas reconfiguram as atividades fundamentais de software para priorizar a entrega contínua de valor e a colaboração intensa.</p></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Engenharia de Software`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>