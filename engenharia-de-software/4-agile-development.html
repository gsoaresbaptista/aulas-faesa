<!doctype html><html lang=pt-BR><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Toposia - Engenharia de Software</title><link media="(prefers-color-scheme: light)" href=/img/dark-favicon.svg rel=icon><link media="(prefers-color-scheme: dark)" href=/img/light-favicon.svg rel=icon><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel=stylesheet><link href=/css/bundle.min.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css rel=stylesheet><script src=https://unpkg.com/lucide@latest></script></head><body><div class=page-wrapper><nav class=sidebar><div class=sidebar-content><header class=sidebar-title-section><a class=course-title-link href=contents.html> <h1 class=sidebar-course-title>Engenharia de Software</h1> </a><div class=sidebar-ornament>❧</div></header><section class=sidebar-toc-section><h2 class=toc-header>Tabela de Conteúdos</h2><ol class=toc-list><li class="toc-item level-2"><a href=#introdução-o-contexto-da-agilidade>4.1. Introdução: O Contexto da Agilidade</a></li><li class="toc-item level-2"><a href=#métodos-ágeis-e-o-manifesto>4.2. Métodos Ágeis e o Manifesto</a></li><li class="toc-item level-2"><a href=#comparativo-ágil-vs-dirigido-a-planos>4.3. Comparativo: Ágil vs. Dirigido a Planos</a></li><li class="toc-item level-2"><a href=#extreme-programming-xp>4.4. Extreme Programming (XP)</a></li><li class="toc-item level-3"><a href=#testes-em-xp>4.4.1. Testes em XP</a></li><li class="toc-item level-3"><a href=#programação-em-pares>4.4.2. Programação em Pares</a></li><li class="toc-item level-2"><a href=#gerenciamento-ágil-com-scrum>4.5. Gerenciamento Ágil com Scrum</a></li><li class="toc-item level-2"><a href=#escalamento-de-métodos-ágeis>4.6. Escalamento de métodos ágeis</a></li><li class="toc-item level-2"><a href=#questões>4.7. Questões</a></li><li class="toc-item level-2"><a href=#próximos-passos>4.8. Próximos passos</a></li></ol></section><nav class=sidebar-nav-section><a class="sidebar-nav-link prev" href=3-software-process-models.html><i class=nav-icon data-lucide=chevron-left></i> Modelos de Processos de Software</a><a class="sidebar-nav-link back" href=javascript:void(0) onclick=handleBackNavigation()><i class=nav-icon data-lucide=arrow-left></i> Voltar</a></nav></div></nav><button aria-label=Menu class=mobile-menu-toggle><div class=hamburger-container><span class=hamburger-line></span><span class=hamburger-line></span><span class=hamburger-line></span></div></button><button aria-label="Alternar Barra Lateral" class=sidebar-toggle onclick=CourseForgeNav.toggleSidebar()><i class=toggle-icon data-lucide=chevron-left></i></button><div class=mobile-menu-overlay></div><main class=main-content><article class=article><header class=article-header><span class=chapter-number>4</span><h1 class=article-title><span class="title-ornament left">❧</span> <span class=title-text>Desenvolvimento Ágil: Scrum e XP</span> <span class="title-ornament right">❧</span></h1><p class=article-date>02/02/2026</p><nav aria-label=Breadcrumb class=breadcrumb><a class=breadcrumb-link href=contents.html>Engenharia de Software</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><a class=breadcrumb-link href=contents.html#part-I>I - Processos de Software</a><span class=breadcrumb-separator><i class=breadcrumb-icon data-lucide=chevron-right></i></span><span class=breadcrumb-current>Desenvolvimento Ágil: Scrum e XP</span></nav></header><div class=article-body><h2 id=introdução-o-contexto-da-agilidade><span class=heading-text>Introdução: O Contexto da Agilidade</span><span class=heading-arabic>4.1</span></h2><p>Nos dias de hoje, as empresas operam num ambiente global caracterizado por mudanças extremamente rápidas e imprevisíveis. Para que essas organizações se mantenham competitivas e sobrevivam, elas precisam de responder prontamente a novas oportunidades de negócio, conquistar novos mercados antes da concorrência, adaptar-se a alterações súbitas nas condições económicas e enfrentar o surgimento constante de produtos e serviços rivais.</p><p>Como o software tornou-se parte integrante e indissociável de quase todas as operações de negócios, a pressão por velocidade recai diretamente sobre as equipas de desenvolvimento. Novos sistemas precisam de ser criados rapidamente para aproveitar essas oportunidades e responder às ameaças competitivas. Consequentemente, a entrega rápida e a flexibilidade deixaram de ser diferenciais para se tornarem requisitos críticos de sobrevivência.</p><p>Nesse cenário dinâmico, o modelo tradicional de desenvolvimento, também conhecido como modelo em cascata ou <em>waterfall</em> (onde se especifica tudo detalhadamente antes de escrever uma linha de código), muitas vezes falha. Ele falha porque assume uma estabilidade de requisitos que simplesmente não existe mais. É aqui que entram os métodos ágeis. O objetivo principal da engenharia de software ágil é justamente permitir o desenvolvimento incremental e a entrega rápida de software funcional.</p><p>Esses processos compartilham algumas características fundamentais que deve conhecer e diferenciar. Primeiramente, as etapas de especificação, projeto e implementação são intercaladas. Ou seja, em vez de fases distintas e sequenciais, elas acontecem simultaneamente ou em ciclos muito curtos de <em>feedback</em>. Além disso, o sistema é desenvolvido numa série de incrementos ou versões; a cada ciclo, uma parte usável do software é entregue. As ferramentas de apoio ao desenvolvimento, como ambientes de desenvolvimento integrados (IDEs) modernos e ferramentas de visualização de código, são utilizadas extensivamente para dar suporte a esse ritmo acelerado, automatizando tarefas repetitivas. Por fim, há um envolvimento constante e ativo dos usuários finais e demais interessados no sistema (stakeholders), que validam cada versão entregue, garantindo que o produto final realmente atenda às suas necessidades, mesmo que elas mudem durante o processo.</p><h2 id=métodos-ágeis-e-o-manifesto><span class=heading-text>Métodos Ágeis e o Manifesto</span><span class=heading-arabic>4.2</span></h2><p>Nas décadas de 1980 e 1990, predominava a visão de que o desenvolvimento de software de qualidade dependia de um planejamento cuidadoso, processos rigorosos e documentação extensiva. Essa abordagem, derivada da engenharia de sistemas críticos e aeroespaciais, justificava seu alto custo de coordenação pela complexidade desses projetos. No entanto, quando aplicada a sistemas corporativos menores e dinâmicos, essa metodologia dirigida a planos gerava um overhead excessivo, tornando o desenvolvimento mais lento do que a evolução dos requisitos do mercado. A insatisfação com essa rigidez e o desperdício de tempo em documentação levaram ao surgimento dos métodos ágeis na década de 1990, que mudaram o foco para a entrega rápida de software útil.</p><p>Essa nova filosofia foi consolidada no Manifesto Ágil, que inverteu os valores tradicionais ao priorizar indivíduos e interações, software em funcionamento, colaboração com o cliente e resposta a mudanças, em detrimento de processos, ferramentas, documentação abrangente e negociação de contratos. Métodos como Extreme Programming (XP), Scrum e DSDM, embora proponham processos diferentes, compartilham um conjunto de princípios fundamentais baseados nesse manifesto, conforme detalhado na tabela abaixo:</p><table><thead><tr><th style=text-align:left>Princípio</th><th style=text-align:left>Descrição</th></tr></thead><tbody><tr><td style=text-align:left><strong>Envolvimento do cliente</strong></td><td style=text-align:left>Os clientes devem estar intimamente envolvidos no processo, fornecendo e priorizando novos requisitos e avaliando as iterações do sistema.</td></tr><tr><td style=text-align:left><strong>Entrega incremental</strong></td><td style=text-align:left>O software é desenvolvido em incrementos, com o cliente especificando os requisitos a serem incluídos em cada ciclo.</td></tr><tr><td style=text-align:left><strong>Pessoas, não processos</strong></td><td style=text-align:left>As habilidades da equipe de desenvolvimento devem ser reconhecidas e exploradas; os membros devem ter autonomia para desenvolver suas próprias maneiras de trabalhar, sem processos prescritivos.</td></tr><tr><td style=text-align:left><strong>Aceitar as mudanças</strong></td><td style=text-align:left>Deve-se assumir que os requisitos do sistema mudarão e projetar o sistema de maneira flexível para acomodar essas alterações.</td></tr><tr><td style=text-align:left><strong>Manter a simplicidade</strong></td><td style=text-align:left>O foco deve estar na simplicidade, tanto do software quanto do processo, trabalhando ativamente para eliminar complexidade desnecessária.</td></tr></tbody></table><p>Embora esses métodos sejam altamente eficazes para o desenvolvimento de produtos comerciais e sistemas personalizados internos, sua aplicação enfrenta barreiras práticas significativas. O sucesso depende, por exemplo, de um cliente disposto e capaz de dedicar tempo integral à equipe, o que nem sempre é possível devido a pressões externas. Além disso, a cultura organizacional de grandes empresas, habituadas a processos formais, muitas vezes resiste à informalidade e à autonomia exigidas pelo modelo ágil, e nem todos os desenvolvedores possuem o perfil de personalidade necessário para a intensa colaboração interpessoal que o método exige.</p><p>Outro desafio crítico é o aspecto contratual e a manutenção de longo prazo. Como a especificação incremental é inerente ao ágil, torna-se difícil firmar contratos tradicionais de escopo fechado, levando a disputas sobre prazos e custos caso surjam problemas. No que tange à manutenção, a ênfase em código limpo em vez de documentação formal pode ser arriscada: se a equipe original se desfizer, o conhecimento implícito sobre o sistema é perdido, dificultando a evolução do software por novos membros que não têm um documento de requisitos coerente para consultar. Devido a esses fatores, especialistas sugerem que, para muitos projetos, uma abordagem híbrida que incorpore técnicas de planejamento tradicional aos métodos ágeis pode ser o caminho mais seguro.</p><h2 id=comparativo-ágil-vs-dirigido-a-planos><span class=heading-text>Comparativo: Ágil vs. Dirigido a Planos</span><span class=heading-arabic>4.3</span></h2><p>As abordagens ágeis e as dirigidas a planos diferem fundamentalmente na forma como estruturam as atividades. Enquanto o ágil considera o projeto e a implementação como atividades centrais, incorporando elicitação de requisitos e testes nesse fluxo contínuo, a abordagem dirigida a planos identifica estágios distintos, onde a saída documental de uma fase serve de base para o planejamento da próxima. Essa distinção, onde o modelo dirigido a planos comunica-se via documentos formais e o ágil itera requisitos e projeto conjuntamente, é ilustrada na figura abaixo:</p><img src=static/fig3_1_especificacoes_agil_planos.png width=60%><p>É importante notar que essas fronteiras não são rígidas. Um processo dirigido a planos pode apoiar entregas incrementais, assim como equipes ágeis podem produzir documentação formal quando necessário. Na verdade, a maioria dos projetos de software inclui práticas das abordagens dirigidas a planos e ágil. Para optar por um equilíbrio entre as abordagens, você precisa responder a uma série de questões técnicas, humanas e organizacionais, resumidas na tabela a seguir:</p><table><thead><tr><th style=text-align:left>Questão / Fator</th><th style=text-align:left>Consideração e Indicação</th></tr></thead><tbody><tr><td style=text-align:left><strong>Detalhe Prévio</strong></td><td style=text-align:left>É importante ter especificação e projeto detalhados antes da implementação? Se sim, indica uma abordagem <strong>dirigida a planos</strong>.</td></tr><tr><td style=text-align:left><strong>Feedback Incremental</strong></td><td style=text-align:left>É realista entregar software rapidamente para obter feedback do cliente? Se sim, considere o uso de <strong>métodos ágeis</strong>.</td></tr><tr><td style=text-align:left><strong>Tamanho do Sistema</strong></td><td style=text-align:left>O sistema é muito grande? <strong>Métodos ágeis</strong> funcionam melhor com equipes pequenas e colocalizadas. Grandes sistemas exigem equipes maiores e coordenação, favorecendo a abordagem <strong>dirigida a planos</strong>.</td></tr><tr><td style=text-align:left><strong>Tipo de Sistema</strong></td><td style=text-align:left>Sistemas de tempo real ou complexos exigem análise profunda prévia? Se sim, um projeto detalhado (<strong>dirigido a planos</strong>) é a melhor opção.</td></tr><tr><td style=text-align:left><strong>Tempo de Vida</strong></td><td style=text-align:left>O sistema terá vida longa? Sistemas duradouros podem exigir documentação extensa para manutenção futura (<strong>dirigido a planos</strong>), embora defensores do ágil argumentem que documentação desatualizada é inútil.</td></tr><tr><td style=text-align:left><strong>Ferramentas (IDE)</strong></td><td style=text-align:left>Existem boas ferramentas de visualização e controle? <strong>Métodos ágeis</strong> dependem de bom suporte tecnológico; sem ele, mais documentação de projeto pode ser necessária.</td></tr><tr><td style=text-align:left><strong>Organização da Equipe</strong></td><td style=text-align:left>A equipe é distribuída ou terceirizada? A necessidade de documentos para comunicação entre times distantes favorece o planejamento prévio.</td></tr><tr><td style=text-align:left><strong>Cultura Organizacional</strong></td><td style=text-align:left>A cultura é de engenharia tradicional? Organizações acostumadas a normas rígidas tendem a exigir documentação extensa (<strong>dirigido a planos</strong>) em vez do conhecimento informal.</td></tr><tr><td style=text-align:left><strong>Habilidade da Equipe</strong></td><td style=text-align:left>Qual o nível dos desenvolvedores? <strong>Métodos ágeis</strong> geralmente exigem alta habilidade. Se a equipe tem nível menor, é melhor que especialistas projetem para que outros codifiquem (<strong>dirigido a planos</strong>).</td></tr><tr><td style=text-align:left><strong>Regulamentação</strong></td><td style=text-align:left>Há regulamentação externa (ex: aviação, saúde)? A necessidade de aprovação de segurança e auditoria torna obrigatória a produção de documentação detalhada (<strong>dirigido a planos</strong>).</td></tr></tbody></table><p>Na realidade, a questão sobre rotular o projeto como dirigido a planos ou ágil é secundária. A principal preocupação do comprador é adquirir um sistema executável que atenda às suas necessidades. Na prática, muitas empresas bem-sucedidas adotam uma postura híbrida, integrando práticas ágeis dentro de seus processos dirigidos a planos.</p><h2 id=extreme-programming-xp><span class=heading-text>Extreme Programming (XP)</span><span class=heading-arabic>4.4</span></h2><p>Extreme Programming (XP) é talvez o método ágil mais conhecido e amplamente utilizado, cujo nome foi cunhado por Kent Beck (2000) com a premissa de elevar práticas de desenvolvimento reconhecidamente boas a níveis "extremos" de disciplina. Em vez de integrar o código apenas no final do mês, no XP a integração e os testes ocorrem várias vezes ao dia. O ciclo de vida é rápido e focado em feedback constante, onde programadores trabalham em pares, escrevem testes antes mesmo do código e realizam releases frequentes, conforme ilustrado no fluxo abaixo:</p><img src=static/fig3_2_ciclo_xp.png width=75%><p>Para sustentar esse ritmo, o XP fundamenta-se em um conjunto de práticas que devem ser seguidas disciplinarmente. Diferente de processos que dependem de burocracia, o XP depende da sinergia entre as seguintes técnicas:</p><table><thead><tr><th style=text-align:left>Prática</th><th style=text-align:left>Descrição</th></tr></thead><tbody><tr><td style=text-align:left><strong>Planejamento Incremental</strong></td><td style=text-align:left>Requisitos são gravados em "cartões de estória". O conteúdo de um release é determinado pelo tempo disponível e prioridade.</td></tr><tr><td style=text-align:left><strong>Pequenos Releases</strong></td><td style=text-align:left>O sistema é desenvolvido em versões frequentes, começando com um conjunto mínimo de funcionalidades que gere valor.</td></tr><tr><td style=text-align:left><strong>Projeto Simples</strong></td><td style=text-align:left>O design deve atender apenas às necessidades atuais. Evita-se antecipar complexidade para mudanças futuras (<em>YAGNI</em>).</td></tr><tr><td style=text-align:left><strong>Desenvolvimento</strong> <em><strong>Test-First</strong></em></td><td style=text-align:left>Testes automatizados são escritos <em>antes</em> da funcionalidade. O código só é aceito se passar nos testes.</td></tr><tr><td style=text-align:left><strong>Refatoração</strong></td><td style=text-align:left>Melhoria contínua da estrutura do código sem alterar seu comportamento, mantendo o software simples e manutenível.</td></tr><tr><td style=text-align:left><strong>Programação em Pares</strong></td><td style=text-align:left>Desenvolvedores trabalham em duplas na mesma máquina: um codifica, o outro revisa. Isso difunde conhecimento e qualidade.</td></tr><tr><td style=text-align:left><strong>Propriedade Coletiva</strong></td><td style=text-align:left>Não existem donos de módulos. Qualquer desenvolvedor pode alterar qualquer parte do código a qualquer momento.</td></tr><tr><td style=text-align:left><strong>Integração Contínua</strong></td><td style=text-align:left>Assim que uma tarefa termina, é integrada ao sistema principal. Todos os testes devem rodar com sucesso imediatamente.</td></tr><tr><td style=text-align:left><strong>Ritmo Sustentável</strong></td><td style=text-align:left>Horas extras excessivas são desencorajadas, pois a fadiga reduz a qualidade do código a médio prazo.</td></tr><tr><td style=text-align:left><strong>Cliente no Local</strong></td><td style=text-align:left>Um representante do usuário deve estar disponível em tempo integral junto à equipe para esclarecer dúvidas e priorizar.</td></tr></tbody></table><p>O processo de planejamento, conhecido como "Jogo de Planejamento", transforma necessidades abstratas em código executável. O cliente escreve "estórias" (cenários de uso) em cartões. Abaixo, temos um exemplo prático (Quadro 3.1) de como um requisito complexo de saúde é descrito em linguagem natural pelo cliente:</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Quadro 3.1: Estória de Usuário - Prescrição de Medicamentos</span></div><div class=callout-content><strong>Cenário:</strong> Kate é uma médica que deseja prescrever medicamentos para um paciente de uma clínica. O prontuário já está sendo exibido. Ela clica em 'medicação' e pode selecionar: 'medicação atual', 'nova medicação' ou 'formulário'. <ul><li><strong>Se 'medicação atual':</strong> O sistema pede verificação da dose. Ela pode alterar e confirmar.</li><li><strong>Se 'nova medicação':</strong> Ela digita as iniciais, o sistema lista fármacos possíveis. Ela escolhe, o sistema pede verificação, ela insere a dose e confirma.</li><li><strong>Se 'formulário':</strong> O sistema exibe busca no formulário aprovado. Ela seleciona, verifica e insere a dose.</li></ul><p><strong>Regra Crítica:</strong> O sistema sempre verifica se a dose está dentro da faixa permitida. Caso não esteja, solicita alteração. Após confirmação, a prescrição é gravada para auditoria.</p></div></div><p>Uma vez definida a estória, a equipe de desenvolvimento a analisa e a decompõe em tarefas técnicas menores e estimáveis (Quadro 3.2). Se houver incerteza técnica, a equipe pode realizar um <em>"Spike"</em> (um tempo dedicado apenas à investigação sem entrega de código).</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Quadro 3.2: Tarefas Técnicas Derivadas</span></div><div class=callout-content><p>A equipe divide a estória acima nas seguintes tarefas de implementação:</p><ul><li><strong>Tarefa 1:</strong> Alterar dose de medicamentos prescritos.</li><li><strong>Tarefa 2:</strong> Seleção de formulário (Interface e Busca).</li><li><strong>Tarefa 3:</strong> Verificação de dose.<ul><li><em>Detalhe:</em> Usando o ID do formulário, buscar dose mínima e máxima recomendada.</li><li><em>Lógica:</em> Se a dose prescrita estiver fora da faixa, emitir erro ("Muito alta" ou "Muito baixa"). Se estiver dentro, habilitar botão 'Confirmar'.</li></ul></li></ul></div></div><p>Essa abordagem desafia a engenharia tradicional ao descartar o princípio de "projetar para a mudança" (tentar antecipar requisitos futuros na arquitetura). O XP assume que o futuro é incerto e que antecipação gera desperdício. Em vez disso, a metodologia aceita que mudanças ocorrerão e confia na <strong>refatoração</strong> constante para reorganizar o software quando necessário. Embora essa falta de design prévio possa degradar a estrutura do código se não for vigiada, a refatoração contínua, apoiada por ferramentas modernas que automatizam essas mudanças, mantém o sistema limpo. Na prática, muitas empresas adaptam o XP, utilizando suas práticas técnicas (como testes automatizados e integração contínua), mas flexibilizando aspectos organizacionais como a programação em pares ou a presença física do cliente.</p><h3 id=testes-em-xp><span class=heading-text>Testes em XP</span><span class=heading-arabic>4.4.1</span></h3><p>A abordagem de testes no desenvolvimento incremental difere significativamente do desenvolvimento dirigido a planos. No contexto incremental, a ausência de uma especificação formal do sistema impede que uma equipe externa desenvolva testes de sistema tradicionais. Consequentemente, alguns métodos ágeis possuem processos de teste informais. Para mitigar problemas de validação, o Extreme Programming (XP) enfatiza a importância crítica dos testes de programa, adotando uma postura que visa reduzir a probabilidade de erros desconhecidos na versão atual do sistema.</p><p>As principais características que definem a estratégia de testes no XP são o desenvolvimento <em>test-first</em>, a criação incremental de testes a partir de cenários, o envolvimento ativo dos usuários na validação e o uso extensivo de frameworks de automação. O desenvolvimento <em>test-first</em> representa uma das inovações mais marcantes desta metodologia. Ao invés de escrever o código e posteriormente os testes, o desenvolvedor escreve os testes antes da implementação. Esta prática permite a execução imediata dos testes durante a codificação, facilitando a identificação precoce de problemas.</p><p>Ao escrever os testes antecipadamente, define-se implicitamente uma interface e uma especificação de comportamento para a funcionalidade. Essa abordagem reduz ambiguidades de requisitos e mal-entendidos de interface, sendo aplicável sempre que houver uma relação clara entre um requisito e sua implementação. No XP, essa ligação é visível pois os cartões de histórias (requisitos) são divididos em tarefas, que servem como unidade principal de implementação. Além disso, essa prática evita o problema de <em>test-lag</em>, que ocorre quando a implementação avança muito à frente dos testes, levando a uma tendência de ignorar a validação para cumprir cronogramas.</p><p>Os requisitos do usuário em XP são expressos como cenários ou histórias, priorizados pelo cliente. A equipe de desenvolvimento avalia cada cenário e o divide em tarefas, onde cada tarefa gera um ou mais testes de unidade. No processo de testes, o papel do cliente é fundamental para ajudar a desenvolver testes de aceitação para as histórias do próximo <em>release</em>. O teste de aceitação verifica se o sistema atende às reais necessidades do cliente utilizando seus próprios dados. Abaixo, apresenta-se um exemplo prático da estrutura de um caso de teste para prescrição médica:</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Quadro 3.3: Descrição do caso de teste para verificação de dose</span></div><div class=callout-content><p>Este quadro ilustra como os parâmetros de entrada e saída são definidos para garantir a segurança na prescrição de medicamentos.</p><table><thead><tr><th style=text-align:left>Componente</th><th style=text-align:left>Descrição Detalhada</th></tr></thead><tbody><tr><td style=text-align:left><strong>Entradas</strong></td><td style=text-align:left>1. Um número em mg representando uma única dose da medicação.<br>2. Um número representando a frequência (doses únicas por dia).</td></tr><tr><td style=text-align:left><strong>Cenários de Teste</strong></td><td style=text-align:left>1. Dose única correta, mas frequência muito alta.<br>2. Dose única excessivamente alta ou muito baixa.<br>3. Produto (Dose × Frequência) muito alto ou muito baixo.<br>4. Produto (Dose × Frequência) dentro do permitido.</td></tr><tr><td style=text-align:left><strong>Saída Esperada</strong></td><td style=text-align:left>Mensagem de "OK" ou erro indicando que a dose está fora da faixa de segurança.</td></tr></tbody></table></div></div><p>Uma grande dificuldade encontrada no XP é obter o apoio contínuo do cliente para o desenvolvimento desses testes de aceitação, visto que eles frequentemente possuem tempo limitado e podem considerar a simples entrega dos requisitos como contribuição suficiente.</p><p>A automação é essencial para sustentar o desenvolvimento <em>test-first</em>. Os testes são escritos como componentes executáveis e autônomos que simulam a entrada e verificam a saída. Frameworks como o JUnit facilitam a escrita e execução desses conjuntos de testes. Como a validação é automatizada, sempre que uma nova funcionalidade é adicionada, os testes podem ser executados rapidamente para detectar regressões ou novos defeitos.</p><p>Apesar de o desenvolvimento <em>test-first</em> e a automação gerarem um grande volume de testes, isso não garante necessariamente a completude da validação do programa. Existem três razões principais para essa limitação, conforme detalhado na tabela a seguir:</p><table><thead><tr><th style=text-align:left>Limitação</th><th style=text-align:left>Descrição do Problema</th></tr></thead><tbody><tr><td style=text-align:left><strong>Atalhos na Escrita</strong></td><td style=text-align:left>Programadores podem escrever testes incompletos que não verificam todas as exceções possíveis, apenas para cumprir a tarefa.</td></tr><tr><td style=text-align:left><strong>Complexidade de Interface</strong></td><td style=text-align:left>É difícil escrever testes unitários incrementais para interfaces de usuário complexas, especialmente para a lógica de exibição e fluxo de telas.</td></tr><tr><td style=text-align:left><strong>Cobertura Incompleta</strong></td><td style=text-align:left>Mesmo com muitos testes, partes essenciais do sistema podem não ser executadas, criando uma falsa sensação de segurança se os testes não forem revisados adequadamente.</td></tr></tbody></table><h3 id=programação-em-pares><span class=heading-text>Programação em Pares</span><span class=heading-arabic>4.4.2</span></h3><p>Uma das práticas mais inovadoras introduzidas no Extreme Programming (XP) é a <strong>programação em pares</strong>. Neste modelo, os desenvolvedores sentam-se juntos na mesma estação de trabalho para desenvolver o software. É fundamental destacar que essas duplas não são estáticas, pelo contrário, os pares são formados de maneira dinâmica, garantindo que todos os membros da equipe trabalhem uns com os outros ao longo do processo de desenvolvimento.</p><p>A adoção dessa metodologia oferece benefícios estruturais significativos para a equipe e para a qualidade do código, conforme detalhado na tabela a seguir:</p><table><thead><tr><th style=text-align:left>Vantagem</th><th style=text-align:left>Descrição e Impacto</th></tr></thead><tbody><tr><td style=text-align:left><strong>Propriedade Coletiva</strong></td><td style=text-align:left>Promove a ideia de "responsabilidade coletiva" e reflete o conceito de <em>programação sem ego</em> de Weinberg (1971). O software pertence à equipe como um todo, eliminando a culpa individual por erros.</td></tr><tr><td style=text-align:left><strong>Revisão Informal</strong></td><td style=text-align:left>Atua como um processo contínuo de revisão, onde cada linha é observada por duas pessoas. Embora seja menos formal que inspeções dedicadas, é um método de verificação muito mais barato e eficaz na detecção de erros.</td></tr><tr><td style=text-align:left><strong>Suporte à Refatoração</strong></td><td style=text-align:left>Facilita a melhoria contínua do software. Diferente do trabalho individual, onde a refatoração pode parecer ineficiente a curto prazo, na programação em pares o benefício é imediato e compartilhado por toda a equipe.</td></tr></tbody></table><p>Existe um debate comum sobre a eficiência dessa prática, baseado na intuição de que dois desenvolvedores trabalhando juntos produziriam apenas metade do código que produziriam separadamente. Estudos acadêmicos apresentam conclusões variadas sobre o tema. Pesquisas utilizando estudantes voluntários (Williams et al.) sugeriram que a produtividade é comparável à do trabalho individual, pois a discussão prévia reduz falsos começos e o retrabalho. Por outro lado, estudos com programadores experientes (Arisholm et al.) indicaram uma perda de produtividade significativa, onde os ganhos de qualidade não compensaram totalmente o custo adicional.</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>A Importância da Gestão de Risco</span></div><div class=callout-content><p>Independentemente das métricas de velocidade de codificação, o <strong>compartilhamento de conhecimento</strong> que ocorre durante a programação em pares é um ativo valioso. Ele reduz drasticamente os riscos globais do projeto caso um membro da equipe precise sair, o que, por si só, pode justificar a adoção da prática.</p></div></div><h2 id=gerenciamento-ágil-com-scrum><span class=heading-text>Gerenciamento Ágil com Scrum</span><span class=heading-arabic>4.5</span></h2><p>A principal responsabilidade dos gerentes de projeto de software reside em garantir a entrega do produto dentro do prazo e do orçamento previstos, supervisionando o trabalho dos engenheiros e monitorando o progresso do desenvolvimento. Tradicionalmente, a abordagem padrão é dirigida a planos, exigindo que o gerente possua uma visão estável de todo o escopo e dos processos de desenvolvimento. No entanto, essa rigidez não se adapta bem aos métodos ágeis, nos quais os requisitos são incrementais e as mudanças são a norma. O desenvolvimento ágil requer uma gestão adaptada para ciclos curtos e para a maximização dos recursos disponíveis.</p><p>Nesse contexto, a abordagem Scrum destaca-se como um método ágil focado no gerenciamento do desenvolvimento iterativo, ao invés de prescrever práticas técnicas específicas. O Scrum não dita o uso de práticas como programação em pares ou desenvolvimento <em>test-first</em>, o que permite sua combinação com frameworks técnicos como o XP (Extreme Programming). O fluxo de gerenciamento desse processo é visualizado na figura abaixo:</p><img src=static/fig3_3_processo_scrum.png width=75%><p>O ciclo de vida no Scrum divide-se fundamentalmente em três fases. A primeira consiste no <strong>planejamento geral</strong>, onde se definem os objetivos e a arquitetura do software. A segunda fase é composta por <strong>ciclos de sprint</strong>, onde ocorre o desenvolvimento incremental do sistema. Por fim, a fase de <strong>encerramento</strong> completa a documentação e avalia as lições aprendidas. A grande inovação do Scrum reside justamente na sua fase central, os sprints, que são unidades de planejamento onde o trabalho é avaliado, selecionado e implementado.</p><p>As características essenciais que regem o funcionamento de um Sprint estão detalhadas na tabela a seguir:</p><table><thead><tr><th style=text-align:left>Etapa do Processo</th><th style=text-align:left>Características e Ações</th></tr></thead><tbody><tr><td style=text-align:left><strong>Duração e Estrutura</strong></td><td style=text-align:left>Os sprints possuem comprimento fixo (normalmente duas a quatro semanas), correspondendo ao desenvolvimento de um <em>release</em> no XP.</td></tr><tr><td style=text-align:left><strong>Planejamento (Backlog)</strong></td><td style=text-align:left>O ponto de partida é o <em>backlog</em> do produto. Durante a avaliação, este é revisto com o cliente para identificar prioridades e riscos, permitindo a introdução de novos requisitos.</td></tr><tr><td style=text-align:left><strong>Seleção</strong></td><td style=text-align:left>A equipe do projeto e o cliente trabalham juntos para selecionar as funcionalidades que serão desenvolvidas no ciclo atual.</td></tr><tr><td style=text-align:left><strong>Execução e Organização</strong></td><td style=text-align:left>A equipe se organiza para o desenvolvimento com reuniões diárias (<em>stand-ups</em>) para analisar progressos. A equipe permanece isolada de distrações externas.</td></tr><tr><td style=text-align:left><strong>Revisão</strong></td><td style=text-align:left>Ao final do sprint, a funcionalidade completa é entregue e apresentada aos <em>stakeholders</em>, iniciando-se o ciclo seguinte imediatamente.</td></tr></tbody></table><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>O Papel do Scrum Master</span></div><div class=callout-content><p>No Scrum, o termo "gerente de projeto" é evitado deliberadamente em favor de uma equipe com poderes de decisão. O <strong>Scrum Master</strong> atua como um facilitador, não como um chefe hierárquico. Ele organiza as reuniões diárias, controla o backlog, registra decisões e, crucialmente, protege a equipe de desenvolvimento de interrupções externas. As reuniões diárias garantem que todos saibam o que está acontecendo e permitem o replanejamento rápido de curto prazo.</p></div></div><p>A eficácia do Scrum é amplamente documentada, com relatos de sucesso em diversos setores, como telecomunicações. As vantagens observadas na aplicação desse método, segundo Rising e Janoff (2000), incluem:</p><table><thead><tr><th style=text-align:left>Vantagem</th><th style=text-align:left>Impacto no Projeto</th></tr></thead><tbody><tr><td style=text-align:left><strong>Decomposição</strong></td><td style=text-align:left>O produto é dividido em partes gerenciáveis e compreensíveis.</td></tr><tr><td style=text-align:left><strong>Resiliência</strong></td><td style=text-align:left>Requisitos instáveis não atrasam o progresso geral.</td></tr><tr><td style=text-align:left><strong>Visibilidade</strong></td><td style=text-align:left>Toda a equipe possui visão do todo, melhorando significativamente a comunicação.</td></tr><tr><td style=text-align:left><strong>Feedback Contínuo</strong></td><td style=text-align:left>Os clientes observam entregas no prazo e fornecem retorno sobre o funcionamento do produto.</td></tr><tr><td style=text-align:left><strong>Cultura Positiva</strong></td><td style=text-align:left>Estabelece-se confiança entre clientes e desenvolvedores, criando um ambiente focado no êxito.</td></tr></tbody></table><p>Embora o Scrum tenha sido originalmente concebido para equipes colocalizadas, permitindo reuniões presenciais diárias, a realidade atual do desenvolvimento de software frequentemente envolve equipes distribuídas globalmente. Consequentemente, diversas experiências e adaptações estão em curso para viabilizar o uso do Scrum em ambientes de desenvolvimento distribuído, mantendo a agilidade e a coesão da equipe mesmo à distância.</p><h2 id=escalamento-de-métodos-ágeis><span class=heading-text>Escalamento de métodos ágeis</span><span class=heading-arabic>4.6</span></h2><p>Os métodos ágeis foram originalmente concebidos para equipes de programação de pequeno porte, situadas em um mesmo ambiente físico para facilitar a comunicação informal. No entanto, a necessidade premente de acelerar a entrega de software alinhada às demandas do cliente também se aplica a sistemas de grande escala. Autores como Denning (2008) argumentam que adaptar a agilidade para grandes sistemas é a única via para evitar falhas clássicas da engenharia de software, como estouros de orçamento e produtos desconectados das necessidades reais.</p><p>Para compreender o desafio, é necessário distinguir as características inerentes ao desenvolvimento de sistemas de grande porte, que diferem substancialmente dos projetos pequenos. A tabela a seguir detalha essas diferenças cruciais:</p><table><thead><tr><th style=text-align:left>Característica do Sistema</th><th style=text-align:left>Impacto e Desafios</th></tr></thead><tbody><tr><td style=text-align:left><strong>Equipes Distribuídas</strong></td><td style=text-align:left>Grandes sistemas são coleções de subsistemas desenvolvidos por equipes separadas, muitas vezes em fusos horários diferentes. A falta de visão global leva ao foco apenas em partes locais, ignorando o todo.</td></tr><tr><td style=text-align:left><strong>Sistemas</strong> <em><strong>Brownfield</strong></em></td><td style=text-align:left>Incluem e interagem com sistemas legados (<em>brownfield</em>). A rigidez dessas integrações limita a flexibilidade e o desenvolvimento incremental, muitas vezes exigindo negociações políticas complexas para alterações.</td></tr><tr><td style=text-align:left><strong>Configuração vs. Criação</strong></td><td style=text-align:left>Uma fração significativa do trabalho foca na configuração e integração de sistemas existentes, o que nem sempre é compatível com a integração frequente de código novo.</td></tr><tr><td style=text-align:left><strong>Regulações Externas</strong></td><td style=text-align:left>Processos são frequentemente restringidos por regras e regulamentos externos que exigem documentação específica e limitam a liberdade de desenvolvimento.</td></tr><tr><td style=text-align:left><strong>Longo Prazo e Turnover</strong></td><td style=text-align:left>O tempo de aquisição e desenvolvimento é extenso. Manter o conhecimento acumulado é difícil, pois a equipe muda inevitavelmente ao longo do projeto.</td></tr><tr><td style=text-align:left><strong>Stakeholders Diversos</strong></td><td style=text-align:left>O grupo de interessados é vasto e heterogêneo (de enfermeiros a diretores executivos), tornando quase impossível envolver todos diretamente no processo de desenvolvimento.</td></tr></tbody></table><p>Ao abordar a expansão do agilismo, identificam-se duas perspectivas distintas. A primeira é o <strong>Scaling Up</strong>, referente ao uso de métodos ágeis para desenvolver sistemas grandes e complexos. A segunda é o <strong>Scaling Out</strong>, que diz respeito à introdução desses métodos em grandes organizações com culturas estabelecidas.</p><p>Para o sucesso do <em>Scaling Up</em>, Leffingwell (2007) defende a manutenção dos fundamentos ágeis, como planejamento flexível e integração contínua, mas com adaptações críticas para suportar a escala:</p><div class="callout callout-note"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><path d="M15 3v6h6"/><path d="M9 13h6"/><path d="M9 17h3"/></svg></span><span class=callout-title-inner>Adaptações Críticas para Grandes Sistemas</span></div><div class=callout-content><ol><li><strong>Projeto e Documentação:</strong> Ao contrário de projetos pequenos, não é possível focar apenas no código. É necessário um projeto de arquitetura prévio e documentação robusta (esquemas de banco de dados, divisão de trabalho) para coordenar as múltiplas equipes.</li><li><strong>Mecanismos de Comunicação:</strong> Devem ser projetados canais formais e frequentes, incluindo videoconferências e reuniões interequipes, suportados por ferramentas como wikis e mensageiros instantâneos.</li><li><strong>Integração e Ferramentas:</strong> A integração contínua torna-se complexa com múltiplos subsistemas. Ferramentas avançadas de gerenciamento de configuração são essenciais para manter construções frequentes e releases regulares em um ambiente multiequipe.</li></ol></div></div><p>Por outro lado, o <em>Scaling Out</em> enfrenta barreiras organizacionais. Enquanto pequenas empresas adotam o ágil rapidamente por falta de burocracia, grandes corporações enfrentam dificuldades significativas na transição cultural e processual.</p><p>Os principais obstáculos enfrentados por grandes empresas ao tentar "escalar para fora" o ágil incluem:</p><table><thead><tr><th style=text-align:left>Obstáculo Organizacional</th><th style=text-align:left>Descrição do Conflito</th></tr></thead><tbody><tr><td style=text-align:left><strong>Aversão ao Risco</strong></td><td style=text-align:left>Gerentes de projeto sem experiência ágil relutam em abandonar planos tradicionais, temendo a imprevisibilidade sobre seus projetos específicos.</td></tr><tr><td style=text-align:left><strong>Padrões Burocráticos</strong></td><td style=text-align:left>Procedimentos de qualidade e ferramentas obrigatórias preexistentes são frequentemente rígidos e incompatíveis com a fluidez ágil.</td></tr><tr><td style=text-align:left><strong>Disparidade de Habilidades</strong></td><td style=text-align:left>O ágil exige alta competência. Grandes empresas possuem níveis de habilidade variados, e profissionais menos experientes podem ter dificuldade em atuar efetivamente em equipes autogerenciáveis.</td></tr><tr><td style=text-align:left><strong>Resistência Cultural</strong></td><td style=text-align:left>Há um choque direto com a cultura de "Comando e Controle". Exemplo: O gerenciamento de mudanças tradicional exige aprovação prévia para tudo, conflitando com a refatoração livre do XP; ou equipes de teste externas separadas, que conflitam com o conceito <em>test-first</em>.</td></tr></tbody></table><p>Em suma, apresentar e sustentar métodos ágeis em uma grande organização não é apenas uma mudança técnica, mas um profundo processo de mudança cultural. Isso exige tempo, recursos significativos e "evangelizadores" internos dedicados a promover a transição, algo que poucas grandes empresas conseguiram realizar plenamente até o momento.</p><h2 id=questões><span class=heading-text>Questões</span><span class=heading-arabic>4.7</span></h2><p><strong>1.</strong> Explique por que, para as empresas que operam em mercados globais dinâmicos, a entrega rápida e a implantação contínua de novos sistemas frequentemente são consideradas mais críticas para a sobrevivência do que a funcionalidade detalhada desses sistemas.</p><p><strong>2.</strong> Explique como os princípios básicos do Manifesto Ágil (como entrega incremental e aceitação de mudanças) levam ao desenvolvimento e implantação de software acelerados, contrastando com a rigidez dos modelos dirigidos a planos.</p><p><strong>3.</strong> Com base na tabela de fatores técnicos, humanos e organizacionais apresentada no texto, cite três cenários ou características de projeto onde você <strong>não</strong> recomendaria o uso de um método ágil, preferindo uma abordagem dirigida a planos.</p><p><strong>4.</strong> O Extreme Programming (XP) expressa os requisitos dos usuários como "estórias" em cartões, em vez de documentos de especificação detalhados. Discuta as vantagens dessa abordagem para o planejamento incremental e as desvantagens potenciais para a manutenção de longo prazo e contratos de escopo fechado.</p><p><strong>5.</strong> Explique por que o desenvolvimento <em>test-first</em> (testes antes do código) ajuda o programador a desenvolver um melhor entendimento dos requisitos do sistema e a evitar ambiguidades. Quais são as limitações dessa abordagem em relação à completude da validação e interfaces complexas?</p><p><strong>6.</strong> Embora intuitivamente pareça que dois programadores trabalham o dobro se estiverem separados, sugira razões baseadas no texto (como revisão informal e refatoração) pelas quais a programação em pares pode ser considerada eficiente e benéfica para a qualidade do código e gestão de risco da equipe.</p><p><strong>7.</strong> Compare a abordagem Scrum para o gerenciamento de projetos com abordagens convencionais dirigidas a planos. Foque sua comparação na forma como cada uma lida com a incerteza dos requisitos, o planejamento das atividades (Sprints vs. Fases Longas) e o papel do gerente (Scrum Master vs. Gerente de Projeto tradicional).</p><p><strong>8.</strong> Você é um gerente de software em uma empresa responsável pelo desenvolvimento de um sistema crítico de controle para aeronaves, sujeito a rigorosas regulamentações de segurança e auditoria. Analise a viabilidade de utilizar uma abordagem puramente ágil (como XP) versus uma abordagem dirigida a planos para este projeto, considerando os fatores de "Regulamentação" e "Tipo de Sistema" discutidos no texto.</p><p><strong>9.</strong> O texto menciona que um dos desafios dos métodos ágeis é a necessidade de um cliente disponível em tempo integral ("Cliente no Local"). Discuta as dificuldades práticas de implementar esse princípio em grandes organizações e como a falta de consenso entre diferentes stakeholders pode afetar o progresso da equipe ágil.</p><p><strong>10.</strong> Para reduzir custos, sua empresa decidiu que a equipe de desenvolvimento passará a trabalhar de forma totalmente remota e distribuída. No entanto, a gerência não considerou que a equipe utiliza Scrum e programação em pares. Discuta os desafios de comunicação e coordenação que essa mudança impõe às práticas ágeis (que foram desenhadas para ambientes colocalizados) e mencione adaptações necessárias para o "Scaling Out" ou trabalho distribuído.</p><h2 id=próximos-passos><span class=heading-text>Próximos passos</span><span class=heading-arabic>4.8</span></h2><div class="callout callout-warning"><div class=callout-title><span class=callout-icon><svg viewbox="0 0 24 24" fill=none height=16 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=16 xmlns=http://www.w3.org/2000/svg><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span><span class=callout-title-inner>Conteúdo em desenvolvimento!</span></div><div class=callout-content><p>Este conteúdo ainda não foi finalizado. Assim que estiver completo, este aviso será atualizado com o link correspondente.</p></div></div></div></article><footer class=footer><p>© 2025 · <a href=#>Gabriel Soares Baptista</a></p></footer></main></div><script>const toggle=document.querySelector(`.mobile-menu-toggle`),sidebar=document.querySelector(`.sidebar`),overlay=document.querySelector(`.mobile-menu-overlay`);function openMenu(){sidebar.classList.add(`open`),overlay.classList.add(`open`),toggle.classList.add(`open`),document.body.style.overflow=`hidden`}function closeMenu(){sidebar.classList.remove(`open`),overlay.classList.remove(`open`),toggle.classList.remove(`open`),document.body.style.overflow=``}toggle.addEventListener(`click`,()=>{sidebar.classList.contains(`open`)?closeMenu():openMenu()}),overlay.addEventListener(`click`,closeMenu);</script><script src=/js/bundle.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){renderMathInElement(document.body,{delimiters:[{left:`$$`,right:`$$`,display:!0},{left:`$`,right:`$`,display:!1},{left:`\\(`,right:`\\)`,display:!1},{left:`\\[`,right:`\\]`,display:!0}],throwOnError:!1})});</script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js></script><script>document.addEventListener(`DOMContentLoaded`,function(){let isSubcourse=!1,courseName=`Engenharia de Software`;CourseForgeNav.applyDynamicBreadcrumbs(`.breadcrumb`,!1),CourseForgeNav.initSidebar(),CourseForgeNav.initScrollSpy(),CourseForgeUI.initCopyButtons()});function handleBackNavigation(){let isSubcourse=!1,dynamic=CourseForgeNav.getBackLink(`contents.html`,`Voltar`,!1);window.location.href=dynamic.url}</script></body></html>